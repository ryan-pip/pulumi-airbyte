// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface ConnectionConfigurations {
    streams: outputs.ConnectionConfigurationsStream[];
}

export interface ConnectionConfigurationsStream {
    cursorFields: string[];
    /**
     * Optional name of the connection
     */
    name: string;
    primaryKeys: string[][];
    syncMode: string;
}

export interface ConnectionSchedule {
    basicTiming: string;
    cronExpression: string;
    /**
     * must be one of ["manual", "cron"]
     */
    scheduleType: string;
}

export interface DestinationAWSDatalakeConfiguration {
    /**
     * target aws account id
     */
    awsAccountId?: string;
    /**
     * The name of the S3 bucket. Read more \n\nhere\n\n.
     */
    bucketName: string;
    /**
     * S3 prefix
     */
    bucketPrefix?: string;
    /**
     * Choose How to Authenticate to AWS.
     */
    credentials: outputs.DestinationAWSDatalakeConfigurationCredentials;
    /**
     * must be one of ["aws-datalake"]
     */
    destinationType: string;
    /**
     * Format of the data output.
     */
    format?: outputs.DestinationAWSDatalakeConfigurationFormat;
    /**
     * Cast float/double as decimal(38,18). This can help achieve higher accuracy and represent numbers correctly as received from the source.
     */
    glueCatalogFloatAsDecimal?: boolean;
    /**
     * Add a default tag key to databases created by this destination
     */
    lakeformationDatabaseDefaultTagKey?: string;
    /**
     * Add default values for the `Tag Key` to databases created by this destination. Comma separate for multiple values.
     */
    lakeformationDatabaseDefaultTagValues?: string;
    /**
     * The default database this destination will use to create tables in per stream. Can be changed per connection by customizing the namespace.
     */
    lakeformationDatabaseName: string;
    /**
     * Whether to create tables as LF governed tables.
     */
    lakeformationGovernedTables?: boolean;
    /**
     * must be one of ["NO PARTITIONING", "DATE", "YEAR", "MONTH", "DAY", "YEAR/MONTH", "YEAR/MONTH/DAY"]
     * Partition data by cursor fields when a cursor field is a date
     */
    partitioning?: string;
    /**
     * must be one of ["", "us-east-1", "us-east-2", "us-west-1", "us-west-2", "af-south-1", "ap-east-1", "ap-south-1", "ap-northeast-1", "ap-northeast-2", "ap-northeast-3", "ap-southeast-1", "ap-southeast-2", "ca-central-1", "cn-north-1", "cn-northwest-1", "eu-central-1", "eu-north-1", "eu-south-1", "eu-west-1", "eu-west-2", "eu-west-3", "sa-east-1", "me-south-1", "us-gov-east-1", "us-gov-west-1"]
     * The region of the S3 bucket. See \n\nhere\n\n for all region codes.
     */
    region: string;
}

export interface DestinationAWSDatalakeConfigurationCredentials {
    destinationAwsDatalakeAuthenticationModeIamRole?: outputs.DestinationAWSDatalakeConfigurationCredentialsDestinationAwsDatalakeAuthenticationModeIamRole;
    destinationAwsDatalakeAuthenticationModeIamUser?: outputs.DestinationAWSDatalakeConfigurationCredentialsDestinationAwsDatalakeAuthenticationModeIamUser;
    destinationAwsDatalakeUpdateAuthenticationModeIamRole?: outputs.DestinationAWSDatalakeConfigurationCredentialsDestinationAwsDatalakeUpdateAuthenticationModeIamRole;
    destinationAwsDatalakeUpdateAuthenticationModeIamUser?: outputs.DestinationAWSDatalakeConfigurationCredentialsDestinationAwsDatalakeUpdateAuthenticationModeIamUser;
}

export interface DestinationAWSDatalakeConfigurationCredentialsDestinationAwsDatalakeAuthenticationModeIamRole {
    credentialsTitle: string;
    roleArn: string;
}

export interface DestinationAWSDatalakeConfigurationCredentialsDestinationAwsDatalakeAuthenticationModeIamUser {
    awsAccessKeyId: string;
    awsSecretAccessKey: string;
    credentialsTitle: string;
}

export interface DestinationAWSDatalakeConfigurationCredentialsDestinationAwsDatalakeUpdateAuthenticationModeIamRole {
    credentialsTitle: string;
    roleArn: string;
}

export interface DestinationAWSDatalakeConfigurationCredentialsDestinationAwsDatalakeUpdateAuthenticationModeIamUser {
    awsAccessKeyId: string;
    awsSecretAccessKey: string;
    credentialsTitle: string;
}

export interface DestinationAWSDatalakeConfigurationFormat {
    destinationAwsDatalakeOutputFormatWildcardJsonLinesNewlineDelimitedJson?: outputs.DestinationAWSDatalakeConfigurationFormatDestinationAwsDatalakeOutputFormatWildcardJsonLinesNewlineDelimitedJson;
    destinationAwsDatalakeOutputFormatWildcardParquetColumnarStorage?: outputs.DestinationAWSDatalakeConfigurationFormatDestinationAwsDatalakeOutputFormatWildcardParquetColumnarStorage;
    destinationAwsDatalakeUpdateOutputFormatWildcardJsonLinesNewlineDelimitedJson?: outputs.DestinationAWSDatalakeConfigurationFormatDestinationAwsDatalakeUpdateOutputFormatWildcardJsonLinesNewlineDelimitedJson;
    destinationAwsDatalakeUpdateOutputFormatWildcardParquetColumnarStorage?: outputs.DestinationAWSDatalakeConfigurationFormatDestinationAwsDatalakeUpdateOutputFormatWildcardParquetColumnarStorage;
}

export interface DestinationAWSDatalakeConfigurationFormatDestinationAwsDatalakeOutputFormatWildcardJsonLinesNewlineDelimitedJson {
    compressionCodec?: string;
    formatType: string;
}

export interface DestinationAWSDatalakeConfigurationFormatDestinationAwsDatalakeOutputFormatWildcardParquetColumnarStorage {
    compressionCodec?: string;
    formatType: string;
}

export interface DestinationAWSDatalakeConfigurationFormatDestinationAwsDatalakeUpdateOutputFormatWildcardJsonLinesNewlineDelimitedJson {
    compressionCodec?: string;
    formatType: string;
}

export interface DestinationAWSDatalakeConfigurationFormatDestinationAwsDatalakeUpdateOutputFormatWildcardParquetColumnarStorage {
    compressionCodec?: string;
    formatType: string;
}

export interface DestinationAzureBlobStorageConfiguration {
    /**
     * The Azure blob storage account key.
     */
    azureBlobStorageAccountKey: string;
    /**
     * The account's name of the Azure Blob Storage.
     */
    azureBlobStorageAccountName: string;
    /**
     * The name of the Azure blob storage container. If not exists - will be created automatically. May be empty, then will be created automatically airbytecontainer+timestamp
     */
    azureBlobStorageContainerName?: string;
    /**
     * This is Azure Blob Storage endpoint domain name. Leave default value (or leave it empty if run container from command line) to use Microsoft native from example.
     */
    azureBlobStorageEndpointDomainName?: string;
    /**
     * The amount of megabytes to buffer for the output stream to Azure. This will impact memory footprint on workers, but may need adjustment for performance and appropriate block size in Azure.
     */
    azureBlobStorageOutputBufferSize?: number;
    /**
     * The amount of megabytes after which the connector should spill the records in a new blob object. Make sure to configure size greater than individual records. Enter 0 if not applicable
     */
    azureBlobStorageSpillSize?: number;
    /**
     * must be one of ["azure-blob-storage"]
     */
    destinationType: string;
    /**
     * Output data format
     */
    format: outputs.DestinationAzureBlobStorageConfigurationFormat;
}

export interface DestinationAzureBlobStorageConfigurationFormat {
    destinationAzureBlobStorageOutputFormatCsvCommaSeparatedValues?: outputs.DestinationAzureBlobStorageConfigurationFormatDestinationAzureBlobStorageOutputFormatCsvCommaSeparatedValues;
    destinationAzureBlobStorageOutputFormatJsonLinesNewlineDelimitedJson?: outputs.DestinationAzureBlobStorageConfigurationFormatDestinationAzureBlobStorageOutputFormatJsonLinesNewlineDelimitedJson;
    destinationAzureBlobStorageUpdateOutputFormatCsvCommaSeparatedValues?: outputs.DestinationAzureBlobStorageConfigurationFormatDestinationAzureBlobStorageUpdateOutputFormatCsvCommaSeparatedValues;
    destinationAzureBlobStorageUpdateOutputFormatJsonLinesNewlineDelimitedJson?: outputs.DestinationAzureBlobStorageConfigurationFormatDestinationAzureBlobStorageUpdateOutputFormatJsonLinesNewlineDelimitedJson;
}

export interface DestinationAzureBlobStorageConfigurationFormatDestinationAzureBlobStorageOutputFormatCsvCommaSeparatedValues {
    flattening: string;
    formatType: string;
}

export interface DestinationAzureBlobStorageConfigurationFormatDestinationAzureBlobStorageOutputFormatJsonLinesNewlineDelimitedJson {
    formatType: string;
}

export interface DestinationAzureBlobStorageConfigurationFormatDestinationAzureBlobStorageUpdateOutputFormatCsvCommaSeparatedValues {
    flattening: string;
    formatType: string;
}

export interface DestinationAzureBlobStorageConfigurationFormatDestinationAzureBlobStorageUpdateOutputFormatJsonLinesNewlineDelimitedJson {
    formatType: string;
}

export interface DestinationBigqueryConfiguration {
    /**
     * Google BigQuery client's chunk (buffer) size (MIN=1, MAX = 15) for each table. The size that will be written by a single RPC. Written data will be buffered and only flushed upon reaching this size or closing the channel. The default 15MB value is used if not set explicitly. Read more \n\nhere\n\n.
     */
    bigQueryClientBufferSizeMb?: number;
    /**
     * The contents of the JSON service account key. Check out the \n\ndocs\n\n if you need help generating this key. Default credentials will be used if this field is left empty.
     */
    credentialsJson?: string;
    /**
     * The default BigQuery Dataset ID that tables are replicated to if the source does not specify a namespace. Read more \n\nhere\n\n.
     */
    datasetId: string;
    /**
     * must be one of ["US", "EU", "asia-east1", "asia-east2", "asia-northeast1", "asia-northeast2", "asia-northeast3", "asia-south1", "asia-south2", "asia-southeast1", "asia-southeast2", "australia-southeast1", "australia-southeast2", "europe-central1", "europe-central2", "europe-north1", "europe-southwest1", "europe-west1", "europe-west2", "europe-west3", "europe-west4", "europe-west6", "europe-west7", "europe-west8", "europe-west9", "me-west1", "northamerica-northeast1", "northamerica-northeast2", "southamerica-east1", "southamerica-west1", "us-central1", "us-east1", "us-east2", "us-east3", "us-east4", "us-east5", "us-west1", "us-west2", "us-west3", "us-west4"]
     * The location of the dataset. Warning: Changes made after creation will not be applied. Read more \n\nhere\n\n.
     */
    datasetLocation: string;
    /**
     * must be one of ["bigquery"]
     */
    destinationType: string;
    /**
     * Loading method used to send select the way data will be uploaded to BigQuery. \n\n\n\nStandard Inserts\n\n - Direct uploading using SQL INSERT statements. This method is extremely inefficient and provided only for quick testing. In almost all cases, you should use staging. \n\n\n\nGCS Staging\n\n - Writes large batches of records to a file, uploads the file to GCS, then uses \n\nCOPY INTO table\n\n to upload the file. Recommended for most workloads for better speed and scalability. Read more about GCS Staging \n\nhere\n\n.
     */
    loadingMethod?: outputs.DestinationBigqueryConfigurationLoadingMethod;
    /**
     * The GCP project ID for the project containing the target BigQuery dataset. Read more \n\nhere\n\n.
     */
    projectId: string;
    /**
     * (Early Access) The dataset to write raw tables into
     */
    rawDataDataset?: string;
    /**
     * must be one of ["interactive", "batch"]
     * Interactive run type means that the query is executed as soon as possible, and these queries count towards concurrent rate limit and daily limit. Read more about interactive run type \n\nhere\n\n. Batch queries are queued and started as soon as idle resources are available in the BigQuery shared resource pool, which usually occurs within a few minutes. Batch queries donâ€™t count towards your concurrent rate limit. Read more about batch queries \n\nhere\n\n. The default "interactive" value is used if not set explicitly.
     */
    transformationPriority?: string;
    /**
     * (Early Access) Use \n\nDestinations V2\n\n.
     */
    use1s1tFormat?: boolean;
}

export interface DestinationBigqueryConfigurationLoadingMethod {
    destinationBigqueryLoadingMethodGcsStaging?: outputs.DestinationBigqueryConfigurationLoadingMethodDestinationBigqueryLoadingMethodGcsStaging;
    destinationBigqueryLoadingMethodStandardInserts?: outputs.DestinationBigqueryConfigurationLoadingMethodDestinationBigqueryLoadingMethodStandardInserts;
    destinationBigqueryUpdateLoadingMethodGcsStaging?: outputs.DestinationBigqueryConfigurationLoadingMethodDestinationBigqueryUpdateLoadingMethodGcsStaging;
    destinationBigqueryUpdateLoadingMethodStandardInserts?: outputs.DestinationBigqueryConfigurationLoadingMethodDestinationBigqueryUpdateLoadingMethodStandardInserts;
}

export interface DestinationBigqueryConfigurationLoadingMethodDestinationBigqueryLoadingMethodGcsStaging {
    credential: outputs.DestinationBigqueryConfigurationLoadingMethodDestinationBigqueryLoadingMethodGcsStagingCredential;
    fileBufferCount?: number;
    gcsBucketName: string;
    gcsBucketPath: string;
    keepFilesInGcsBucket?: string;
    method: string;
}

export interface DestinationBigqueryConfigurationLoadingMethodDestinationBigqueryLoadingMethodGcsStagingCredential {
    destinationBigqueryLoadingMethodGcsStagingCredentialHmacKey?: outputs.DestinationBigqueryConfigurationLoadingMethodDestinationBigqueryLoadingMethodGcsStagingCredentialDestinationBigqueryLoadingMethodGcsStagingCredentialHmacKey;
}

export interface DestinationBigqueryConfigurationLoadingMethodDestinationBigqueryLoadingMethodGcsStagingCredentialDestinationBigqueryLoadingMethodGcsStagingCredentialHmacKey {
    credentialType: string;
    hmacKeyAccessId: string;
    hmacKeySecret: string;
}

export interface DestinationBigqueryConfigurationLoadingMethodDestinationBigqueryLoadingMethodStandardInserts {
    method: string;
}

export interface DestinationBigqueryConfigurationLoadingMethodDestinationBigqueryUpdateLoadingMethodGcsStaging {
    credential: outputs.DestinationBigqueryConfigurationLoadingMethodDestinationBigqueryUpdateLoadingMethodGcsStagingCredential;
    fileBufferCount?: number;
    gcsBucketName: string;
    gcsBucketPath: string;
    keepFilesInGcsBucket?: string;
    method: string;
}

export interface DestinationBigqueryConfigurationLoadingMethodDestinationBigqueryUpdateLoadingMethodGcsStagingCredential {
    destinationBigqueryUpdateLoadingMethodGcsStagingCredentialHmacKey?: outputs.DestinationBigqueryConfigurationLoadingMethodDestinationBigqueryUpdateLoadingMethodGcsStagingCredentialDestinationBigqueryUpdateLoadingMethodGcsStagingCredentialHmacKey;
}

export interface DestinationBigqueryConfigurationLoadingMethodDestinationBigqueryUpdateLoadingMethodGcsStagingCredentialDestinationBigqueryUpdateLoadingMethodGcsStagingCredentialHmacKey {
    credentialType: string;
    hmacKeyAccessId: string;
    hmacKeySecret: string;
}

export interface DestinationBigqueryConfigurationLoadingMethodDestinationBigqueryUpdateLoadingMethodStandardInserts {
    method: string;
}

export interface DestinationBigqueryDenormalizedConfiguration {
    /**
     * Google BigQuery client's chunk (buffer) size (MIN=1, MAX = 15) for each table. The size that will be written by a single RPC. Written data will be buffered and only flushed upon reaching this size or closing the channel. The default 15MB value is used if not set explicitly. Read more \n\nhere\n\n.
     */
    bigQueryClientBufferSizeMb?: number;
    /**
     * The contents of the JSON service account key. Check out the \n\ndocs\n\n if you need help generating this key. Default credentials will be used if this field is left empty.
     */
    credentialsJson?: string;
    /**
     * The default BigQuery Dataset ID that tables are replicated to if the source does not specify a namespace. Read more \n\nhere\n\n.
     */
    datasetId: string;
    /**
     * must be one of ["US", "EU", "asia-east1", "asia-east2", "asia-northeast1", "asia-northeast2", "asia-northeast3", "asia-south1", "asia-south2", "asia-southeast1", "asia-southeast2", "australia-southeast1", "australia-southeast2", "europe-central1", "europe-central2", "europe-north1", "europe-southwest1", "europe-west1", "europe-west2", "europe-west3", "europe-west4", "europe-west6", "europe-west7", "europe-west8", "europe-west9", "me-west1", "northamerica-northeast1", "northamerica-northeast2", "southamerica-east1", "southamerica-west1", "us-central1", "us-east1", "us-east2", "us-east3", "us-east4", "us-east5", "us-west1", "us-west2", "us-west3", "us-west4"]
     * The location of the dataset. Warning: Changes made after creation will not be applied. The default "US" value is used if not set explicitly. Read more \n\nhere\n\n.
     */
    datasetLocation?: string;
    /**
     * must be one of ["bigquery-denormalized"]
     */
    destinationType: string;
    /**
     * Loading method used to send select the way data will be uploaded to BigQuery. \n\n\n\nStandard Inserts\n\n - Direct uploading using SQL INSERT statements. This method is extremely inefficient and provided only for quick testing. In almost all cases, you should use staging. \n\n\n\nGCS Staging\n\n - Writes large batches of records to a file, uploads the file to GCS, then uses \n\nCOPY INTO table\n\n to upload the file. Recommended for most workloads for better speed and scalability. Read more about GCS Staging \n\nhere\n\n.
     */
    loadingMethod?: outputs.DestinationBigqueryDenormalizedConfigurationLoadingMethod;
    /**
     * The GCP project ID for the project containing the target BigQuery dataset. Read more \n\nhere\n\n.
     */
    projectId: string;
}

export interface DestinationBigqueryDenormalizedConfigurationLoadingMethod {
    destinationBigqueryDenormalizedLoadingMethodGcsStaging?: outputs.DestinationBigqueryDenormalizedConfigurationLoadingMethodDestinationBigqueryDenormalizedLoadingMethodGcsStaging;
    destinationBigqueryDenormalizedLoadingMethodStandardInserts?: outputs.DestinationBigqueryDenormalizedConfigurationLoadingMethodDestinationBigqueryDenormalizedLoadingMethodStandardInserts;
    destinationBigqueryDenormalizedUpdateLoadingMethodGcsStaging?: outputs.DestinationBigqueryDenormalizedConfigurationLoadingMethodDestinationBigqueryDenormalizedUpdateLoadingMethodGcsStaging;
    destinationBigqueryDenormalizedUpdateLoadingMethodStandardInserts?: outputs.DestinationBigqueryDenormalizedConfigurationLoadingMethodDestinationBigqueryDenormalizedUpdateLoadingMethodStandardInserts;
}

export interface DestinationBigqueryDenormalizedConfigurationLoadingMethodDestinationBigqueryDenormalizedLoadingMethodGcsStaging {
    credential: outputs.DestinationBigqueryDenormalizedConfigurationLoadingMethodDestinationBigqueryDenormalizedLoadingMethodGcsStagingCredential;
    fileBufferCount?: number;
    gcsBucketName: string;
    gcsBucketPath: string;
    keepFilesInGcsBucket?: string;
    method: string;
}

export interface DestinationBigqueryDenormalizedConfigurationLoadingMethodDestinationBigqueryDenormalizedLoadingMethodGcsStagingCredential {
    destinationBigqueryDenormalizedLoadingMethodGcsStagingCredentialHmacKey?: outputs.DestinationBigqueryDenormalizedConfigurationLoadingMethodDestinationBigqueryDenormalizedLoadingMethodGcsStagingCredentialDestinationBigqueryDenormalizedLoadingMethodGcsStagingCredentialHmacKey;
}

export interface DestinationBigqueryDenormalizedConfigurationLoadingMethodDestinationBigqueryDenormalizedLoadingMethodGcsStagingCredentialDestinationBigqueryDenormalizedLoadingMethodGcsStagingCredentialHmacKey {
    credentialType: string;
    hmacKeyAccessId: string;
    hmacKeySecret: string;
}

export interface DestinationBigqueryDenormalizedConfigurationLoadingMethodDestinationBigqueryDenormalizedLoadingMethodStandardInserts {
    method: string;
}

export interface DestinationBigqueryDenormalizedConfigurationLoadingMethodDestinationBigqueryDenormalizedUpdateLoadingMethodGcsStaging {
    credential: outputs.DestinationBigqueryDenormalizedConfigurationLoadingMethodDestinationBigqueryDenormalizedUpdateLoadingMethodGcsStagingCredential;
    fileBufferCount?: number;
    gcsBucketName: string;
    gcsBucketPath: string;
    keepFilesInGcsBucket?: string;
    method: string;
}

export interface DestinationBigqueryDenormalizedConfigurationLoadingMethodDestinationBigqueryDenormalizedUpdateLoadingMethodGcsStagingCredential {
    destinationBigqueryDenormalizedUpdateLoadingMethodGcsStagingCredentialHmacKey?: outputs.DestinationBigqueryDenormalizedConfigurationLoadingMethodDestinationBigqueryDenormalizedUpdateLoadingMethodGcsStagingCredentialDestinationBigqueryDenormalizedUpdateLoadingMethodGcsStagingCredentialHmacKey;
}

export interface DestinationBigqueryDenormalizedConfigurationLoadingMethodDestinationBigqueryDenormalizedUpdateLoadingMethodGcsStagingCredentialDestinationBigqueryDenormalizedUpdateLoadingMethodGcsStagingCredentialHmacKey {
    credentialType: string;
    hmacKeyAccessId: string;
    hmacKeySecret: string;
}

export interface DestinationBigqueryDenormalizedConfigurationLoadingMethodDestinationBigqueryDenormalizedUpdateLoadingMethodStandardInserts {
    method: string;
}

export interface DestinationClickhouseConfiguration {
    /**
     * Name of the database.
     */
    database: string;
    /**
     * must be one of ["clickhouse"]
     */
    destinationType: string;
    /**
     * Hostname of the database.
     */
    host: string;
    /**
     * Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
     */
    jdbcUrlParams?: string;
    /**
     * Password associated with the username.
     */
    password?: string;
    /**
     * HTTP port of the database.
     */
    port: number;
    /**
     * Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
     */
    tunnelMethod?: outputs.DestinationClickhouseConfigurationTunnelMethod;
    /**
     * Username to use to access the database.
     */
    username: string;
}

export interface DestinationClickhouseConfigurationTunnelMethod {
    destinationClickhouseSshTunnelMethodNoTunnel?: outputs.DestinationClickhouseConfigurationTunnelMethodDestinationClickhouseSshTunnelMethodNoTunnel;
    destinationClickhouseSshTunnelMethodPasswordAuthentication?: outputs.DestinationClickhouseConfigurationTunnelMethodDestinationClickhouseSshTunnelMethodPasswordAuthentication;
    destinationClickhouseSshTunnelMethodSshKeyAuthentication?: outputs.DestinationClickhouseConfigurationTunnelMethodDestinationClickhouseSshTunnelMethodSshKeyAuthentication;
    destinationClickhouseUpdateSshTunnelMethodNoTunnel?: outputs.DestinationClickhouseConfigurationTunnelMethodDestinationClickhouseUpdateSshTunnelMethodNoTunnel;
    destinationClickhouseUpdateSshTunnelMethodPasswordAuthentication?: outputs.DestinationClickhouseConfigurationTunnelMethodDestinationClickhouseUpdateSshTunnelMethodPasswordAuthentication;
    destinationClickhouseUpdateSshTunnelMethodSshKeyAuthentication?: outputs.DestinationClickhouseConfigurationTunnelMethodDestinationClickhouseUpdateSshTunnelMethodSshKeyAuthentication;
}

export interface DestinationClickhouseConfigurationTunnelMethodDestinationClickhouseSshTunnelMethodNoTunnel {
    tunnelMethod: string;
}

export interface DestinationClickhouseConfigurationTunnelMethodDestinationClickhouseSshTunnelMethodPasswordAuthentication {
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
    tunnelUserPassword: string;
}

export interface DestinationClickhouseConfigurationTunnelMethodDestinationClickhouseSshTunnelMethodSshKeyAuthentication {
    sshKey: string;
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
}

export interface DestinationClickhouseConfigurationTunnelMethodDestinationClickhouseUpdateSshTunnelMethodNoTunnel {
    tunnelMethod: string;
}

export interface DestinationClickhouseConfigurationTunnelMethodDestinationClickhouseUpdateSshTunnelMethodPasswordAuthentication {
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
    tunnelUserPassword: string;
}

export interface DestinationClickhouseConfigurationTunnelMethodDestinationClickhouseUpdateSshTunnelMethodSshKeyAuthentication {
    sshKey: string;
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
}

export interface DestinationConvexConfiguration {
    /**
     * API access key used to send data to a Convex deployment.
     */
    accessKey: string;
    /**
     * URL of the Convex deployment that is the destination
     */
    deploymentUrl: string;
    /**
     * must be one of ["convex"]
     */
    destinationType: string;
}

export interface DestinationCumulioConfiguration {
    /**
     * URL of the Cumul.io API (e.g. 'https://api.cumul.io', 'https://api.us.cumul.io', or VPC-specific API url). Defaults to 'https://api.cumul.io'.
     */
    apiHost: string;
    /**
     * An API key generated in Cumul.io's platform (can be generated here: https://app.cumul.io/start/profile/integration).
     */
    apiKey: string;
    /**
     * The corresponding API token generated in Cumul.io's platform (can be generated here: https://app.cumul.io/start/profile/integration).
     */
    apiToken: string;
    /**
     * must be one of ["cumulio"]
     */
    destinationType: string;
}

export interface DestinationDatabendConfiguration {
    /**
     * Name of the database.
     */
    database: string;
    /**
     * must be one of ["databend"]
     */
    destinationType: string;
    /**
     * Hostname of the database.
     */
    host: string;
    /**
     * Password associated with the username.
     */
    password?: string;
    /**
     * Port of the database.
     */
    port?: number;
    /**
     * The default  table was written to.
     */
    table?: string;
    /**
     * Username to use to access the database.
     */
    username: string;
}

export interface DestinationDatabricksConfiguration {
    /**
     * You must agree to the Databricks JDBC Driver \n\nTerms & Conditions\n\n to use this connector.
     */
    acceptTerms: boolean;
    /**
     * Storage on which the delta lake is built.
     */
    dataSource: outputs.DestinationDatabricksConfigurationDataSource;
    /**
     * The name of the catalog. If not specified otherwise, the "hiveMetastore" will be used.
     */
    database?: string;
    /**
     * Databricks Cluster HTTP Path.
     */
    databricksHttpPath: string;
    /**
     * Databricks Personal Access Token for making authenticated requests.
     */
    databricksPersonalAccessToken: string;
    /**
     * Databricks Cluster Port.
     */
    databricksPort?: string;
    /**
     * Databricks Cluster Server Hostname.
     */
    databricksServerHostname: string;
    /**
     * must be one of ["databricks"]
     */
    destinationType: string;
    /**
     * Support schema evolution for all streams. If "false", the connector might fail when a stream's schema changes.
     */
    enableSchemaEvolution?: boolean;
    /**
     * Default to 'true'. Switch it to 'false' for debugging purpose.
     */
    purgeStagingData?: boolean;
    /**
     * The default schema tables are written. If not specified otherwise, the "default" will be used.
     */
    schema?: string;
}

export interface DestinationDatabricksConfigurationDataSource {
    destinationDatabricksDataSourceAmazonS3?: outputs.DestinationDatabricksConfigurationDataSourceDestinationDatabricksDataSourceAmazonS3;
    destinationDatabricksDataSourceAzureBlobStorage?: outputs.DestinationDatabricksConfigurationDataSourceDestinationDatabricksDataSourceAzureBlobStorage;
    destinationDatabricksDataSourceRecommendedManagedTables?: outputs.DestinationDatabricksConfigurationDataSourceDestinationDatabricksDataSourceRecommendedManagedTables;
    destinationDatabricksUpdateDataSourceAmazonS3?: outputs.DestinationDatabricksConfigurationDataSourceDestinationDatabricksUpdateDataSourceAmazonS3;
    destinationDatabricksUpdateDataSourceAzureBlobStorage?: outputs.DestinationDatabricksConfigurationDataSourceDestinationDatabricksUpdateDataSourceAzureBlobStorage;
    destinationDatabricksUpdateDataSourceRecommendedManagedTables?: outputs.DestinationDatabricksConfigurationDataSourceDestinationDatabricksUpdateDataSourceRecommendedManagedTables;
}

export interface DestinationDatabricksConfigurationDataSourceDestinationDatabricksDataSourceAmazonS3 {
    dataSourceType: string;
    fileNamePattern?: string;
    s3AccessKeyId: string;
    s3BucketName: string;
    s3BucketPath: string;
    s3BucketRegion: string;
    s3SecretAccessKey: string;
}

export interface DestinationDatabricksConfigurationDataSourceDestinationDatabricksDataSourceAzureBlobStorage {
    azureBlobStorageAccountName: string;
    azureBlobStorageContainerName: string;
    azureBlobStorageEndpointDomainName?: string;
    azureBlobStorageSasToken: string;
    dataSourceType: string;
}

export interface DestinationDatabricksConfigurationDataSourceDestinationDatabricksDataSourceRecommendedManagedTables {
    dataSourceType: string;
}

export interface DestinationDatabricksConfigurationDataSourceDestinationDatabricksUpdateDataSourceAmazonS3 {
    dataSourceType: string;
    fileNamePattern?: string;
    s3AccessKeyId: string;
    s3BucketName: string;
    s3BucketPath: string;
    s3BucketRegion: string;
    s3SecretAccessKey: string;
}

export interface DestinationDatabricksConfigurationDataSourceDestinationDatabricksUpdateDataSourceAzureBlobStorage {
    azureBlobStorageAccountName: string;
    azureBlobStorageContainerName: string;
    azureBlobStorageEndpointDomainName?: string;
    azureBlobStorageSasToken: string;
    dataSourceType: string;
}

export interface DestinationDatabricksConfigurationDataSourceDestinationDatabricksUpdateDataSourceRecommendedManagedTables {
    dataSourceType: string;
}

export interface DestinationDevNullConfiguration {
    /**
     * must be one of ["dev-null"]
     */
    destinationType: string;
    /**
     * The type of destination to be used
     */
    testDestination: outputs.DestinationDevNullConfigurationTestDestination;
}

export interface DestinationDevNullConfigurationTestDestination {
    destinationDevNullTestDestinationSilent?: outputs.DestinationDevNullConfigurationTestDestinationDestinationDevNullTestDestinationSilent;
    destinationDevNullUpdateTestDestinationSilent?: outputs.DestinationDevNullConfigurationTestDestinationDestinationDevNullUpdateTestDestinationSilent;
}

export interface DestinationDevNullConfigurationTestDestinationDestinationDevNullTestDestinationSilent {
    testDestinationType: string;
}

export interface DestinationDevNullConfigurationTestDestinationDestinationDevNullUpdateTestDestinationSilent {
    testDestinationType: string;
}

export interface DestinationDynamodbConfiguration {
    /**
     * The access key id to access the DynamoDB. Airbyte requires Read and Write permissions to the DynamoDB.
     */
    accessKeyId: string;
    /**
     * must be one of ["dynamodb"]
     */
    destinationType: string;
    /**
     * This is your DynamoDB endpoint url.(if you are working with AWS DynamoDB, just leave empty).
     */
    dynamodbEndpoint?: string;
    /**
     * must be one of ["", "us-east-1", "us-east-2", "us-west-1", "us-west-2", "af-south-1", "ap-east-1", "ap-south-1", "ap-northeast-1", "ap-northeast-2", "ap-northeast-3", "ap-southeast-1", "ap-southeast-2", "ca-central-1", "cn-north-1", "cn-northwest-1", "eu-central-1", "eu-north-1", "eu-south-1", "eu-west-1", "eu-west-2", "eu-west-3", "sa-east-1", "me-south-1", "us-gov-east-1", "us-gov-west-1"]
     * The region of the DynamoDB.
     */
    dynamodbRegion: string;
    /**
     * The prefix to use when naming DynamoDB tables.
     */
    dynamodbTableNamePrefix: string;
    /**
     * The corresponding secret to the access key id.
     */
    secretAccessKey: string;
}

export interface DestinationElasticsearchConfiguration {
    /**
     * The type of authentication to be used
     */
    authenticationMethod?: outputs.DestinationElasticsearchConfigurationAuthenticationMethod;
    /**
     * CA certificate
     */
    caCertificate?: string;
    /**
     * must be one of ["elasticsearch"]
     */
    destinationType: string;
    /**
     * The full url of the Elasticsearch server
     */
    endpoint: string;
    /**
     * If a primary key identifier is defined in the source, an upsert will be performed using the primary key value as the elasticsearch doc id. Does not support composite primary keys.
     */
    upsert?: boolean;
}

export interface DestinationElasticsearchConfigurationAuthenticationMethod {
    destinationElasticsearchAuthenticationMethodApiKeySecret?: outputs.DestinationElasticsearchConfigurationAuthenticationMethodDestinationElasticsearchAuthenticationMethodApiKeySecret;
    destinationElasticsearchAuthenticationMethodUsernamePassword?: outputs.DestinationElasticsearchConfigurationAuthenticationMethodDestinationElasticsearchAuthenticationMethodUsernamePassword;
    destinationElasticsearchUpdateAuthenticationMethodApiKeySecret?: outputs.DestinationElasticsearchConfigurationAuthenticationMethodDestinationElasticsearchUpdateAuthenticationMethodApiKeySecret;
    destinationElasticsearchUpdateAuthenticationMethodUsernamePassword?: outputs.DestinationElasticsearchConfigurationAuthenticationMethodDestinationElasticsearchUpdateAuthenticationMethodUsernamePassword;
}

export interface DestinationElasticsearchConfigurationAuthenticationMethodDestinationElasticsearchAuthenticationMethodApiKeySecret {
    apiKeyId: string;
    apiKeySecret: string;
    method: string;
}

export interface DestinationElasticsearchConfigurationAuthenticationMethodDestinationElasticsearchAuthenticationMethodUsernamePassword {
    method: string;
    password: string;
    username: string;
}

export interface DestinationElasticsearchConfigurationAuthenticationMethodDestinationElasticsearchUpdateAuthenticationMethodApiKeySecret {
    apiKeyId: string;
    apiKeySecret: string;
    method: string;
}

export interface DestinationElasticsearchConfigurationAuthenticationMethodDestinationElasticsearchUpdateAuthenticationMethodUsernamePassword {
    method: string;
    password: string;
    username: string;
}

export interface DestinationFireboltConfiguration {
    /**
     * Firebolt account to login.
     */
    account?: string;
    /**
     * The database to connect to.
     */
    database: string;
    /**
     * must be one of ["firebolt"]
     */
    destinationType: string;
    /**
     * Engine name or url to connect to.
     */
    engine?: string;
    /**
     * The host name of your Firebolt database.
     */
    host?: string;
    /**
     * Loading method used to select the way data will be uploaded to Firebolt
     */
    loadingMethod?: outputs.DestinationFireboltConfigurationLoadingMethod;
    /**
     * Firebolt password.
     */
    password: string;
    /**
     * Firebolt email address you use to login.
     */
    username: string;
}

export interface DestinationFireboltConfigurationLoadingMethod {
    destinationFireboltLoadingMethodExternalTableViaS3?: outputs.DestinationFireboltConfigurationLoadingMethodDestinationFireboltLoadingMethodExternalTableViaS3;
    destinationFireboltLoadingMethodSqlInserts?: outputs.DestinationFireboltConfigurationLoadingMethodDestinationFireboltLoadingMethodSqlInserts;
    destinationFireboltUpdateLoadingMethodExternalTableViaS3?: outputs.DestinationFireboltConfigurationLoadingMethodDestinationFireboltUpdateLoadingMethodExternalTableViaS3;
    destinationFireboltUpdateLoadingMethodSqlInserts?: outputs.DestinationFireboltConfigurationLoadingMethodDestinationFireboltUpdateLoadingMethodSqlInserts;
}

export interface DestinationFireboltConfigurationLoadingMethodDestinationFireboltLoadingMethodExternalTableViaS3 {
    awsKeyId: string;
    awsKeySecret: string;
    method: string;
    s3Bucket: string;
    s3Region: string;
}

export interface DestinationFireboltConfigurationLoadingMethodDestinationFireboltLoadingMethodSqlInserts {
    method: string;
}

export interface DestinationFireboltConfigurationLoadingMethodDestinationFireboltUpdateLoadingMethodExternalTableViaS3 {
    awsKeyId: string;
    awsKeySecret: string;
    method: string;
    s3Bucket: string;
    s3Region: string;
}

export interface DestinationFireboltConfigurationLoadingMethodDestinationFireboltUpdateLoadingMethodSqlInserts {
    method: string;
}

export interface DestinationFirestoreConfiguration {
    /**
     * The contents of the JSON service account key. Check out the \n\ndocs\n\n if you need help generating this key. Default credentials will be used if this field is left empty.
     */
    credentialsJson?: string;
    /**
     * must be one of ["firestore"]
     */
    destinationType: string;
    /**
     * The GCP project ID for the project containing the target BigQuery dataset.
     */
    projectId: string;
}

export interface DestinationGcsConfiguration {
    /**
     * An HMAC key is a type of credential and can be associated with a service account or a user account in Cloud Storage. Read more \n\nhere\n\n.
     */
    credential: outputs.DestinationGcsConfigurationCredential;
    /**
     * must be one of ["gcs"]
     */
    destinationType: string;
    /**
     * Output data format. One of the following formats must be selected - \n\nAVRO\n\n format, \n\nPARQUET\n\n format, \n\nCSV\n\n format, or \n\nJSONL\n\n format.
     */
    format: outputs.DestinationGcsConfigurationFormat;
    /**
     * You can find the bucket name in the App Engine Admin console Application Settings page, under the label Google Cloud Storage Bucket. Read more \n\nhere\n\n.
     */
    gcsBucketName: string;
    /**
     * GCS Bucket Path string Subdirectory under the above bucket to sync the data into.
     */
    gcsBucketPath: string;
    /**
     * must be one of ["northamerica-northeast1", "northamerica-northeast2", "us-central1", "us-east1", "us-east4", "us-west1", "us-west2", "us-west3", "us-west4", "southamerica-east1", "southamerica-west1", "europe-central2", "europe-north1", "europe-west1", "europe-west2", "europe-west3", "europe-west4", "europe-west6", "asia-east1", "asia-east2", "asia-northeast1", "asia-northeast2", "asia-northeast3", "asia-south1", "asia-south2", "asia-southeast1", "asia-southeast2", "australia-southeast1", "australia-southeast2", "asia", "eu", "us", "asia1", "eur4", "nam4"]
     * Select a Region of the GCS Bucket. Read more \n\nhere\n\n.
     */
    gcsBucketRegion?: string;
}

export interface DestinationGcsConfigurationCredential {
    destinationGcsAuthenticationHmacKey?: outputs.DestinationGcsConfigurationCredentialDestinationGcsAuthenticationHmacKey;
    destinationGcsUpdateAuthenticationHmacKey?: outputs.DestinationGcsConfigurationCredentialDestinationGcsUpdateAuthenticationHmacKey;
}

export interface DestinationGcsConfigurationCredentialDestinationGcsAuthenticationHmacKey {
    credentialType: string;
    hmacKeyAccessId: string;
    hmacKeySecret: string;
}

export interface DestinationGcsConfigurationCredentialDestinationGcsUpdateAuthenticationHmacKey {
    credentialType: string;
    hmacKeyAccessId: string;
    hmacKeySecret: string;
}

export interface DestinationGcsConfigurationFormat {
    destinationGcsOutputFormatAvroApacheAvro?: outputs.DestinationGcsConfigurationFormatDestinationGcsOutputFormatAvroApacheAvro;
    destinationGcsOutputFormatCsvCommaSeparatedValues?: outputs.DestinationGcsConfigurationFormatDestinationGcsOutputFormatCsvCommaSeparatedValues;
    destinationGcsOutputFormatJsonLinesNewlineDelimitedJson?: outputs.DestinationGcsConfigurationFormatDestinationGcsOutputFormatJsonLinesNewlineDelimitedJson;
    destinationGcsOutputFormatParquetColumnarStorage?: outputs.DestinationGcsConfigurationFormatDestinationGcsOutputFormatParquetColumnarStorage;
    destinationGcsUpdateOutputFormatAvroApacheAvro?: outputs.DestinationGcsConfigurationFormatDestinationGcsUpdateOutputFormatAvroApacheAvro;
    destinationGcsUpdateOutputFormatCsvCommaSeparatedValues?: outputs.DestinationGcsConfigurationFormatDestinationGcsUpdateOutputFormatCsvCommaSeparatedValues;
    destinationGcsUpdateOutputFormatJsonLinesNewlineDelimitedJson?: outputs.DestinationGcsConfigurationFormatDestinationGcsUpdateOutputFormatJsonLinesNewlineDelimitedJson;
    destinationGcsUpdateOutputFormatParquetColumnarStorage?: outputs.DestinationGcsConfigurationFormatDestinationGcsUpdateOutputFormatParquetColumnarStorage;
}

export interface DestinationGcsConfigurationFormatDestinationGcsOutputFormatAvroApacheAvro {
    compressionCodec: outputs.DestinationGcsConfigurationFormatDestinationGcsOutputFormatAvroApacheAvroCompressionCodec;
    formatType: string;
}

export interface DestinationGcsConfigurationFormatDestinationGcsOutputFormatAvroApacheAvroCompressionCodec {
    destinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2?: outputs.DestinationGcsConfigurationFormatDestinationGcsOutputFormatAvroApacheAvroCompressionCodecDestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2;
    destinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflate?: outputs.DestinationGcsConfigurationFormatDestinationGcsOutputFormatAvroApacheAvroCompressionCodecDestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflate;
    destinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompression?: outputs.DestinationGcsConfigurationFormatDestinationGcsOutputFormatAvroApacheAvroCompressionCodecDestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompression;
    destinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappy?: outputs.DestinationGcsConfigurationFormatDestinationGcsOutputFormatAvroApacheAvroCompressionCodecDestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappy;
    destinationGcsOutputFormatAvroApacheAvroCompressionCodecXz?: outputs.DestinationGcsConfigurationFormatDestinationGcsOutputFormatAvroApacheAvroCompressionCodecDestinationGcsOutputFormatAvroApacheAvroCompressionCodecXz;
    destinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandard?: outputs.DestinationGcsConfigurationFormatDestinationGcsOutputFormatAvroApacheAvroCompressionCodecDestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandard;
}

export interface DestinationGcsConfigurationFormatDestinationGcsOutputFormatAvroApacheAvroCompressionCodecDestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2 {
    codec: string;
}

export interface DestinationGcsConfigurationFormatDestinationGcsOutputFormatAvroApacheAvroCompressionCodecDestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflate {
    codec: string;
    compressionLevel?: number;
}

export interface DestinationGcsConfigurationFormatDestinationGcsOutputFormatAvroApacheAvroCompressionCodecDestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompression {
    codec: string;
}

export interface DestinationGcsConfigurationFormatDestinationGcsOutputFormatAvroApacheAvroCompressionCodecDestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappy {
    codec: string;
}

export interface DestinationGcsConfigurationFormatDestinationGcsOutputFormatAvroApacheAvroCompressionCodecDestinationGcsOutputFormatAvroApacheAvroCompressionCodecXz {
    codec: string;
    compressionLevel?: number;
}

export interface DestinationGcsConfigurationFormatDestinationGcsOutputFormatAvroApacheAvroCompressionCodecDestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandard {
    codec: string;
    compressionLevel?: number;
    includeChecksum?: boolean;
}

export interface DestinationGcsConfigurationFormatDestinationGcsOutputFormatCsvCommaSeparatedValues {
    compression?: outputs.DestinationGcsConfigurationFormatDestinationGcsOutputFormatCsvCommaSeparatedValuesCompression;
    flattening?: string;
    formatType: string;
}

export interface DestinationGcsConfigurationFormatDestinationGcsOutputFormatCsvCommaSeparatedValuesCompression {
    destinationGcsOutputFormatCsvCommaSeparatedValuesCompressionGzip?: outputs.DestinationGcsConfigurationFormatDestinationGcsOutputFormatCsvCommaSeparatedValuesCompressionDestinationGcsOutputFormatCsvCommaSeparatedValuesCompressionGzip;
    destinationGcsOutputFormatCsvCommaSeparatedValuesCompressionNoCompression?: outputs.DestinationGcsConfigurationFormatDestinationGcsOutputFormatCsvCommaSeparatedValuesCompressionDestinationGcsOutputFormatCsvCommaSeparatedValuesCompressionNoCompression;
}

export interface DestinationGcsConfigurationFormatDestinationGcsOutputFormatCsvCommaSeparatedValuesCompressionDestinationGcsOutputFormatCsvCommaSeparatedValuesCompressionGzip {
    compressionType?: string;
}

export interface DestinationGcsConfigurationFormatDestinationGcsOutputFormatCsvCommaSeparatedValuesCompressionDestinationGcsOutputFormatCsvCommaSeparatedValuesCompressionNoCompression {
    compressionType?: string;
}

export interface DestinationGcsConfigurationFormatDestinationGcsOutputFormatJsonLinesNewlineDelimitedJson {
    compression?: outputs.DestinationGcsConfigurationFormatDestinationGcsOutputFormatJsonLinesNewlineDelimitedJsonCompression;
    formatType: string;
}

export interface DestinationGcsConfigurationFormatDestinationGcsOutputFormatJsonLinesNewlineDelimitedJsonCompression {
    destinationGcsOutputFormatJsonLinesNewlineDelimitedJsonCompressionGzip?: outputs.DestinationGcsConfigurationFormatDestinationGcsOutputFormatJsonLinesNewlineDelimitedJsonCompressionDestinationGcsOutputFormatJsonLinesNewlineDelimitedJsonCompressionGzip;
    destinationGcsOutputFormatJsonLinesNewlineDelimitedJsonCompressionNoCompression?: outputs.DestinationGcsConfigurationFormatDestinationGcsOutputFormatJsonLinesNewlineDelimitedJsonCompressionDestinationGcsOutputFormatJsonLinesNewlineDelimitedJsonCompressionNoCompression;
}

export interface DestinationGcsConfigurationFormatDestinationGcsOutputFormatJsonLinesNewlineDelimitedJsonCompressionDestinationGcsOutputFormatJsonLinesNewlineDelimitedJsonCompressionGzip {
    compressionType?: string;
}

export interface DestinationGcsConfigurationFormatDestinationGcsOutputFormatJsonLinesNewlineDelimitedJsonCompressionDestinationGcsOutputFormatJsonLinesNewlineDelimitedJsonCompressionNoCompression {
    compressionType?: string;
}

export interface DestinationGcsConfigurationFormatDestinationGcsOutputFormatParquetColumnarStorage {
    blockSizeMb?: number;
    compressionCodec?: string;
    dictionaryEncoding?: boolean;
    dictionaryPageSizeKb?: number;
    formatType: string;
    maxPaddingSizeMb?: number;
    pageSizeKb?: number;
}

export interface DestinationGcsConfigurationFormatDestinationGcsUpdateOutputFormatAvroApacheAvro {
    compressionCodec: outputs.DestinationGcsConfigurationFormatDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodec;
    formatType: string;
}

export interface DestinationGcsConfigurationFormatDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodec {
    destinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecBzip2?: outputs.DestinationGcsConfigurationFormatDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecBzip2;
    destinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecDeflate?: outputs.DestinationGcsConfigurationFormatDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecDeflate;
    destinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecNoCompression?: outputs.DestinationGcsConfigurationFormatDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecNoCompression;
    destinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecSnappy?: outputs.DestinationGcsConfigurationFormatDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecSnappy;
    destinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecXz?: outputs.DestinationGcsConfigurationFormatDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecXz;
    destinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecZstandard?: outputs.DestinationGcsConfigurationFormatDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecZstandard;
}

export interface DestinationGcsConfigurationFormatDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecBzip2 {
    codec: string;
}

export interface DestinationGcsConfigurationFormatDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecDeflate {
    codec: string;
    compressionLevel?: number;
}

export interface DestinationGcsConfigurationFormatDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecNoCompression {
    codec: string;
}

export interface DestinationGcsConfigurationFormatDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecSnappy {
    codec: string;
}

export interface DestinationGcsConfigurationFormatDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecXz {
    codec: string;
    compressionLevel?: number;
}

export interface DestinationGcsConfigurationFormatDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecZstandard {
    codec: string;
    compressionLevel?: number;
    includeChecksum?: boolean;
}

export interface DestinationGcsConfigurationFormatDestinationGcsUpdateOutputFormatCsvCommaSeparatedValues {
    compression?: outputs.DestinationGcsConfigurationFormatDestinationGcsUpdateOutputFormatCsvCommaSeparatedValuesCompression;
    flattening?: string;
    formatType: string;
}

export interface DestinationGcsConfigurationFormatDestinationGcsUpdateOutputFormatCsvCommaSeparatedValuesCompression {
    destinationGcsUpdateOutputFormatCsvCommaSeparatedValuesCompressionGzip?: outputs.DestinationGcsConfigurationFormatDestinationGcsUpdateOutputFormatCsvCommaSeparatedValuesCompressionDestinationGcsUpdateOutputFormatCsvCommaSeparatedValuesCompressionGzip;
    destinationGcsUpdateOutputFormatCsvCommaSeparatedValuesCompressionNoCompression?: outputs.DestinationGcsConfigurationFormatDestinationGcsUpdateOutputFormatCsvCommaSeparatedValuesCompressionDestinationGcsUpdateOutputFormatCsvCommaSeparatedValuesCompressionNoCompression;
}

export interface DestinationGcsConfigurationFormatDestinationGcsUpdateOutputFormatCsvCommaSeparatedValuesCompressionDestinationGcsUpdateOutputFormatCsvCommaSeparatedValuesCompressionGzip {
    compressionType?: string;
}

export interface DestinationGcsConfigurationFormatDestinationGcsUpdateOutputFormatCsvCommaSeparatedValuesCompressionDestinationGcsUpdateOutputFormatCsvCommaSeparatedValuesCompressionNoCompression {
    compressionType?: string;
}

export interface DestinationGcsConfigurationFormatDestinationGcsUpdateOutputFormatJsonLinesNewlineDelimitedJson {
    compression?: outputs.DestinationGcsConfigurationFormatDestinationGcsUpdateOutputFormatJsonLinesNewlineDelimitedJsonCompression;
    formatType: string;
}

export interface DestinationGcsConfigurationFormatDestinationGcsUpdateOutputFormatJsonLinesNewlineDelimitedJsonCompression {
    destinationGcsUpdateOutputFormatJsonLinesNewlineDelimitedJsonCompressionGzip?: outputs.DestinationGcsConfigurationFormatDestinationGcsUpdateOutputFormatJsonLinesNewlineDelimitedJsonCompressionDestinationGcsUpdateOutputFormatJsonLinesNewlineDelimitedJsonCompressionGzip;
    destinationGcsUpdateOutputFormatJsonLinesNewlineDelimitedJsonCompressionNoCompression?: outputs.DestinationGcsConfigurationFormatDestinationGcsUpdateOutputFormatJsonLinesNewlineDelimitedJsonCompressionDestinationGcsUpdateOutputFormatJsonLinesNewlineDelimitedJsonCompressionNoCompression;
}

export interface DestinationGcsConfigurationFormatDestinationGcsUpdateOutputFormatJsonLinesNewlineDelimitedJsonCompressionDestinationGcsUpdateOutputFormatJsonLinesNewlineDelimitedJsonCompressionGzip {
    compressionType?: string;
}

export interface DestinationGcsConfigurationFormatDestinationGcsUpdateOutputFormatJsonLinesNewlineDelimitedJsonCompressionDestinationGcsUpdateOutputFormatJsonLinesNewlineDelimitedJsonCompressionNoCompression {
    compressionType?: string;
}

export interface DestinationGcsConfigurationFormatDestinationGcsUpdateOutputFormatParquetColumnarStorage {
    blockSizeMb?: number;
    compressionCodec?: string;
    dictionaryEncoding?: boolean;
    dictionaryPageSizeKb?: number;
    formatType: string;
    maxPaddingSizeMb?: number;
    pageSizeKb?: number;
}

export interface DestinationGoogleSheetsConfiguration {
    /**
     * Google API Credentials for connecting to Google Sheets and Google Drive APIs
     */
    credentials: outputs.DestinationGoogleSheetsConfigurationCredentials;
    /**
     * must be one of ["google-sheets"]
     */
    destinationType: string;
    /**
     * The link to your spreadsheet. See \n\nthis guide\n\n for more details.
     */
    spreadsheetId: string;
}

export interface DestinationGoogleSheetsConfigurationCredentials {
    clientId: string;
    clientSecret: string;
    refreshToken: string;
}

export interface DestinationKeenConfiguration {
    /**
     * To get Keen Master API Key, navigate to the Access tab from the left-hand, side panel and check the Project Details section.
     */
    apiKey: string;
    /**
     * must be one of ["keen"]
     */
    destinationType: string;
    /**
     * Allow connector to guess keen.timestamp value based on the streamed data.
     */
    inferTimestamp?: boolean;
    /**
     * To get Keen Project ID, navigate to the Access tab from the left-hand, side panel and check the Project Details section.
     */
    projectId: string;
}

export interface DestinationKinesisConfiguration {
    /**
     * Generate the AWS Access Key for current user.
     */
    accessKey: string;
    /**
     * Buffer size for storing kinesis records before being batch streamed.
     */
    bufferSize: number;
    /**
     * must be one of ["kinesis"]
     */
    destinationType: string;
    /**
     * AWS Kinesis endpoint.
     */
    endpoint: string;
    /**
     * The AWS Private Key - a string of numbers and letters that are unique for each account, also known as a "recovery phrase".
     */
    privateKey: string;
    /**
     * AWS region. Your account determines the Regions that are available to you.
     */
    region: string;
    /**
     * Number of shards to which the data should be streamed.
     */
    shardCount: number;
}

export interface DestinationLangchainConfiguration {
    /**
     * must be one of ["langchain"]
     */
    destinationType: string;
    /**
     * Embedding configuration
     */
    embedding: outputs.DestinationLangchainConfigurationEmbedding;
    /**
     * Indexing configuration
     */
    indexing: outputs.DestinationLangchainConfigurationIndexing;
    processing: outputs.DestinationLangchainConfigurationProcessing;
}

export interface DestinationLangchainConfigurationEmbedding {
    destinationLangchainEmbeddingFake?: outputs.DestinationLangchainConfigurationEmbeddingDestinationLangchainEmbeddingFake;
    destinationLangchainEmbeddingOpenAi?: outputs.DestinationLangchainConfigurationEmbeddingDestinationLangchainEmbeddingOpenAi;
    destinationLangchainUpdateEmbeddingFake?: outputs.DestinationLangchainConfigurationEmbeddingDestinationLangchainUpdateEmbeddingFake;
    destinationLangchainUpdateEmbeddingOpenAi?: outputs.DestinationLangchainConfigurationEmbeddingDestinationLangchainUpdateEmbeddingOpenAi;
}

export interface DestinationLangchainConfigurationEmbeddingDestinationLangchainEmbeddingFake {
    mode?: string;
}

export interface DestinationLangchainConfigurationEmbeddingDestinationLangchainEmbeddingOpenAi {
    mode?: string;
    openaiKey: string;
}

export interface DestinationLangchainConfigurationEmbeddingDestinationLangchainUpdateEmbeddingFake {
    mode?: string;
}

export interface DestinationLangchainConfigurationEmbeddingDestinationLangchainUpdateEmbeddingOpenAi {
    mode?: string;
    openaiKey: string;
}

export interface DestinationLangchainConfigurationIndexing {
    destinationLangchainIndexingChromaLocalPersistance?: outputs.DestinationLangchainConfigurationIndexingDestinationLangchainIndexingChromaLocalPersistance;
    destinationLangchainIndexingDocArrayHnswSearch?: outputs.DestinationLangchainConfigurationIndexingDestinationLangchainIndexingDocArrayHnswSearch;
    destinationLangchainIndexingPinecone?: outputs.DestinationLangchainConfigurationIndexingDestinationLangchainIndexingPinecone;
    destinationLangchainUpdateIndexingChromaLocalPersistance?: outputs.DestinationLangchainConfigurationIndexingDestinationLangchainUpdateIndexingChromaLocalPersistance;
    destinationLangchainUpdateIndexingDocArrayHnswSearch?: outputs.DestinationLangchainConfigurationIndexingDestinationLangchainUpdateIndexingDocArrayHnswSearch;
    destinationLangchainUpdateIndexingPinecone?: outputs.DestinationLangchainConfigurationIndexingDestinationLangchainUpdateIndexingPinecone;
}

export interface DestinationLangchainConfigurationIndexingDestinationLangchainIndexingChromaLocalPersistance {
    collectionName?: string;
    destinationPath: string;
    mode?: string;
}

export interface DestinationLangchainConfigurationIndexingDestinationLangchainIndexingDocArrayHnswSearch {
    destinationPath: string;
    mode?: string;
}

export interface DestinationLangchainConfigurationIndexingDestinationLangchainIndexingPinecone {
    index: string;
    mode?: string;
    pineconeEnvironment: string;
    pineconeKey: string;
}

export interface DestinationLangchainConfigurationIndexingDestinationLangchainUpdateIndexingChromaLocalPersistance {
    collectionName?: string;
    destinationPath: string;
    mode?: string;
}

export interface DestinationLangchainConfigurationIndexingDestinationLangchainUpdateIndexingDocArrayHnswSearch {
    destinationPath: string;
    mode?: string;
}

export interface DestinationLangchainConfigurationIndexingDestinationLangchainUpdateIndexingPinecone {
    index: string;
    mode?: string;
    pineconeEnvironment: string;
    pineconeKey: string;
}

export interface DestinationLangchainConfigurationProcessing {
    chunkOverlap?: number;
    chunkSize: number;
    textFields: string[];
}

export interface DestinationMSsqlConfiguration {
    /**
     * The name of the MSSQL database.
     */
    database: string;
    /**
     * must be one of ["mssql"]
     */
    destinationType: string;
    /**
     * The host name of the MSSQL database.
     */
    host: string;
    /**
     * Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
     */
    jdbcUrlParams?: string;
    /**
     * The password associated with this username.
     */
    password?: string;
    /**
     * The port of the MSSQL database.
     */
    port: number;
    /**
     * The default schema tables are written to if the source does not specify a namespace. The usual value for this field is "public".
     */
    schema: string;
    /**
     * The encryption method which is used to communicate with the database.
     */
    sslMethod?: outputs.DestinationMSsqlConfigurationSslMethod;
    /**
     * Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
     */
    tunnelMethod?: outputs.DestinationMSsqlConfigurationTunnelMethod;
    /**
     * The username which is used to access the database.
     */
    username: string;
}

export interface DestinationMSsqlConfigurationSslMethod {
    destinationMssqlSslMethodEncryptedTrustServerCertificate?: outputs.DestinationMSsqlConfigurationSslMethodDestinationMssqlSslMethodEncryptedTrustServerCertificate;
    destinationMssqlSslMethodEncryptedVerifyCertificate?: outputs.DestinationMSsqlConfigurationSslMethodDestinationMssqlSslMethodEncryptedVerifyCertificate;
    destinationMssqlUpdateSslMethodEncryptedTrustServerCertificate?: outputs.DestinationMSsqlConfigurationSslMethodDestinationMssqlUpdateSslMethodEncryptedTrustServerCertificate;
    destinationMssqlUpdateSslMethodEncryptedVerifyCertificate?: outputs.DestinationMSsqlConfigurationSslMethodDestinationMssqlUpdateSslMethodEncryptedVerifyCertificate;
}

export interface DestinationMSsqlConfigurationSslMethodDestinationMssqlSslMethodEncryptedTrustServerCertificate {
    sslMethod: string;
}

export interface DestinationMSsqlConfigurationSslMethodDestinationMssqlSslMethodEncryptedVerifyCertificate {
    hostNameInCertificate?: string;
    sslMethod: string;
}

export interface DestinationMSsqlConfigurationSslMethodDestinationMssqlUpdateSslMethodEncryptedTrustServerCertificate {
    sslMethod: string;
}

export interface DestinationMSsqlConfigurationSslMethodDestinationMssqlUpdateSslMethodEncryptedVerifyCertificate {
    hostNameInCertificate?: string;
    sslMethod: string;
}

export interface DestinationMSsqlConfigurationTunnelMethod {
    destinationMssqlSshTunnelMethodNoTunnel?: outputs.DestinationMSsqlConfigurationTunnelMethodDestinationMssqlSshTunnelMethodNoTunnel;
    destinationMssqlSshTunnelMethodPasswordAuthentication?: outputs.DestinationMSsqlConfigurationTunnelMethodDestinationMssqlSshTunnelMethodPasswordAuthentication;
    destinationMssqlSshTunnelMethodSshKeyAuthentication?: outputs.DestinationMSsqlConfigurationTunnelMethodDestinationMssqlSshTunnelMethodSshKeyAuthentication;
    destinationMssqlUpdateSshTunnelMethodNoTunnel?: outputs.DestinationMSsqlConfigurationTunnelMethodDestinationMssqlUpdateSshTunnelMethodNoTunnel;
    destinationMssqlUpdateSshTunnelMethodPasswordAuthentication?: outputs.DestinationMSsqlConfigurationTunnelMethodDestinationMssqlUpdateSshTunnelMethodPasswordAuthentication;
    destinationMssqlUpdateSshTunnelMethodSshKeyAuthentication?: outputs.DestinationMSsqlConfigurationTunnelMethodDestinationMssqlUpdateSshTunnelMethodSshKeyAuthentication;
}

export interface DestinationMSsqlConfigurationTunnelMethodDestinationMssqlSshTunnelMethodNoTunnel {
    tunnelMethod: string;
}

export interface DestinationMSsqlConfigurationTunnelMethodDestinationMssqlSshTunnelMethodPasswordAuthentication {
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
    tunnelUserPassword: string;
}

export interface DestinationMSsqlConfigurationTunnelMethodDestinationMssqlSshTunnelMethodSshKeyAuthentication {
    sshKey: string;
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
}

export interface DestinationMSsqlConfigurationTunnelMethodDestinationMssqlUpdateSshTunnelMethodNoTunnel {
    tunnelMethod: string;
}

export interface DestinationMSsqlConfigurationTunnelMethodDestinationMssqlUpdateSshTunnelMethodPasswordAuthentication {
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
    tunnelUserPassword: string;
}

export interface DestinationMSsqlConfigurationTunnelMethodDestinationMssqlUpdateSshTunnelMethodSshKeyAuthentication {
    sshKey: string;
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
}

export interface DestinationMongodbConfiguration {
    /**
     * Authorization type.
     */
    authType: outputs.DestinationMongodbConfigurationAuthType;
    /**
     * Name of the database.
     */
    database: string;
    /**
     * must be one of ["mongodb"]
     */
    destinationType: string;
    /**
     * MongoDb instance to connect to. For MongoDB Atlas and Replica Set TLS connection is used by default.
     */
    instanceType?: outputs.DestinationMongodbConfigurationInstanceType;
    /**
     * Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
     */
    tunnelMethod?: outputs.DestinationMongodbConfigurationTunnelMethod;
}

export interface DestinationMongodbConfigurationAuthType {
    destinationMongodbAuthorizationTypeLoginPassword?: outputs.DestinationMongodbConfigurationAuthTypeDestinationMongodbAuthorizationTypeLoginPassword;
    destinationMongodbAuthorizationTypeNone?: outputs.DestinationMongodbConfigurationAuthTypeDestinationMongodbAuthorizationTypeNone;
    destinationMongodbUpdateAuthorizationTypeLoginPassword?: outputs.DestinationMongodbConfigurationAuthTypeDestinationMongodbUpdateAuthorizationTypeLoginPassword;
    destinationMongodbUpdateAuthorizationTypeNone?: outputs.DestinationMongodbConfigurationAuthTypeDestinationMongodbUpdateAuthorizationTypeNone;
}

export interface DestinationMongodbConfigurationAuthTypeDestinationMongodbAuthorizationTypeLoginPassword {
    authorization: string;
    password: string;
    username: string;
}

export interface DestinationMongodbConfigurationAuthTypeDestinationMongodbAuthorizationTypeNone {
    authorization: string;
}

export interface DestinationMongodbConfigurationAuthTypeDestinationMongodbUpdateAuthorizationTypeLoginPassword {
    authorization: string;
    password: string;
    username: string;
}

export interface DestinationMongodbConfigurationAuthTypeDestinationMongodbUpdateAuthorizationTypeNone {
    authorization: string;
}

export interface DestinationMongodbConfigurationInstanceType {
    destinationMongodbMongoDbInstanceTypeMongoDbAtlas?: outputs.DestinationMongodbConfigurationInstanceTypeDestinationMongodbMongoDbInstanceTypeMongoDbAtlas;
    destinationMongodbMongoDbInstanceTypeReplicaSet?: outputs.DestinationMongodbConfigurationInstanceTypeDestinationMongodbMongoDbInstanceTypeReplicaSet;
    destinationMongodbMongoDbInstanceTypeStandaloneMongoDbInstance?: outputs.DestinationMongodbConfigurationInstanceTypeDestinationMongodbMongoDbInstanceTypeStandaloneMongoDbInstance;
    destinationMongodbUpdateMongoDbInstanceTypeMongoDbAtlas?: outputs.DestinationMongodbConfigurationInstanceTypeDestinationMongodbUpdateMongoDbInstanceTypeMongoDbAtlas;
    destinationMongodbUpdateMongoDbInstanceTypeReplicaSet?: outputs.DestinationMongodbConfigurationInstanceTypeDestinationMongodbUpdateMongoDbInstanceTypeReplicaSet;
    destinationMongodbUpdateMongoDbInstanceTypeStandaloneMongoDbInstance?: outputs.DestinationMongodbConfigurationInstanceTypeDestinationMongodbUpdateMongoDbInstanceTypeStandaloneMongoDbInstance;
}

export interface DestinationMongodbConfigurationInstanceTypeDestinationMongodbMongoDbInstanceTypeMongoDbAtlas {
    clusterUrl: string;
    instance: string;
}

export interface DestinationMongodbConfigurationInstanceTypeDestinationMongodbMongoDbInstanceTypeReplicaSet {
    instance: string;
    replicaSet?: string;
    serverAddresses: string;
}

export interface DestinationMongodbConfigurationInstanceTypeDestinationMongodbMongoDbInstanceTypeStandaloneMongoDbInstance {
    host: string;
    instance: string;
    port: number;
}

export interface DestinationMongodbConfigurationInstanceTypeDestinationMongodbUpdateMongoDbInstanceTypeMongoDbAtlas {
    clusterUrl: string;
    instance: string;
}

export interface DestinationMongodbConfigurationInstanceTypeDestinationMongodbUpdateMongoDbInstanceTypeReplicaSet {
    instance: string;
    replicaSet?: string;
    serverAddresses: string;
}

export interface DestinationMongodbConfigurationInstanceTypeDestinationMongodbUpdateMongoDbInstanceTypeStandaloneMongoDbInstance {
    host: string;
    instance: string;
    port: number;
}

export interface DestinationMongodbConfigurationTunnelMethod {
    destinationMongodbSshTunnelMethodNoTunnel?: outputs.DestinationMongodbConfigurationTunnelMethodDestinationMongodbSshTunnelMethodNoTunnel;
    destinationMongodbSshTunnelMethodPasswordAuthentication?: outputs.DestinationMongodbConfigurationTunnelMethodDestinationMongodbSshTunnelMethodPasswordAuthentication;
    destinationMongodbSshTunnelMethodSshKeyAuthentication?: outputs.DestinationMongodbConfigurationTunnelMethodDestinationMongodbSshTunnelMethodSshKeyAuthentication;
    destinationMongodbUpdateSshTunnelMethodNoTunnel?: outputs.DestinationMongodbConfigurationTunnelMethodDestinationMongodbUpdateSshTunnelMethodNoTunnel;
    destinationMongodbUpdateSshTunnelMethodPasswordAuthentication?: outputs.DestinationMongodbConfigurationTunnelMethodDestinationMongodbUpdateSshTunnelMethodPasswordAuthentication;
    destinationMongodbUpdateSshTunnelMethodSshKeyAuthentication?: outputs.DestinationMongodbConfigurationTunnelMethodDestinationMongodbUpdateSshTunnelMethodSshKeyAuthentication;
}

export interface DestinationMongodbConfigurationTunnelMethodDestinationMongodbSshTunnelMethodNoTunnel {
    tunnelMethod: string;
}

export interface DestinationMongodbConfigurationTunnelMethodDestinationMongodbSshTunnelMethodPasswordAuthentication {
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
    tunnelUserPassword: string;
}

export interface DestinationMongodbConfigurationTunnelMethodDestinationMongodbSshTunnelMethodSshKeyAuthentication {
    sshKey: string;
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
}

export interface DestinationMongodbConfigurationTunnelMethodDestinationMongodbUpdateSshTunnelMethodNoTunnel {
    tunnelMethod: string;
}

export interface DestinationMongodbConfigurationTunnelMethodDestinationMongodbUpdateSshTunnelMethodPasswordAuthentication {
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
    tunnelUserPassword: string;
}

export interface DestinationMongodbConfigurationTunnelMethodDestinationMongodbUpdateSshTunnelMethodSshKeyAuthentication {
    sshKey: string;
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
}

export interface DestinationMysqlConfiguration {
    /**
     * Name of the database.
     */
    database: string;
    /**
     * must be one of ["mysql"]
     */
    destinationType: string;
    /**
     * Hostname of the database.
     */
    host: string;
    /**
     * Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
     */
    jdbcUrlParams?: string;
    /**
     * Password associated with the username.
     */
    password?: string;
    /**
     * Port of the database.
     */
    port: number;
    /**
     * Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
     */
    tunnelMethod?: outputs.DestinationMysqlConfigurationTunnelMethod;
    /**
     * Username to use to access the database.
     */
    username: string;
}

export interface DestinationMysqlConfigurationTunnelMethod {
    destinationMysqlSshTunnelMethodNoTunnel?: outputs.DestinationMysqlConfigurationTunnelMethodDestinationMysqlSshTunnelMethodNoTunnel;
    destinationMysqlSshTunnelMethodPasswordAuthentication?: outputs.DestinationMysqlConfigurationTunnelMethodDestinationMysqlSshTunnelMethodPasswordAuthentication;
    destinationMysqlSshTunnelMethodSshKeyAuthentication?: outputs.DestinationMysqlConfigurationTunnelMethodDestinationMysqlSshTunnelMethodSshKeyAuthentication;
    destinationMysqlUpdateSshTunnelMethodNoTunnel?: outputs.DestinationMysqlConfigurationTunnelMethodDestinationMysqlUpdateSshTunnelMethodNoTunnel;
    destinationMysqlUpdateSshTunnelMethodPasswordAuthentication?: outputs.DestinationMysqlConfigurationTunnelMethodDestinationMysqlUpdateSshTunnelMethodPasswordAuthentication;
    destinationMysqlUpdateSshTunnelMethodSshKeyAuthentication?: outputs.DestinationMysqlConfigurationTunnelMethodDestinationMysqlUpdateSshTunnelMethodSshKeyAuthentication;
}

export interface DestinationMysqlConfigurationTunnelMethodDestinationMysqlSshTunnelMethodNoTunnel {
    tunnelMethod: string;
}

export interface DestinationMysqlConfigurationTunnelMethodDestinationMysqlSshTunnelMethodPasswordAuthentication {
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
    tunnelUserPassword: string;
}

export interface DestinationMysqlConfigurationTunnelMethodDestinationMysqlSshTunnelMethodSshKeyAuthentication {
    sshKey: string;
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
}

export interface DestinationMysqlConfigurationTunnelMethodDestinationMysqlUpdateSshTunnelMethodNoTunnel {
    tunnelMethod: string;
}

export interface DestinationMysqlConfigurationTunnelMethodDestinationMysqlUpdateSshTunnelMethodPasswordAuthentication {
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
    tunnelUserPassword: string;
}

export interface DestinationMysqlConfigurationTunnelMethodDestinationMysqlUpdateSshTunnelMethodSshKeyAuthentication {
    sshKey: string;
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
}

export interface DestinationOracleConfiguration {
    /**
     * must be one of ["oracle"]
     */
    destinationType: string;
    /**
     * The hostname of the database.
     */
    host: string;
    /**
     * Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
     */
    jdbcUrlParams?: string;
    /**
     * The password associated with the username.
     */
    password?: string;
    /**
     * The port of the database.
     */
    port: number;
    /**
     * The default schema is used as the target schema for all statements issued from the connection that do not explicitly specify a schema name. The usual value for this field is "airbyte".  In Oracle, schemas and users are the same thing, so the "user" parameter is used as the login credentials and this is used for the default Airbyte message schema.
     */
    schema?: string;
    /**
     * The System Identifier uniquely distinguishes the instance from any other instance on the same computer.
     */
    sid: string;
    /**
     * Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
     */
    tunnelMethod?: outputs.DestinationOracleConfigurationTunnelMethod;
    /**
     * The username to access the database. This user must have CREATE USER privileges in the database.
     */
    username: string;
}

export interface DestinationOracleConfigurationTunnelMethod {
    destinationOracleSshTunnelMethodNoTunnel?: outputs.DestinationOracleConfigurationTunnelMethodDestinationOracleSshTunnelMethodNoTunnel;
    destinationOracleSshTunnelMethodPasswordAuthentication?: outputs.DestinationOracleConfigurationTunnelMethodDestinationOracleSshTunnelMethodPasswordAuthentication;
    destinationOracleSshTunnelMethodSshKeyAuthentication?: outputs.DestinationOracleConfigurationTunnelMethodDestinationOracleSshTunnelMethodSshKeyAuthentication;
    destinationOracleUpdateSshTunnelMethodNoTunnel?: outputs.DestinationOracleConfigurationTunnelMethodDestinationOracleUpdateSshTunnelMethodNoTunnel;
    destinationOracleUpdateSshTunnelMethodPasswordAuthentication?: outputs.DestinationOracleConfigurationTunnelMethodDestinationOracleUpdateSshTunnelMethodPasswordAuthentication;
    destinationOracleUpdateSshTunnelMethodSshKeyAuthentication?: outputs.DestinationOracleConfigurationTunnelMethodDestinationOracleUpdateSshTunnelMethodSshKeyAuthentication;
}

export interface DestinationOracleConfigurationTunnelMethodDestinationOracleSshTunnelMethodNoTunnel {
    tunnelMethod: string;
}

export interface DestinationOracleConfigurationTunnelMethodDestinationOracleSshTunnelMethodPasswordAuthentication {
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
    tunnelUserPassword: string;
}

export interface DestinationOracleConfigurationTunnelMethodDestinationOracleSshTunnelMethodSshKeyAuthentication {
    sshKey: string;
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
}

export interface DestinationOracleConfigurationTunnelMethodDestinationOracleUpdateSshTunnelMethodNoTunnel {
    tunnelMethod: string;
}

export interface DestinationOracleConfigurationTunnelMethodDestinationOracleUpdateSshTunnelMethodPasswordAuthentication {
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
    tunnelUserPassword: string;
}

export interface DestinationOracleConfigurationTunnelMethodDestinationOracleUpdateSshTunnelMethodSshKeyAuthentication {
    sshKey: string;
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
}

export interface DestinationPostgresConfiguration {
    /**
     * Name of the database.
     */
    database: string;
    /**
     * must be one of ["postgres"]
     */
    destinationType: string;
    /**
     * Hostname of the database.
     */
    host: string;
    /**
     * Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
     */
    jdbcUrlParams?: string;
    /**
     * Password associated with the username.
     */
    password?: string;
    /**
     * Port of the database.
     */
    port: number;
    /**
     * The default schema tables are written to if the source does not specify a namespace. The usual value for this field is "public".
     */
    schema: string;
    /**
     * SSL connection modes.
     * \n\ndisable\n\n - Chose this mode to disable encryption of communication between Airbyte and destination database
     * \n\nallow\n\n - Chose this mode to enable encryption only when required by the source database
     * \n\nprefer\n\n - Chose this mode to allow unencrypted connection only if the source database does not support encryption
     * \n\nrequire\n\n - Chose this mode to always require encryption. If the source database server does not support encryption, connection will fail
     * \n\nverify-ca\n\n - Chose this mode to always require encryption and to verify that the source database server has a valid SSL certificate
     * \n\nverify-full\n\n - This is the most secure mode. Chose this mode to always require encryption and to verify the identity of the source database server
     * See more information - \n\n in the docs\n\n.
     */
    sslMode?: outputs.DestinationPostgresConfigurationSslMode;
    /**
     * Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
     */
    tunnelMethod?: outputs.DestinationPostgresConfigurationTunnelMethod;
    /**
     * Username to use to access the database.
     */
    username: string;
}

export interface DestinationPostgresConfigurationSslMode {
    destinationPostgresSslModesAllow?: outputs.DestinationPostgresConfigurationSslModeDestinationPostgresSslModesAllow;
    destinationPostgresSslModesDisable?: outputs.DestinationPostgresConfigurationSslModeDestinationPostgresSslModesDisable;
    destinationPostgresSslModesPrefer?: outputs.DestinationPostgresConfigurationSslModeDestinationPostgresSslModesPrefer;
    destinationPostgresSslModesRequire?: outputs.DestinationPostgresConfigurationSslModeDestinationPostgresSslModesRequire;
    destinationPostgresSslModesVerifyCa?: outputs.DestinationPostgresConfigurationSslModeDestinationPostgresSslModesVerifyCa;
    destinationPostgresSslModesVerifyFull?: outputs.DestinationPostgresConfigurationSslModeDestinationPostgresSslModesVerifyFull;
    destinationPostgresUpdateSslModesAllow?: outputs.DestinationPostgresConfigurationSslModeDestinationPostgresUpdateSslModesAllow;
    destinationPostgresUpdateSslModesDisable?: outputs.DestinationPostgresConfigurationSslModeDestinationPostgresUpdateSslModesDisable;
    destinationPostgresUpdateSslModesPrefer?: outputs.DestinationPostgresConfigurationSslModeDestinationPostgresUpdateSslModesPrefer;
    destinationPostgresUpdateSslModesRequire?: outputs.DestinationPostgresConfigurationSslModeDestinationPostgresUpdateSslModesRequire;
    destinationPostgresUpdateSslModesVerifyCa?: outputs.DestinationPostgresConfigurationSslModeDestinationPostgresUpdateSslModesVerifyCa;
    destinationPostgresUpdateSslModesVerifyFull?: outputs.DestinationPostgresConfigurationSslModeDestinationPostgresUpdateSslModesVerifyFull;
}

export interface DestinationPostgresConfigurationSslModeDestinationPostgresSslModesAllow {
    mode: string;
}

export interface DestinationPostgresConfigurationSslModeDestinationPostgresSslModesDisable {
    mode: string;
}

export interface DestinationPostgresConfigurationSslModeDestinationPostgresSslModesPrefer {
    mode: string;
}

export interface DestinationPostgresConfigurationSslModeDestinationPostgresSslModesRequire {
    mode: string;
}

export interface DestinationPostgresConfigurationSslModeDestinationPostgresSslModesVerifyCa {
    caCertificate: string;
    clientKeyPassword?: string;
    mode: string;
}

export interface DestinationPostgresConfigurationSslModeDestinationPostgresSslModesVerifyFull {
    caCertificate: string;
    clientCertificate: string;
    clientKey: string;
    clientKeyPassword?: string;
    mode: string;
}

export interface DestinationPostgresConfigurationSslModeDestinationPostgresUpdateSslModesAllow {
    mode: string;
}

export interface DestinationPostgresConfigurationSslModeDestinationPostgresUpdateSslModesDisable {
    mode: string;
}

export interface DestinationPostgresConfigurationSslModeDestinationPostgresUpdateSslModesPrefer {
    mode: string;
}

export interface DestinationPostgresConfigurationSslModeDestinationPostgresUpdateSslModesRequire {
    mode: string;
}

export interface DestinationPostgresConfigurationSslModeDestinationPostgresUpdateSslModesVerifyCa {
    caCertificate: string;
    clientKeyPassword?: string;
    mode: string;
}

export interface DestinationPostgresConfigurationSslModeDestinationPostgresUpdateSslModesVerifyFull {
    caCertificate: string;
    clientCertificate: string;
    clientKey: string;
    clientKeyPassword?: string;
    mode: string;
}

export interface DestinationPostgresConfigurationTunnelMethod {
    destinationPostgresSshTunnelMethodNoTunnel?: outputs.DestinationPostgresConfigurationTunnelMethodDestinationPostgresSshTunnelMethodNoTunnel;
    destinationPostgresSshTunnelMethodPasswordAuthentication?: outputs.DestinationPostgresConfigurationTunnelMethodDestinationPostgresSshTunnelMethodPasswordAuthentication;
    destinationPostgresSshTunnelMethodSshKeyAuthentication?: outputs.DestinationPostgresConfigurationTunnelMethodDestinationPostgresSshTunnelMethodSshKeyAuthentication;
    destinationPostgresUpdateSshTunnelMethodNoTunnel?: outputs.DestinationPostgresConfigurationTunnelMethodDestinationPostgresUpdateSshTunnelMethodNoTunnel;
    destinationPostgresUpdateSshTunnelMethodPasswordAuthentication?: outputs.DestinationPostgresConfigurationTunnelMethodDestinationPostgresUpdateSshTunnelMethodPasswordAuthentication;
    destinationPostgresUpdateSshTunnelMethodSshKeyAuthentication?: outputs.DestinationPostgresConfigurationTunnelMethodDestinationPostgresUpdateSshTunnelMethodSshKeyAuthentication;
}

export interface DestinationPostgresConfigurationTunnelMethodDestinationPostgresSshTunnelMethodNoTunnel {
    tunnelMethod: string;
}

export interface DestinationPostgresConfigurationTunnelMethodDestinationPostgresSshTunnelMethodPasswordAuthentication {
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
    tunnelUserPassword: string;
}

export interface DestinationPostgresConfigurationTunnelMethodDestinationPostgresSshTunnelMethodSshKeyAuthentication {
    sshKey: string;
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
}

export interface DestinationPostgresConfigurationTunnelMethodDestinationPostgresUpdateSshTunnelMethodNoTunnel {
    tunnelMethod: string;
}

export interface DestinationPostgresConfigurationTunnelMethodDestinationPostgresUpdateSshTunnelMethodPasswordAuthentication {
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
    tunnelUserPassword: string;
}

export interface DestinationPostgresConfigurationTunnelMethodDestinationPostgresUpdateSshTunnelMethodSshKeyAuthentication {
    sshKey: string;
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
}

export interface DestinationPubsubConfiguration {
    /**
     * Number of ms before the buffer is flushed
     */
    batchingDelayThreshold?: number;
    /**
     * Number of messages before the buffer is flushed
     */
    batchingElementCountThreshold?: number;
    /**
     * If TRUE messages will be buffered instead of sending them one by one
     */
    batchingEnabled: boolean;
    /**
     * Number of bytes before the buffer is flushed
     */
    batchingRequestBytesThreshold?: number;
    /**
     * The contents of the JSON service account key. Check out the \n\ndocs\n\n if you need help generating this key.
     */
    credentialsJson: string;
    /**
     * must be one of ["pubsub"]
     */
    destinationType: string;
    /**
     * If TRUE PubSub publisher will have \n\nmessage ordering\n\n enabled. Every message will have an ordering key of stream
     */
    orderingEnabled: boolean;
    /**
     * The GCP project ID for the project containing the target PubSub.
     */
    projectId: string;
    /**
     * The PubSub topic ID in the given GCP project ID.
     */
    topicId: string;
}

export interface DestinationRedisConfiguration {
    /**
     * must be one of ["hash"]
     * Redis cache type to store data in.
     */
    cacheType: string;
    /**
     * must be one of ["redis"]
     */
    destinationType: string;
    /**
     * Redis host to connect to.
     */
    host: string;
    /**
     * Password associated with Redis.
     */
    password?: string;
    /**
     * Port of Redis.
     */
    port: number;
    /**
     * Indicates whether SSL encryption protocol will be used to connect to Redis. It is recommended to use SSL connection if possible.
     */
    ssl?: boolean;
    /**
     * SSL connection modes.
     * \n\n\n\nverify-full\n\n - This is the most secure mode. Always require encryption and verifies the identity of the source database server
     */
    sslMode?: outputs.DestinationRedisConfigurationSslMode;
    /**
     * Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
     */
    tunnelMethod?: outputs.DestinationRedisConfigurationTunnelMethod;
    /**
     * Username associated with Redis.
     */
    username: string;
}

export interface DestinationRedisConfigurationSslMode {
    destinationRedisSslModesDisable?: outputs.DestinationRedisConfigurationSslModeDestinationRedisSslModesDisable;
    destinationRedisSslModesVerifyFull?: outputs.DestinationRedisConfigurationSslModeDestinationRedisSslModesVerifyFull;
    destinationRedisUpdateSslModesDisable?: outputs.DestinationRedisConfigurationSslModeDestinationRedisUpdateSslModesDisable;
    destinationRedisUpdateSslModesVerifyFull?: outputs.DestinationRedisConfigurationSslModeDestinationRedisUpdateSslModesVerifyFull;
}

export interface DestinationRedisConfigurationSslModeDestinationRedisSslModesDisable {
    mode: string;
}

export interface DestinationRedisConfigurationSslModeDestinationRedisSslModesVerifyFull {
    caCertificate: string;
    clientCertificate: string;
    clientKey: string;
    clientKeyPassword?: string;
    mode: string;
}

export interface DestinationRedisConfigurationSslModeDestinationRedisUpdateSslModesDisable {
    mode: string;
}

export interface DestinationRedisConfigurationSslModeDestinationRedisUpdateSslModesVerifyFull {
    caCertificate: string;
    clientCertificate: string;
    clientKey: string;
    clientKeyPassword?: string;
    mode: string;
}

export interface DestinationRedisConfigurationTunnelMethod {
    destinationRedisSshTunnelMethodNoTunnel?: outputs.DestinationRedisConfigurationTunnelMethodDestinationRedisSshTunnelMethodNoTunnel;
    destinationRedisSshTunnelMethodPasswordAuthentication?: outputs.DestinationRedisConfigurationTunnelMethodDestinationRedisSshTunnelMethodPasswordAuthentication;
    destinationRedisSshTunnelMethodSshKeyAuthentication?: outputs.DestinationRedisConfigurationTunnelMethodDestinationRedisSshTunnelMethodSshKeyAuthentication;
    destinationRedisUpdateSshTunnelMethodNoTunnel?: outputs.DestinationRedisConfigurationTunnelMethodDestinationRedisUpdateSshTunnelMethodNoTunnel;
    destinationRedisUpdateSshTunnelMethodPasswordAuthentication?: outputs.DestinationRedisConfigurationTunnelMethodDestinationRedisUpdateSshTunnelMethodPasswordAuthentication;
    destinationRedisUpdateSshTunnelMethodSshKeyAuthentication?: outputs.DestinationRedisConfigurationTunnelMethodDestinationRedisUpdateSshTunnelMethodSshKeyAuthentication;
}

export interface DestinationRedisConfigurationTunnelMethodDestinationRedisSshTunnelMethodNoTunnel {
    tunnelMethod: string;
}

export interface DestinationRedisConfigurationTunnelMethodDestinationRedisSshTunnelMethodPasswordAuthentication {
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
    tunnelUserPassword: string;
}

export interface DestinationRedisConfigurationTunnelMethodDestinationRedisSshTunnelMethodSshKeyAuthentication {
    sshKey: string;
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
}

export interface DestinationRedisConfigurationTunnelMethodDestinationRedisUpdateSshTunnelMethodNoTunnel {
    tunnelMethod: string;
}

export interface DestinationRedisConfigurationTunnelMethodDestinationRedisUpdateSshTunnelMethodPasswordAuthentication {
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
    tunnelUserPassword: string;
}

export interface DestinationRedisConfigurationTunnelMethodDestinationRedisUpdateSshTunnelMethodSshKeyAuthentication {
    sshKey: string;
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
}

export interface DestinationRedshiftConfiguration {
    /**
     * Name of the database.
     */
    database: string;
    /**
     * must be one of ["redshift"]
     */
    destinationType: string;
    /**
     * Host Endpoint of the Redshift Cluster (must include the cluster-id, region and end with .redshift.amazonaws.com)
     */
    host: string;
    /**
     * Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
     */
    jdbcUrlParams?: string;
    /**
     * Password associated with the username.
     */
    password: string;
    /**
     * Port of the database.
     */
    port: number;
    /**
     * The default schema tables are written to if the source does not specify a namespace. Unless specifically configured, the usual value for this field is "public".
     */
    schema: string;
    /**
     * Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
     */
    tunnelMethod?: outputs.DestinationRedshiftConfigurationTunnelMethod;
    /**
     * The method how the data will be uploaded to the database.
     */
    uploadingMethod?: outputs.DestinationRedshiftConfigurationUploadingMethod;
    /**
     * Username to use to access the database.
     */
    username: string;
}

export interface DestinationRedshiftConfigurationTunnelMethod {
    destinationRedshiftSshTunnelMethodNoTunnel?: outputs.DestinationRedshiftConfigurationTunnelMethodDestinationRedshiftSshTunnelMethodNoTunnel;
    destinationRedshiftSshTunnelMethodPasswordAuthentication?: outputs.DestinationRedshiftConfigurationTunnelMethodDestinationRedshiftSshTunnelMethodPasswordAuthentication;
    destinationRedshiftSshTunnelMethodSshKeyAuthentication?: outputs.DestinationRedshiftConfigurationTunnelMethodDestinationRedshiftSshTunnelMethodSshKeyAuthentication;
    destinationRedshiftUpdateSshTunnelMethodNoTunnel?: outputs.DestinationRedshiftConfigurationTunnelMethodDestinationRedshiftUpdateSshTunnelMethodNoTunnel;
    destinationRedshiftUpdateSshTunnelMethodPasswordAuthentication?: outputs.DestinationRedshiftConfigurationTunnelMethodDestinationRedshiftUpdateSshTunnelMethodPasswordAuthentication;
    destinationRedshiftUpdateSshTunnelMethodSshKeyAuthentication?: outputs.DestinationRedshiftConfigurationTunnelMethodDestinationRedshiftUpdateSshTunnelMethodSshKeyAuthentication;
}

export interface DestinationRedshiftConfigurationTunnelMethodDestinationRedshiftSshTunnelMethodNoTunnel {
    tunnelMethod: string;
}

export interface DestinationRedshiftConfigurationTunnelMethodDestinationRedshiftSshTunnelMethodPasswordAuthentication {
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
    tunnelUserPassword: string;
}

export interface DestinationRedshiftConfigurationTunnelMethodDestinationRedshiftSshTunnelMethodSshKeyAuthentication {
    sshKey: string;
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
}

export interface DestinationRedshiftConfigurationTunnelMethodDestinationRedshiftUpdateSshTunnelMethodNoTunnel {
    tunnelMethod: string;
}

export interface DestinationRedshiftConfigurationTunnelMethodDestinationRedshiftUpdateSshTunnelMethodPasswordAuthentication {
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
    tunnelUserPassword: string;
}

export interface DestinationRedshiftConfigurationTunnelMethodDestinationRedshiftUpdateSshTunnelMethodSshKeyAuthentication {
    sshKey: string;
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
}

export interface DestinationRedshiftConfigurationUploadingMethod {
    destinationRedshiftUpdateUploadingMethodS3Staging?: outputs.DestinationRedshiftConfigurationUploadingMethodDestinationRedshiftUpdateUploadingMethodS3Staging;
    destinationRedshiftUpdateUploadingMethodStandard?: outputs.DestinationRedshiftConfigurationUploadingMethodDestinationRedshiftUpdateUploadingMethodStandard;
    destinationRedshiftUploadingMethodS3Staging?: outputs.DestinationRedshiftConfigurationUploadingMethodDestinationRedshiftUploadingMethodS3Staging;
    destinationRedshiftUploadingMethodStandard?: outputs.DestinationRedshiftConfigurationUploadingMethodDestinationRedshiftUploadingMethodStandard;
}

export interface DestinationRedshiftConfigurationUploadingMethodDestinationRedshiftUpdateUploadingMethodS3Staging {
    accessKeyId: string;
    encryption?: outputs.DestinationRedshiftConfigurationUploadingMethodDestinationRedshiftUpdateUploadingMethodS3StagingEncryption;
    fileBufferCount?: number;
    fileNamePattern?: string;
    method: string;
    purgeStagingData?: boolean;
    s3BucketName: string;
    s3BucketPath?: string;
    s3BucketRegion: string;
    secretAccessKey: string;
}

export interface DestinationRedshiftConfigurationUploadingMethodDestinationRedshiftUpdateUploadingMethodS3StagingEncryption {
    destinationRedshiftUpdateUploadingMethodS3StagingEncryptionAesCbcEnvelopeEncryption?: outputs.DestinationRedshiftConfigurationUploadingMethodDestinationRedshiftUpdateUploadingMethodS3StagingEncryptionDestinationRedshiftUpdateUploadingMethodS3StagingEncryptionAesCbcEnvelopeEncryption;
    destinationRedshiftUpdateUploadingMethodS3StagingEncryptionNoEncryption?: outputs.DestinationRedshiftConfigurationUploadingMethodDestinationRedshiftUpdateUploadingMethodS3StagingEncryptionDestinationRedshiftUpdateUploadingMethodS3StagingEncryptionNoEncryption;
}

export interface DestinationRedshiftConfigurationUploadingMethodDestinationRedshiftUpdateUploadingMethodS3StagingEncryptionDestinationRedshiftUpdateUploadingMethodS3StagingEncryptionAesCbcEnvelopeEncryption {
    encryptionType: string;
    keyEncryptingKey?: string;
}

export interface DestinationRedshiftConfigurationUploadingMethodDestinationRedshiftUpdateUploadingMethodS3StagingEncryptionDestinationRedshiftUpdateUploadingMethodS3StagingEncryptionNoEncryption {
    encryptionType: string;
}

export interface DestinationRedshiftConfigurationUploadingMethodDestinationRedshiftUpdateUploadingMethodStandard {
    method: string;
}

export interface DestinationRedshiftConfigurationUploadingMethodDestinationRedshiftUploadingMethodS3Staging {
    accessKeyId: string;
    encryption?: outputs.DestinationRedshiftConfigurationUploadingMethodDestinationRedshiftUploadingMethodS3StagingEncryption;
    fileBufferCount?: number;
    fileNamePattern?: string;
    method: string;
    purgeStagingData?: boolean;
    s3BucketName: string;
    s3BucketPath?: string;
    s3BucketRegion: string;
    secretAccessKey: string;
}

export interface DestinationRedshiftConfigurationUploadingMethodDestinationRedshiftUploadingMethodS3StagingEncryption {
    destinationRedshiftUploadingMethodS3StagingEncryptionAesCbcEnvelopeEncryption?: outputs.DestinationRedshiftConfigurationUploadingMethodDestinationRedshiftUploadingMethodS3StagingEncryptionDestinationRedshiftUploadingMethodS3StagingEncryptionAesCbcEnvelopeEncryption;
    destinationRedshiftUploadingMethodS3StagingEncryptionNoEncryption?: outputs.DestinationRedshiftConfigurationUploadingMethodDestinationRedshiftUploadingMethodS3StagingEncryptionDestinationRedshiftUploadingMethodS3StagingEncryptionNoEncryption;
}

export interface DestinationRedshiftConfigurationUploadingMethodDestinationRedshiftUploadingMethodS3StagingEncryptionDestinationRedshiftUploadingMethodS3StagingEncryptionAesCbcEnvelopeEncryption {
    encryptionType: string;
    keyEncryptingKey?: string;
}

export interface DestinationRedshiftConfigurationUploadingMethodDestinationRedshiftUploadingMethodS3StagingEncryptionDestinationRedshiftUploadingMethodS3StagingEncryptionNoEncryption {
    encryptionType: string;
}

export interface DestinationRedshiftConfigurationUploadingMethodDestinationRedshiftUploadingMethodStandard {
    method: string;
}

export interface DestinationS3Configuration {
    /**
     * The access key ID to access the S3 bucket. Airbyte requires Read and Write permissions to the given bucket. Read more \n\nhere\n\n.
     */
    accessKeyId?: string;
    /**
     * must be one of ["s3"]
     */
    destinationType: string;
    /**
     * The pattern allows you to set the file-name format for the S3 staging file(s)
     */
    fileNamePattern?: string;
    /**
     * Format of the data output. See \n\nhere\n\n for more details
     */
    format: outputs.DestinationS3ConfigurationFormat;
    /**
     * The name of the S3 bucket. Read more \n\nhere\n\n.
     */
    s3BucketName: string;
    /**
     * Directory under the S3 bucket where data will be written. Read more \n\nhere\n\n
     */
    s3BucketPath: string;
    /**
     * must be one of ["", "us-east-1", "us-east-2", "us-west-1", "us-west-2", "af-south-1", "ap-east-1", "ap-south-1", "ap-northeast-1", "ap-northeast-2", "ap-northeast-3", "ap-southeast-1", "ap-southeast-2", "ca-central-1", "cn-north-1", "cn-northwest-1", "eu-central-1", "eu-north-1", "eu-south-1", "eu-west-1", "eu-west-2", "eu-west-3", "sa-east-1", "me-south-1", "us-gov-east-1", "us-gov-west-1"]
     * The region of the S3 bucket. See \n\nhere\n\n for all region codes.
     */
    s3BucketRegion: string;
    /**
     * Your S3 endpoint url. Read more \n\nhere\n\n
     */
    s3Endpoint?: string;
    /**
     * Format string on how data will be organized inside the S3 bucket directory. Read more \n\nhere\n\n
     */
    s3PathFormat?: string;
    /**
     * The corresponding secret to the access key ID. Read more \n\nhere\n\n
     */
    secretAccessKey?: string;
}

export interface DestinationS3ConfigurationFormat {
    destinationS3OutputFormatAvroApacheAvro?: outputs.DestinationS3ConfigurationFormatDestinationS3OutputFormatAvroApacheAvro;
    destinationS3OutputFormatCsvCommaSeparatedValues?: outputs.DestinationS3ConfigurationFormatDestinationS3OutputFormatCsvCommaSeparatedValues;
    destinationS3OutputFormatJsonLinesNewlineDelimitedJson?: outputs.DestinationS3ConfigurationFormatDestinationS3OutputFormatJsonLinesNewlineDelimitedJson;
    destinationS3OutputFormatParquetColumnarStorage?: outputs.DestinationS3ConfigurationFormatDestinationS3OutputFormatParquetColumnarStorage;
    destinationS3UpdateOutputFormatAvroApacheAvro?: outputs.DestinationS3ConfigurationFormatDestinationS3UpdateOutputFormatAvroApacheAvro;
    destinationS3UpdateOutputFormatCsvCommaSeparatedValues?: outputs.DestinationS3ConfigurationFormatDestinationS3UpdateOutputFormatCsvCommaSeparatedValues;
    destinationS3UpdateOutputFormatJsonLinesNewlineDelimitedJson?: outputs.DestinationS3ConfigurationFormatDestinationS3UpdateOutputFormatJsonLinesNewlineDelimitedJson;
    destinationS3UpdateOutputFormatParquetColumnarStorage?: outputs.DestinationS3ConfigurationFormatDestinationS3UpdateOutputFormatParquetColumnarStorage;
}

export interface DestinationS3ConfigurationFormatDestinationS3OutputFormatAvroApacheAvro {
    compressionCodec: outputs.DestinationS3ConfigurationFormatDestinationS3OutputFormatAvroApacheAvroCompressionCodec;
    formatType: string;
}

export interface DestinationS3ConfigurationFormatDestinationS3OutputFormatAvroApacheAvroCompressionCodec {
    destinationS3OutputFormatAvroApacheAvroCompressionCodecBzip2?: outputs.DestinationS3ConfigurationFormatDestinationS3OutputFormatAvroApacheAvroCompressionCodecDestinationS3OutputFormatAvroApacheAvroCompressionCodecBzip2;
    destinationS3OutputFormatAvroApacheAvroCompressionCodecDeflate?: outputs.DestinationS3ConfigurationFormatDestinationS3OutputFormatAvroApacheAvroCompressionCodecDestinationS3OutputFormatAvroApacheAvroCompressionCodecDeflate;
    destinationS3OutputFormatAvroApacheAvroCompressionCodecNoCompression?: outputs.DestinationS3ConfigurationFormatDestinationS3OutputFormatAvroApacheAvroCompressionCodecDestinationS3OutputFormatAvroApacheAvroCompressionCodecNoCompression;
    destinationS3OutputFormatAvroApacheAvroCompressionCodecSnappy?: outputs.DestinationS3ConfigurationFormatDestinationS3OutputFormatAvroApacheAvroCompressionCodecDestinationS3OutputFormatAvroApacheAvroCompressionCodecSnappy;
    destinationS3OutputFormatAvroApacheAvroCompressionCodecXz?: outputs.DestinationS3ConfigurationFormatDestinationS3OutputFormatAvroApacheAvroCompressionCodecDestinationS3OutputFormatAvroApacheAvroCompressionCodecXz;
    destinationS3OutputFormatAvroApacheAvroCompressionCodecZstandard?: outputs.DestinationS3ConfigurationFormatDestinationS3OutputFormatAvroApacheAvroCompressionCodecDestinationS3OutputFormatAvroApacheAvroCompressionCodecZstandard;
}

export interface DestinationS3ConfigurationFormatDestinationS3OutputFormatAvroApacheAvroCompressionCodecDestinationS3OutputFormatAvroApacheAvroCompressionCodecBzip2 {
    codec: string;
}

export interface DestinationS3ConfigurationFormatDestinationS3OutputFormatAvroApacheAvroCompressionCodecDestinationS3OutputFormatAvroApacheAvroCompressionCodecDeflate {
    codec: string;
    compressionLevel: number;
}

export interface DestinationS3ConfigurationFormatDestinationS3OutputFormatAvroApacheAvroCompressionCodecDestinationS3OutputFormatAvroApacheAvroCompressionCodecNoCompression {
    codec: string;
}

export interface DestinationS3ConfigurationFormatDestinationS3OutputFormatAvroApacheAvroCompressionCodecDestinationS3OutputFormatAvroApacheAvroCompressionCodecSnappy {
    codec: string;
}

export interface DestinationS3ConfigurationFormatDestinationS3OutputFormatAvroApacheAvroCompressionCodecDestinationS3OutputFormatAvroApacheAvroCompressionCodecXz {
    codec: string;
    compressionLevel: number;
}

export interface DestinationS3ConfigurationFormatDestinationS3OutputFormatAvroApacheAvroCompressionCodecDestinationS3OutputFormatAvroApacheAvroCompressionCodecZstandard {
    codec: string;
    compressionLevel: number;
    includeChecksum?: boolean;
}

export interface DestinationS3ConfigurationFormatDestinationS3OutputFormatCsvCommaSeparatedValues {
    compression?: outputs.DestinationS3ConfigurationFormatDestinationS3OutputFormatCsvCommaSeparatedValuesCompression;
    flattening: string;
    formatType: string;
}

export interface DestinationS3ConfigurationFormatDestinationS3OutputFormatCsvCommaSeparatedValuesCompression {
    destinationS3OutputFormatCsvCommaSeparatedValuesCompressionGzip?: outputs.DestinationS3ConfigurationFormatDestinationS3OutputFormatCsvCommaSeparatedValuesCompressionDestinationS3OutputFormatCsvCommaSeparatedValuesCompressionGzip;
    destinationS3OutputFormatCsvCommaSeparatedValuesCompressionNoCompression?: outputs.DestinationS3ConfigurationFormatDestinationS3OutputFormatCsvCommaSeparatedValuesCompressionDestinationS3OutputFormatCsvCommaSeparatedValuesCompressionNoCompression;
}

export interface DestinationS3ConfigurationFormatDestinationS3OutputFormatCsvCommaSeparatedValuesCompressionDestinationS3OutputFormatCsvCommaSeparatedValuesCompressionGzip {
    compressionType?: string;
}

export interface DestinationS3ConfigurationFormatDestinationS3OutputFormatCsvCommaSeparatedValuesCompressionDestinationS3OutputFormatCsvCommaSeparatedValuesCompressionNoCompression {
    compressionType?: string;
}

export interface DestinationS3ConfigurationFormatDestinationS3OutputFormatJsonLinesNewlineDelimitedJson {
    compression?: outputs.DestinationS3ConfigurationFormatDestinationS3OutputFormatJsonLinesNewlineDelimitedJsonCompression;
    flattening?: string;
    formatType: string;
}

export interface DestinationS3ConfigurationFormatDestinationS3OutputFormatJsonLinesNewlineDelimitedJsonCompression {
    destinationS3OutputFormatJsonLinesNewlineDelimitedJsonCompressionGzip?: outputs.DestinationS3ConfigurationFormatDestinationS3OutputFormatJsonLinesNewlineDelimitedJsonCompressionDestinationS3OutputFormatJsonLinesNewlineDelimitedJsonCompressionGzip;
    destinationS3OutputFormatJsonLinesNewlineDelimitedJsonCompressionNoCompression?: outputs.DestinationS3ConfigurationFormatDestinationS3OutputFormatJsonLinesNewlineDelimitedJsonCompressionDestinationS3OutputFormatJsonLinesNewlineDelimitedJsonCompressionNoCompression;
}

export interface DestinationS3ConfigurationFormatDestinationS3OutputFormatJsonLinesNewlineDelimitedJsonCompressionDestinationS3OutputFormatJsonLinesNewlineDelimitedJsonCompressionGzip {
    compressionType?: string;
}

export interface DestinationS3ConfigurationFormatDestinationS3OutputFormatJsonLinesNewlineDelimitedJsonCompressionDestinationS3OutputFormatJsonLinesNewlineDelimitedJsonCompressionNoCompression {
    compressionType?: string;
}

export interface DestinationS3ConfigurationFormatDestinationS3OutputFormatParquetColumnarStorage {
    blockSizeMb?: number;
    compressionCodec?: string;
    dictionaryEncoding?: boolean;
    dictionaryPageSizeKb?: number;
    formatType: string;
    maxPaddingSizeMb?: number;
    pageSizeKb?: number;
}

export interface DestinationS3ConfigurationFormatDestinationS3UpdateOutputFormatAvroApacheAvro {
    compressionCodec: outputs.DestinationS3ConfigurationFormatDestinationS3UpdateOutputFormatAvroApacheAvroCompressionCodec;
    formatType: string;
}

export interface DestinationS3ConfigurationFormatDestinationS3UpdateOutputFormatAvroApacheAvroCompressionCodec {
    destinationS3UpdateOutputFormatAvroApacheAvroCompressionCodecBzip2?: outputs.DestinationS3ConfigurationFormatDestinationS3UpdateOutputFormatAvroApacheAvroCompressionCodecDestinationS3UpdateOutputFormatAvroApacheAvroCompressionCodecBzip2;
    destinationS3UpdateOutputFormatAvroApacheAvroCompressionCodecDeflate?: outputs.DestinationS3ConfigurationFormatDestinationS3UpdateOutputFormatAvroApacheAvroCompressionCodecDestinationS3UpdateOutputFormatAvroApacheAvroCompressionCodecDeflate;
    destinationS3UpdateOutputFormatAvroApacheAvroCompressionCodecNoCompression?: outputs.DestinationS3ConfigurationFormatDestinationS3UpdateOutputFormatAvroApacheAvroCompressionCodecDestinationS3UpdateOutputFormatAvroApacheAvroCompressionCodecNoCompression;
    destinationS3UpdateOutputFormatAvroApacheAvroCompressionCodecSnappy?: outputs.DestinationS3ConfigurationFormatDestinationS3UpdateOutputFormatAvroApacheAvroCompressionCodecDestinationS3UpdateOutputFormatAvroApacheAvroCompressionCodecSnappy;
    destinationS3UpdateOutputFormatAvroApacheAvroCompressionCodecXz?: outputs.DestinationS3ConfigurationFormatDestinationS3UpdateOutputFormatAvroApacheAvroCompressionCodecDestinationS3UpdateOutputFormatAvroApacheAvroCompressionCodecXz;
    destinationS3UpdateOutputFormatAvroApacheAvroCompressionCodecZstandard?: outputs.DestinationS3ConfigurationFormatDestinationS3UpdateOutputFormatAvroApacheAvroCompressionCodecDestinationS3UpdateOutputFormatAvroApacheAvroCompressionCodecZstandard;
}

export interface DestinationS3ConfigurationFormatDestinationS3UpdateOutputFormatAvroApacheAvroCompressionCodecDestinationS3UpdateOutputFormatAvroApacheAvroCompressionCodecBzip2 {
    codec: string;
}

export interface DestinationS3ConfigurationFormatDestinationS3UpdateOutputFormatAvroApacheAvroCompressionCodecDestinationS3UpdateOutputFormatAvroApacheAvroCompressionCodecDeflate {
    codec: string;
    compressionLevel: number;
}

export interface DestinationS3ConfigurationFormatDestinationS3UpdateOutputFormatAvroApacheAvroCompressionCodecDestinationS3UpdateOutputFormatAvroApacheAvroCompressionCodecNoCompression {
    codec: string;
}

export interface DestinationS3ConfigurationFormatDestinationS3UpdateOutputFormatAvroApacheAvroCompressionCodecDestinationS3UpdateOutputFormatAvroApacheAvroCompressionCodecSnappy {
    codec: string;
}

export interface DestinationS3ConfigurationFormatDestinationS3UpdateOutputFormatAvroApacheAvroCompressionCodecDestinationS3UpdateOutputFormatAvroApacheAvroCompressionCodecXz {
    codec: string;
    compressionLevel: number;
}

export interface DestinationS3ConfigurationFormatDestinationS3UpdateOutputFormatAvroApacheAvroCompressionCodecDestinationS3UpdateOutputFormatAvroApacheAvroCompressionCodecZstandard {
    codec: string;
    compressionLevel: number;
    includeChecksum?: boolean;
}

export interface DestinationS3ConfigurationFormatDestinationS3UpdateOutputFormatCsvCommaSeparatedValues {
    compression?: outputs.DestinationS3ConfigurationFormatDestinationS3UpdateOutputFormatCsvCommaSeparatedValuesCompression;
    flattening: string;
    formatType: string;
}

export interface DestinationS3ConfigurationFormatDestinationS3UpdateOutputFormatCsvCommaSeparatedValuesCompression {
    destinationS3UpdateOutputFormatCsvCommaSeparatedValuesCompressionGzip?: outputs.DestinationS3ConfigurationFormatDestinationS3UpdateOutputFormatCsvCommaSeparatedValuesCompressionDestinationS3UpdateOutputFormatCsvCommaSeparatedValuesCompressionGzip;
    destinationS3UpdateOutputFormatCsvCommaSeparatedValuesCompressionNoCompression?: outputs.DestinationS3ConfigurationFormatDestinationS3UpdateOutputFormatCsvCommaSeparatedValuesCompressionDestinationS3UpdateOutputFormatCsvCommaSeparatedValuesCompressionNoCompression;
}

export interface DestinationS3ConfigurationFormatDestinationS3UpdateOutputFormatCsvCommaSeparatedValuesCompressionDestinationS3UpdateOutputFormatCsvCommaSeparatedValuesCompressionGzip {
    compressionType?: string;
}

export interface DestinationS3ConfigurationFormatDestinationS3UpdateOutputFormatCsvCommaSeparatedValuesCompressionDestinationS3UpdateOutputFormatCsvCommaSeparatedValuesCompressionNoCompression {
    compressionType?: string;
}

export interface DestinationS3ConfigurationFormatDestinationS3UpdateOutputFormatJsonLinesNewlineDelimitedJson {
    compression?: outputs.DestinationS3ConfigurationFormatDestinationS3UpdateOutputFormatJsonLinesNewlineDelimitedJsonCompression;
    flattening?: string;
    formatType: string;
}

export interface DestinationS3ConfigurationFormatDestinationS3UpdateOutputFormatJsonLinesNewlineDelimitedJsonCompression {
    destinationS3UpdateOutputFormatJsonLinesNewlineDelimitedJsonCompressionGzip?: outputs.DestinationS3ConfigurationFormatDestinationS3UpdateOutputFormatJsonLinesNewlineDelimitedJsonCompressionDestinationS3UpdateOutputFormatJsonLinesNewlineDelimitedJsonCompressionGzip;
    destinationS3UpdateOutputFormatJsonLinesNewlineDelimitedJsonCompressionNoCompression?: outputs.DestinationS3ConfigurationFormatDestinationS3UpdateOutputFormatJsonLinesNewlineDelimitedJsonCompressionDestinationS3UpdateOutputFormatJsonLinesNewlineDelimitedJsonCompressionNoCompression;
}

export interface DestinationS3ConfigurationFormatDestinationS3UpdateOutputFormatJsonLinesNewlineDelimitedJsonCompressionDestinationS3UpdateOutputFormatJsonLinesNewlineDelimitedJsonCompressionGzip {
    compressionType?: string;
}

export interface DestinationS3ConfigurationFormatDestinationS3UpdateOutputFormatJsonLinesNewlineDelimitedJsonCompressionDestinationS3UpdateOutputFormatJsonLinesNewlineDelimitedJsonCompressionNoCompression {
    compressionType?: string;
}

export interface DestinationS3ConfigurationFormatDestinationS3UpdateOutputFormatParquetColumnarStorage {
    blockSizeMb?: number;
    compressionCodec?: string;
    dictionaryEncoding?: boolean;
    dictionaryPageSizeKb?: number;
    formatType: string;
    maxPaddingSizeMb?: number;
    pageSizeKb?: number;
}

export interface DestinationS3GlueConfiguration {
    /**
     * The access key ID to access the S3 bucket. Airbyte requires Read and Write permissions to the given bucket. Read more \n\nhere\n\n.
     */
    accessKeyId?: string;
    /**
     * must be one of ["s3-glue"]
     */
    destinationType: string;
    /**
     * The pattern allows you to set the file-name format for the S3 staging file(s)
     */
    fileNamePattern?: string;
    /**
     * Format of the data output. See \n\nhere\n\n for more details
     */
    format: outputs.DestinationS3GlueConfigurationFormat;
    /**
     * Name of the glue database for creating the tables, leave blank if no integration
     */
    glueDatabase: string;
    /**
     * must be one of ["org.openx.data.jsonserde.JsonSerDe", "org.apache.hive.hcatalog.data.JsonSerDe"]
     * The library that your query engine will use for reading and writing data in your lake.
     */
    glueSerializationLibrary: string;
    /**
     * The name of the S3 bucket. Read more \n\nhere\n\n.
     */
    s3BucketName: string;
    /**
     * Directory under the S3 bucket where data will be written. Read more \n\nhere\n\n
     */
    s3BucketPath: string;
    /**
     * must be one of ["", "us-east-1", "us-east-2", "us-west-1", "us-west-2", "af-south-1", "ap-east-1", "ap-south-1", "ap-northeast-1", "ap-northeast-2", "ap-northeast-3", "ap-southeast-1", "ap-southeast-2", "ca-central-1", "cn-north-1", "cn-northwest-1", "eu-central-1", "eu-north-1", "eu-south-1", "eu-west-1", "eu-west-2", "eu-west-3", "sa-east-1", "me-south-1", "us-gov-east-1", "us-gov-west-1"]
     * The region of the S3 bucket. See \n\nhere\n\n for all region codes.
     */
    s3BucketRegion: string;
    /**
     * Your S3 endpoint url. Read more \n\nhere\n\n
     */
    s3Endpoint?: string;
    /**
     * Format string on how data will be organized inside the S3 bucket directory. Read more \n\nhere\n\n
     */
    s3PathFormat?: string;
    /**
     * The corresponding secret to the access key ID. Read more \n\nhere\n\n
     */
    secretAccessKey?: string;
}

export interface DestinationS3GlueConfigurationFormat {
    destinationS3GlueOutputFormatJsonLinesNewlineDelimitedJson?: outputs.DestinationS3GlueConfigurationFormatDestinationS3GlueOutputFormatJsonLinesNewlineDelimitedJson;
    destinationS3GlueUpdateOutputFormatJsonLinesNewlineDelimitedJson?: outputs.DestinationS3GlueConfigurationFormatDestinationS3GlueUpdateOutputFormatJsonLinesNewlineDelimitedJson;
}

export interface DestinationS3GlueConfigurationFormatDestinationS3GlueOutputFormatJsonLinesNewlineDelimitedJson {
    compression?: outputs.DestinationS3GlueConfigurationFormatDestinationS3GlueOutputFormatJsonLinesNewlineDelimitedJsonCompression;
    flattening?: string;
    formatType: string;
}

export interface DestinationS3GlueConfigurationFormatDestinationS3GlueOutputFormatJsonLinesNewlineDelimitedJsonCompression {
    destinationS3GlueOutputFormatJsonLinesNewlineDelimitedJsonCompressionGzip?: outputs.DestinationS3GlueConfigurationFormatDestinationS3GlueOutputFormatJsonLinesNewlineDelimitedJsonCompressionDestinationS3GlueOutputFormatJsonLinesNewlineDelimitedJsonCompressionGzip;
    destinationS3GlueOutputFormatJsonLinesNewlineDelimitedJsonCompressionNoCompression?: outputs.DestinationS3GlueConfigurationFormatDestinationS3GlueOutputFormatJsonLinesNewlineDelimitedJsonCompressionDestinationS3GlueOutputFormatJsonLinesNewlineDelimitedJsonCompressionNoCompression;
}

export interface DestinationS3GlueConfigurationFormatDestinationS3GlueOutputFormatJsonLinesNewlineDelimitedJsonCompressionDestinationS3GlueOutputFormatJsonLinesNewlineDelimitedJsonCompressionGzip {
    compressionType?: string;
}

export interface DestinationS3GlueConfigurationFormatDestinationS3GlueOutputFormatJsonLinesNewlineDelimitedJsonCompressionDestinationS3GlueOutputFormatJsonLinesNewlineDelimitedJsonCompressionNoCompression {
    compressionType?: string;
}

export interface DestinationS3GlueConfigurationFormatDestinationS3GlueUpdateOutputFormatJsonLinesNewlineDelimitedJson {
    compression?: outputs.DestinationS3GlueConfigurationFormatDestinationS3GlueUpdateOutputFormatJsonLinesNewlineDelimitedJsonCompression;
    flattening?: string;
    formatType: string;
}

export interface DestinationS3GlueConfigurationFormatDestinationS3GlueUpdateOutputFormatJsonLinesNewlineDelimitedJsonCompression {
    destinationS3GlueUpdateOutputFormatJsonLinesNewlineDelimitedJsonCompressionGzip?: outputs.DestinationS3GlueConfigurationFormatDestinationS3GlueUpdateOutputFormatJsonLinesNewlineDelimitedJsonCompressionDestinationS3GlueUpdateOutputFormatJsonLinesNewlineDelimitedJsonCompressionGzip;
    destinationS3GlueUpdateOutputFormatJsonLinesNewlineDelimitedJsonCompressionNoCompression?: outputs.DestinationS3GlueConfigurationFormatDestinationS3GlueUpdateOutputFormatJsonLinesNewlineDelimitedJsonCompressionDestinationS3GlueUpdateOutputFormatJsonLinesNewlineDelimitedJsonCompressionNoCompression;
}

export interface DestinationS3GlueConfigurationFormatDestinationS3GlueUpdateOutputFormatJsonLinesNewlineDelimitedJsonCompressionDestinationS3GlueUpdateOutputFormatJsonLinesNewlineDelimitedJsonCompressionGzip {
    compressionType?: string;
}

export interface DestinationS3GlueConfigurationFormatDestinationS3GlueUpdateOutputFormatJsonLinesNewlineDelimitedJsonCompressionDestinationS3GlueUpdateOutputFormatJsonLinesNewlineDelimitedJsonCompressionNoCompression {
    compressionType?: string;
}

export interface DestinationSftpJsonConfiguration {
    /**
     * Path to the directory where json files will be written.
     */
    destinationPath: string;
    /**
     * must be one of ["sftp-json"]
     */
    destinationType: string;
    /**
     * Hostname of the SFTP server.
     */
    host: string;
    /**
     * Password associated with the username.
     */
    password: string;
    /**
     * Port of the SFTP server.
     */
    port?: number;
    /**
     * Username to use to access the SFTP server.
     */
    username: string;
}

export interface DestinationSnowflakeConfiguration {
    credentials?: outputs.DestinationSnowflakeConfigurationCredentials;
    /**
     * Enter the name of the \n\ndatabase\n\n you want to sync data into
     */
    database: string;
    /**
     * must be one of ["snowflake"]
     */
    destinationType: string;
    /**
     * Enter your Snowflake account's \n\nlocator\n\n (in the format \n\n.\n\n.\n\n.snowflakecomputing.com)
     */
    host: string;
    /**
     * Enter the additional properties to pass to the JDBC URL string when connecting to the database (formatted as key=value pairs separated by the symbol &). Example: key1=value1&key2=value2&key3=value3
     */
    jdbcUrlParams?: string;
    /**
     * (Beta) The schema to write raw tables into
     */
    rawDataSchema?: string;
    /**
     * Enter the \n\nrole\n\n that you want to use to access Snowflake
     */
    role: string;
    /**
     * Enter the name of the default \n\nschema\n\n
     */
    schema: string;
    /**
     * (Beta) Use \n\nDestinations V2\n\n. Contact Airbyte Support to participate in the beta program.
     */
    use1s1tFormat?: boolean;
    /**
     * Enter the name of the user you want to use to access the database
     */
    username: string;
    /**
     * Enter the name of the \n\nwarehouse\n\n that you want to sync data into
     */
    warehouse: string;
}

export interface DestinationSnowflakeConfigurationCredentials {
    destinationSnowflakeAuthorizationMethodKeyPairAuthentication?: outputs.DestinationSnowflakeConfigurationCredentialsDestinationSnowflakeAuthorizationMethodKeyPairAuthentication;
    destinationSnowflakeAuthorizationMethodOAuth20?: outputs.DestinationSnowflakeConfigurationCredentialsDestinationSnowflakeAuthorizationMethodOAuth20;
    destinationSnowflakeAuthorizationMethodUsernameAndPassword?: outputs.DestinationSnowflakeConfigurationCredentialsDestinationSnowflakeAuthorizationMethodUsernameAndPassword;
    destinationSnowflakeUpdateAuthorizationMethodKeyPairAuthentication?: outputs.DestinationSnowflakeConfigurationCredentialsDestinationSnowflakeUpdateAuthorizationMethodKeyPairAuthentication;
    destinationSnowflakeUpdateAuthorizationMethodOAuth20?: outputs.DestinationSnowflakeConfigurationCredentialsDestinationSnowflakeUpdateAuthorizationMethodOAuth20;
    destinationSnowflakeUpdateAuthorizationMethodUsernameAndPassword?: outputs.DestinationSnowflakeConfigurationCredentialsDestinationSnowflakeUpdateAuthorizationMethodUsernameAndPassword;
}

export interface DestinationSnowflakeConfigurationCredentialsDestinationSnowflakeAuthorizationMethodKeyPairAuthentication {
    authType?: string;
    privateKey: string;
    privateKeyPassword?: string;
}

export interface DestinationSnowflakeConfigurationCredentialsDestinationSnowflakeAuthorizationMethodOAuth20 {
    accessToken: string;
    authType?: string;
    clientId?: string;
    clientSecret?: string;
    refreshToken: string;
}

export interface DestinationSnowflakeConfigurationCredentialsDestinationSnowflakeAuthorizationMethodUsernameAndPassword {
    authType?: string;
    password: string;
}

export interface DestinationSnowflakeConfigurationCredentialsDestinationSnowflakeUpdateAuthorizationMethodKeyPairAuthentication {
    authType?: string;
    privateKey: string;
    privateKeyPassword?: string;
}

export interface DestinationSnowflakeConfigurationCredentialsDestinationSnowflakeUpdateAuthorizationMethodOAuth20 {
    accessToken: string;
    authType?: string;
    clientId?: string;
    clientSecret?: string;
    refreshToken: string;
}

export interface DestinationSnowflakeConfigurationCredentialsDestinationSnowflakeUpdateAuthorizationMethodUsernameAndPassword {
    authType?: string;
    password: string;
}

export interface DestinationTimeplusConfiguration {
    /**
     * Personal API key
     */
    apikey: string;
    /**
     * must be one of ["timeplus"]
     */
    destinationType: string;
    /**
     * Timeplus workspace endpoint
     */
    endpoint: string;
}

export interface DestinationTypesenseConfiguration {
    /**
     * Typesense API Key
     */
    apiKey: string;
    /**
     * How many documents should be imported together. Default 1000
     */
    batchSize?: string;
    /**
     * must be one of ["typesense"]
     */
    destinationType: string;
    /**
     * Hostname of the Typesense instance without protocol.
     */
    host: string;
    /**
     * Port of the Typesense instance. Ex: 8108, 80, 443. Default is 443
     */
    port?: string;
    /**
     * Protocol of the Typesense instance. Ex: http or https. Default is https
     */
    protocol?: string;
}

export interface DestinationVerticaConfiguration {
    /**
     * Name of the database.
     */
    database: string;
    /**
     * must be one of ["vertica"]
     */
    destinationType: string;
    /**
     * Hostname of the database.
     */
    host: string;
    /**
     * Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
     */
    jdbcUrlParams?: string;
    /**
     * Password associated with the username.
     */
    password?: string;
    /**
     * Port of the database.
     */
    port: number;
    /**
     * Schema for vertica destination
     */
    schema: string;
    /**
     * Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
     */
    tunnelMethod?: outputs.DestinationVerticaConfigurationTunnelMethod;
    /**
     * Username to use to access the database.
     */
    username: string;
}

export interface DestinationVerticaConfigurationTunnelMethod {
    destinationVerticaSshTunnelMethodNoTunnel?: outputs.DestinationVerticaConfigurationTunnelMethodDestinationVerticaSshTunnelMethodNoTunnel;
    destinationVerticaSshTunnelMethodPasswordAuthentication?: outputs.DestinationVerticaConfigurationTunnelMethodDestinationVerticaSshTunnelMethodPasswordAuthentication;
    destinationVerticaSshTunnelMethodSshKeyAuthentication?: outputs.DestinationVerticaConfigurationTunnelMethodDestinationVerticaSshTunnelMethodSshKeyAuthentication;
    destinationVerticaUpdateSshTunnelMethodNoTunnel?: outputs.DestinationVerticaConfigurationTunnelMethodDestinationVerticaUpdateSshTunnelMethodNoTunnel;
    destinationVerticaUpdateSshTunnelMethodPasswordAuthentication?: outputs.DestinationVerticaConfigurationTunnelMethodDestinationVerticaUpdateSshTunnelMethodPasswordAuthentication;
    destinationVerticaUpdateSshTunnelMethodSshKeyAuthentication?: outputs.DestinationVerticaConfigurationTunnelMethodDestinationVerticaUpdateSshTunnelMethodSshKeyAuthentication;
}

export interface DestinationVerticaConfigurationTunnelMethodDestinationVerticaSshTunnelMethodNoTunnel {
    tunnelMethod: string;
}

export interface DestinationVerticaConfigurationTunnelMethodDestinationVerticaSshTunnelMethodPasswordAuthentication {
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
    tunnelUserPassword: string;
}

export interface DestinationVerticaConfigurationTunnelMethodDestinationVerticaSshTunnelMethodSshKeyAuthentication {
    sshKey: string;
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
}

export interface DestinationVerticaConfigurationTunnelMethodDestinationVerticaUpdateSshTunnelMethodNoTunnel {
    tunnelMethod: string;
}

export interface DestinationVerticaConfigurationTunnelMethodDestinationVerticaUpdateSshTunnelMethodPasswordAuthentication {
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
    tunnelUserPassword: string;
}

export interface DestinationVerticaConfigurationTunnelMethodDestinationVerticaUpdateSshTunnelMethodSshKeyAuthentication {
    sshKey: string;
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
}

export interface DestinationXataConfiguration {
    /**
     * API Key to connect.
     */
    apiKey: string;
    /**
     * URL pointing to your workspace.
     */
    dbUrl: string;
    /**
     * must be one of ["xata"]
     */
    destinationType: string;
}

export interface GetConnectionConfigurations {
    streams: outputs.GetConnectionConfigurationsStream[];
}

export interface GetConnectionConfigurationsStream {
    cursorFields: string[];
    /**
     * Optional name of the connection
     */
    name: string;
    primaryKeys: string[][];
    syncMode: string;
}

export interface GetConnectionSchedule {
    basicTiming: string;
    cronExpression: string;
    /**
     * must be one of ["manual", "cron"]
     */
    scheduleType: string;
}

export interface GetDestinationAWSDatalakeConfiguration {
    /**
     * target aws account id
     */
    awsAccountId: string;
    /**
     * The name of the S3 bucket. Read more \n\nhere\n\n.
     */
    bucketName: string;
    /**
     * S3 prefix
     */
    bucketPrefix: string;
    /**
     * Choose How to Authenticate to AWS.
     */
    credentials: outputs.GetDestinationAWSDatalakeConfigurationCredentials;
    /**
     * must be one of ["aws-datalake"]
     */
    destinationType: string;
    /**
     * Format of the data output.
     */
    format: outputs.GetDestinationAWSDatalakeConfigurationFormat;
    /**
     * Cast float/double as decimal(38,18). This can help achieve higher accuracy and represent numbers correctly as received from the source.
     */
    glueCatalogFloatAsDecimal: boolean;
    /**
     * Add a default tag key to databases created by this destination
     */
    lakeformationDatabaseDefaultTagKey: string;
    /**
     * Add default values for the `Tag Key` to databases created by this destination. Comma separate for multiple values.
     */
    lakeformationDatabaseDefaultTagValues: string;
    /**
     * The default database this destination will use to create tables in per stream. Can be changed per connection by customizing the namespace.
     */
    lakeformationDatabaseName: string;
    /**
     * Whether to create tables as LF governed tables.
     */
    lakeformationGovernedTables: boolean;
    /**
     * must be one of ["NO PARTITIONING", "DATE", "YEAR", "MONTH", "DAY", "YEAR/MONTH", "YEAR/MONTH/DAY"]
     * Partition data by cursor fields when a cursor field is a date
     */
    partitioning: string;
    /**
     * must be one of ["", "us-east-1", "us-east-2", "us-west-1", "us-west-2", "af-south-1", "ap-east-1", "ap-south-1", "ap-northeast-1", "ap-northeast-2", "ap-northeast-3", "ap-southeast-1", "ap-southeast-2", "ca-central-1", "cn-north-1", "cn-northwest-1", "eu-central-1", "eu-north-1", "eu-south-1", "eu-west-1", "eu-west-2", "eu-west-3", "sa-east-1", "me-south-1", "us-gov-east-1", "us-gov-west-1"]
     * The region of the S3 bucket. See \n\nhere\n\n for all region codes.
     */
    region: string;
}

export interface GetDestinationAWSDatalakeConfigurationCredentials {
    destinationAwsDatalakeAuthenticationModeIamRole: outputs.GetDestinationAWSDatalakeConfigurationCredentialsDestinationAwsDatalakeAuthenticationModeIamRole;
    destinationAwsDatalakeAuthenticationModeIamUser: outputs.GetDestinationAWSDatalakeConfigurationCredentialsDestinationAwsDatalakeAuthenticationModeIamUser;
    destinationAwsDatalakeUpdateAuthenticationModeIamRole: outputs.GetDestinationAWSDatalakeConfigurationCredentialsDestinationAwsDatalakeUpdateAuthenticationModeIamRole;
    destinationAwsDatalakeUpdateAuthenticationModeIamUser: outputs.GetDestinationAWSDatalakeConfigurationCredentialsDestinationAwsDatalakeUpdateAuthenticationModeIamUser;
}

export interface GetDestinationAWSDatalakeConfigurationCredentialsDestinationAwsDatalakeAuthenticationModeIamRole {
    credentialsTitle: string;
    roleArn: string;
}

export interface GetDestinationAWSDatalakeConfigurationCredentialsDestinationAwsDatalakeAuthenticationModeIamUser {
    awsAccessKeyId: string;
    awsSecretAccessKey: string;
    credentialsTitle: string;
}

export interface GetDestinationAWSDatalakeConfigurationCredentialsDestinationAwsDatalakeUpdateAuthenticationModeIamRole {
    credentialsTitle: string;
    roleArn: string;
}

export interface GetDestinationAWSDatalakeConfigurationCredentialsDestinationAwsDatalakeUpdateAuthenticationModeIamUser {
    awsAccessKeyId: string;
    awsSecretAccessKey: string;
    credentialsTitle: string;
}

export interface GetDestinationAWSDatalakeConfigurationFormat {
    destinationAwsDatalakeOutputFormatWildcardJsonLinesNewlineDelimitedJson: outputs.GetDestinationAWSDatalakeConfigurationFormatDestinationAwsDatalakeOutputFormatWildcardJsonLinesNewlineDelimitedJson;
    destinationAwsDatalakeOutputFormatWildcardParquetColumnarStorage: outputs.GetDestinationAWSDatalakeConfigurationFormatDestinationAwsDatalakeOutputFormatWildcardParquetColumnarStorage;
    destinationAwsDatalakeUpdateOutputFormatWildcardJsonLinesNewlineDelimitedJson: outputs.GetDestinationAWSDatalakeConfigurationFormatDestinationAwsDatalakeUpdateOutputFormatWildcardJsonLinesNewlineDelimitedJson;
    destinationAwsDatalakeUpdateOutputFormatWildcardParquetColumnarStorage: outputs.GetDestinationAWSDatalakeConfigurationFormatDestinationAwsDatalakeUpdateOutputFormatWildcardParquetColumnarStorage;
}

export interface GetDestinationAWSDatalakeConfigurationFormatDestinationAwsDatalakeOutputFormatWildcardJsonLinesNewlineDelimitedJson {
    compressionCodec: string;
    formatType: string;
}

export interface GetDestinationAWSDatalakeConfigurationFormatDestinationAwsDatalakeOutputFormatWildcardParquetColumnarStorage {
    compressionCodec: string;
    formatType: string;
}

export interface GetDestinationAWSDatalakeConfigurationFormatDestinationAwsDatalakeUpdateOutputFormatWildcardJsonLinesNewlineDelimitedJson {
    compressionCodec: string;
    formatType: string;
}

export interface GetDestinationAWSDatalakeConfigurationFormatDestinationAwsDatalakeUpdateOutputFormatWildcardParquetColumnarStorage {
    compressionCodec: string;
    formatType: string;
}

export interface GetDestinationAzureBlobStorageConfiguration {
    /**
     * The Azure blob storage account key.
     */
    azureBlobStorageAccountKey: string;
    /**
     * The account's name of the Azure Blob Storage.
     */
    azureBlobStorageAccountName: string;
    /**
     * The name of the Azure blob storage container. If not exists - will be created automatically. May be empty, then will be created automatically airbytecontainer+timestamp
     */
    azureBlobStorageContainerName: string;
    /**
     * This is Azure Blob Storage endpoint domain name. Leave default value (or leave it empty if run container from command line) to use Microsoft native from example.
     */
    azureBlobStorageEndpointDomainName: string;
    /**
     * The amount of megabytes to buffer for the output stream to Azure. This will impact memory footprint on workers, but may need adjustment for performance and appropriate block size in Azure.
     */
    azureBlobStorageOutputBufferSize: number;
    /**
     * The amount of megabytes after which the connector should spill the records in a new blob object. Make sure to configure size greater than individual records. Enter 0 if not applicable
     */
    azureBlobStorageSpillSize: number;
    /**
     * must be one of ["azure-blob-storage"]
     */
    destinationType: string;
    /**
     * Output data format
     */
    format: outputs.GetDestinationAzureBlobStorageConfigurationFormat;
}

export interface GetDestinationAzureBlobStorageConfigurationFormat {
    destinationAzureBlobStorageOutputFormatCsvCommaSeparatedValues: outputs.GetDestinationAzureBlobStorageConfigurationFormatDestinationAzureBlobStorageOutputFormatCsvCommaSeparatedValues;
    destinationAzureBlobStorageOutputFormatJsonLinesNewlineDelimitedJson: outputs.GetDestinationAzureBlobStorageConfigurationFormatDestinationAzureBlobStorageOutputFormatJsonLinesNewlineDelimitedJson;
    destinationAzureBlobStorageUpdateOutputFormatCsvCommaSeparatedValues: outputs.GetDestinationAzureBlobStorageConfigurationFormatDestinationAzureBlobStorageUpdateOutputFormatCsvCommaSeparatedValues;
    destinationAzureBlobStorageUpdateOutputFormatJsonLinesNewlineDelimitedJson: outputs.GetDestinationAzureBlobStorageConfigurationFormatDestinationAzureBlobStorageUpdateOutputFormatJsonLinesNewlineDelimitedJson;
}

export interface GetDestinationAzureBlobStorageConfigurationFormatDestinationAzureBlobStorageOutputFormatCsvCommaSeparatedValues {
    flattening: string;
    formatType: string;
}

export interface GetDestinationAzureBlobStorageConfigurationFormatDestinationAzureBlobStorageOutputFormatJsonLinesNewlineDelimitedJson {
    formatType: string;
}

export interface GetDestinationAzureBlobStorageConfigurationFormatDestinationAzureBlobStorageUpdateOutputFormatCsvCommaSeparatedValues {
    flattening: string;
    formatType: string;
}

export interface GetDestinationAzureBlobStorageConfigurationFormatDestinationAzureBlobStorageUpdateOutputFormatJsonLinesNewlineDelimitedJson {
    formatType: string;
}

export interface GetDestinationBigqueryConfiguration {
    /**
     * Google BigQuery client's chunk (buffer) size (MIN=1, MAX = 15) for each table. The size that will be written by a single RPC. Written data will be buffered and only flushed upon reaching this size or closing the channel. The default 15MB value is used if not set explicitly. Read more \n\nhere\n\n.
     */
    bigQueryClientBufferSizeMb: number;
    /**
     * The contents of the JSON service account key. Check out the \n\ndocs\n\n if you need help generating this key. Default credentials will be used if this field is left empty.
     */
    credentialsJson: string;
    /**
     * The default BigQuery Dataset ID that tables are replicated to if the source does not specify a namespace. Read more \n\nhere\n\n.
     */
    datasetId: string;
    /**
     * must be one of ["US", "EU", "asia-east1", "asia-east2", "asia-northeast1", "asia-northeast2", "asia-northeast3", "asia-south1", "asia-south2", "asia-southeast1", "asia-southeast2", "australia-southeast1", "australia-southeast2", "europe-central1", "europe-central2", "europe-north1", "europe-southwest1", "europe-west1", "europe-west2", "europe-west3", "europe-west4", "europe-west6", "europe-west7", "europe-west8", "europe-west9", "me-west1", "northamerica-northeast1", "northamerica-northeast2", "southamerica-east1", "southamerica-west1", "us-central1", "us-east1", "us-east2", "us-east3", "us-east4", "us-east5", "us-west1", "us-west2", "us-west3", "us-west4"]
     * The location of the dataset. Warning: Changes made after creation will not be applied. Read more \n\nhere\n\n.
     */
    datasetLocation: string;
    /**
     * must be one of ["bigquery"]
     */
    destinationType: string;
    /**
     * Loading method used to send select the way data will be uploaded to BigQuery. \n\n\n\nStandard Inserts\n\n - Direct uploading using SQL INSERT statements. This method is extremely inefficient and provided only for quick testing. In almost all cases, you should use staging. \n\n\n\nGCS Staging\n\n - Writes large batches of records to a file, uploads the file to GCS, then uses \n\nCOPY INTO table\n\n to upload the file. Recommended for most workloads for better speed and scalability. Read more about GCS Staging \n\nhere\n\n.
     */
    loadingMethod: outputs.GetDestinationBigqueryConfigurationLoadingMethod;
    /**
     * The GCP project ID for the project containing the target BigQuery dataset. Read more \n\nhere\n\n.
     */
    projectId: string;
    /**
     * (Early Access) The dataset to write raw tables into
     */
    rawDataDataset: string;
    /**
     * must be one of ["interactive", "batch"]
     * Interactive run type means that the query is executed as soon as possible, and these queries count towards concurrent rate limit and daily limit. Read more about interactive run type \n\nhere\n\n. Batch queries are queued and started as soon as idle resources are available in the BigQuery shared resource pool, which usually occurs within a few minutes. Batch queries donâ€™t count towards your concurrent rate limit. Read more about batch queries \n\nhere\n\n. The default "interactive" value is used if not set explicitly.
     */
    transformationPriority: string;
    /**
     * (Early Access) Use \n\nDestinations V2\n\n.
     */
    use1s1tFormat: boolean;
}

export interface GetDestinationBigqueryConfigurationLoadingMethod {
    destinationBigqueryLoadingMethodGcsStaging: outputs.GetDestinationBigqueryConfigurationLoadingMethodDestinationBigqueryLoadingMethodGcsStaging;
    destinationBigqueryLoadingMethodStandardInserts: outputs.GetDestinationBigqueryConfigurationLoadingMethodDestinationBigqueryLoadingMethodStandardInserts;
    destinationBigqueryUpdateLoadingMethodGcsStaging: outputs.GetDestinationBigqueryConfigurationLoadingMethodDestinationBigqueryUpdateLoadingMethodGcsStaging;
    destinationBigqueryUpdateLoadingMethodStandardInserts: outputs.GetDestinationBigqueryConfigurationLoadingMethodDestinationBigqueryUpdateLoadingMethodStandardInserts;
}

export interface GetDestinationBigqueryConfigurationLoadingMethodDestinationBigqueryLoadingMethodGcsStaging {
    credential: outputs.GetDestinationBigqueryConfigurationLoadingMethodDestinationBigqueryLoadingMethodGcsStagingCredential;
    fileBufferCount: number;
    gcsBucketName: string;
    gcsBucketPath: string;
    keepFilesInGcsBucket: string;
    method: string;
}

export interface GetDestinationBigqueryConfigurationLoadingMethodDestinationBigqueryLoadingMethodGcsStagingCredential {
    destinationBigqueryLoadingMethodGcsStagingCredentialHmacKey: outputs.GetDestinationBigqueryConfigurationLoadingMethodDestinationBigqueryLoadingMethodGcsStagingCredentialDestinationBigqueryLoadingMethodGcsStagingCredentialHmacKey;
}

export interface GetDestinationBigqueryConfigurationLoadingMethodDestinationBigqueryLoadingMethodGcsStagingCredentialDestinationBigqueryLoadingMethodGcsStagingCredentialHmacKey {
    credentialType: string;
    hmacKeyAccessId: string;
    hmacKeySecret: string;
}

export interface GetDestinationBigqueryConfigurationLoadingMethodDestinationBigqueryLoadingMethodStandardInserts {
    method: string;
}

export interface GetDestinationBigqueryConfigurationLoadingMethodDestinationBigqueryUpdateLoadingMethodGcsStaging {
    credential: outputs.GetDestinationBigqueryConfigurationLoadingMethodDestinationBigqueryUpdateLoadingMethodGcsStagingCredential;
    fileBufferCount: number;
    gcsBucketName: string;
    gcsBucketPath: string;
    keepFilesInGcsBucket: string;
    method: string;
}

export interface GetDestinationBigqueryConfigurationLoadingMethodDestinationBigqueryUpdateLoadingMethodGcsStagingCredential {
    destinationBigqueryUpdateLoadingMethodGcsStagingCredentialHmacKey: outputs.GetDestinationBigqueryConfigurationLoadingMethodDestinationBigqueryUpdateLoadingMethodGcsStagingCredentialDestinationBigqueryUpdateLoadingMethodGcsStagingCredentialHmacKey;
}

export interface GetDestinationBigqueryConfigurationLoadingMethodDestinationBigqueryUpdateLoadingMethodGcsStagingCredentialDestinationBigqueryUpdateLoadingMethodGcsStagingCredentialHmacKey {
    credentialType: string;
    hmacKeyAccessId: string;
    hmacKeySecret: string;
}

export interface GetDestinationBigqueryConfigurationLoadingMethodDestinationBigqueryUpdateLoadingMethodStandardInserts {
    method: string;
}

export interface GetDestinationBigqueryDenormalizedConfiguration {
    /**
     * Google BigQuery client's chunk (buffer) size (MIN=1, MAX = 15) for each table. The size that will be written by a single RPC. Written data will be buffered and only flushed upon reaching this size or closing the channel. The default 15MB value is used if not set explicitly. Read more \n\nhere\n\n.
     */
    bigQueryClientBufferSizeMb: number;
    /**
     * The contents of the JSON service account key. Check out the \n\ndocs\n\n if you need help generating this key. Default credentials will be used if this field is left empty.
     */
    credentialsJson: string;
    /**
     * The default BigQuery Dataset ID that tables are replicated to if the source does not specify a namespace. Read more \n\nhere\n\n.
     */
    datasetId: string;
    /**
     * must be one of ["US", "EU", "asia-east1", "asia-east2", "asia-northeast1", "asia-northeast2", "asia-northeast3", "asia-south1", "asia-south2", "asia-southeast1", "asia-southeast2", "australia-southeast1", "australia-southeast2", "europe-central1", "europe-central2", "europe-north1", "europe-southwest1", "europe-west1", "europe-west2", "europe-west3", "europe-west4", "europe-west6", "europe-west7", "europe-west8", "europe-west9", "me-west1", "northamerica-northeast1", "northamerica-northeast2", "southamerica-east1", "southamerica-west1", "us-central1", "us-east1", "us-east2", "us-east3", "us-east4", "us-east5", "us-west1", "us-west2", "us-west3", "us-west4"]
     * The location of the dataset. Warning: Changes made after creation will not be applied. The default "US" value is used if not set explicitly. Read more \n\nhere\n\n.
     */
    datasetLocation: string;
    /**
     * must be one of ["bigquery-denormalized"]
     */
    destinationType: string;
    /**
     * Loading method used to send select the way data will be uploaded to BigQuery. \n\n\n\nStandard Inserts\n\n - Direct uploading using SQL INSERT statements. This method is extremely inefficient and provided only for quick testing. In almost all cases, you should use staging. \n\n\n\nGCS Staging\n\n - Writes large batches of records to a file, uploads the file to GCS, then uses \n\nCOPY INTO table\n\n to upload the file. Recommended for most workloads for better speed and scalability. Read more about GCS Staging \n\nhere\n\n.
     */
    loadingMethod: outputs.GetDestinationBigqueryDenormalizedConfigurationLoadingMethod;
    /**
     * The GCP project ID for the project containing the target BigQuery dataset. Read more \n\nhere\n\n.
     */
    projectId: string;
}

export interface GetDestinationBigqueryDenormalizedConfigurationLoadingMethod {
    destinationBigqueryDenormalizedLoadingMethodGcsStaging: outputs.GetDestinationBigqueryDenormalizedConfigurationLoadingMethodDestinationBigqueryDenormalizedLoadingMethodGcsStaging;
    destinationBigqueryDenormalizedLoadingMethodStandardInserts: outputs.GetDestinationBigqueryDenormalizedConfigurationLoadingMethodDestinationBigqueryDenormalizedLoadingMethodStandardInserts;
    destinationBigqueryDenormalizedUpdateLoadingMethodGcsStaging: outputs.GetDestinationBigqueryDenormalizedConfigurationLoadingMethodDestinationBigqueryDenormalizedUpdateLoadingMethodGcsStaging;
    destinationBigqueryDenormalizedUpdateLoadingMethodStandardInserts: outputs.GetDestinationBigqueryDenormalizedConfigurationLoadingMethodDestinationBigqueryDenormalizedUpdateLoadingMethodStandardInserts;
}

export interface GetDestinationBigqueryDenormalizedConfigurationLoadingMethodDestinationBigqueryDenormalizedLoadingMethodGcsStaging {
    credential: outputs.GetDestinationBigqueryDenormalizedConfigurationLoadingMethodDestinationBigqueryDenormalizedLoadingMethodGcsStagingCredential;
    fileBufferCount: number;
    gcsBucketName: string;
    gcsBucketPath: string;
    keepFilesInGcsBucket: string;
    method: string;
}

export interface GetDestinationBigqueryDenormalizedConfigurationLoadingMethodDestinationBigqueryDenormalizedLoadingMethodGcsStagingCredential {
    destinationBigqueryDenormalizedLoadingMethodGcsStagingCredentialHmacKey: outputs.GetDestinationBigqueryDenormalizedConfigurationLoadingMethodDestinationBigqueryDenormalizedLoadingMethodGcsStagingCredentialDestinationBigqueryDenormalizedLoadingMethodGcsStagingCredentialHmacKey;
}

export interface GetDestinationBigqueryDenormalizedConfigurationLoadingMethodDestinationBigqueryDenormalizedLoadingMethodGcsStagingCredentialDestinationBigqueryDenormalizedLoadingMethodGcsStagingCredentialHmacKey {
    credentialType: string;
    hmacKeyAccessId: string;
    hmacKeySecret: string;
}

export interface GetDestinationBigqueryDenormalizedConfigurationLoadingMethodDestinationBigqueryDenormalizedLoadingMethodStandardInserts {
    method: string;
}

export interface GetDestinationBigqueryDenormalizedConfigurationLoadingMethodDestinationBigqueryDenormalizedUpdateLoadingMethodGcsStaging {
    credential: outputs.GetDestinationBigqueryDenormalizedConfigurationLoadingMethodDestinationBigqueryDenormalizedUpdateLoadingMethodGcsStagingCredential;
    fileBufferCount: number;
    gcsBucketName: string;
    gcsBucketPath: string;
    keepFilesInGcsBucket: string;
    method: string;
}

export interface GetDestinationBigqueryDenormalizedConfigurationLoadingMethodDestinationBigqueryDenormalizedUpdateLoadingMethodGcsStagingCredential {
    destinationBigqueryDenormalizedUpdateLoadingMethodGcsStagingCredentialHmacKey: outputs.GetDestinationBigqueryDenormalizedConfigurationLoadingMethodDestinationBigqueryDenormalizedUpdateLoadingMethodGcsStagingCredentialDestinationBigqueryDenormalizedUpdateLoadingMethodGcsStagingCredentialHmacKey;
}

export interface GetDestinationBigqueryDenormalizedConfigurationLoadingMethodDestinationBigqueryDenormalizedUpdateLoadingMethodGcsStagingCredentialDestinationBigqueryDenormalizedUpdateLoadingMethodGcsStagingCredentialHmacKey {
    credentialType: string;
    hmacKeyAccessId: string;
    hmacKeySecret: string;
}

export interface GetDestinationBigqueryDenormalizedConfigurationLoadingMethodDestinationBigqueryDenormalizedUpdateLoadingMethodStandardInserts {
    method: string;
}

export interface GetDestinationClickhouseConfiguration {
    /**
     * Name of the database.
     */
    database: string;
    /**
     * must be one of ["clickhouse"]
     */
    destinationType: string;
    /**
     * Hostname of the database.
     */
    host: string;
    /**
     * Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
     */
    jdbcUrlParams: string;
    /**
     * Password associated with the username.
     */
    password: string;
    /**
     * HTTP port of the database.
     */
    port: number;
    /**
     * Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
     */
    tunnelMethod: outputs.GetDestinationClickhouseConfigurationTunnelMethod;
    /**
     * Username to use to access the database.
     */
    username: string;
}

export interface GetDestinationClickhouseConfigurationTunnelMethod {
    destinationClickhouseSshTunnelMethodNoTunnel: outputs.GetDestinationClickhouseConfigurationTunnelMethodDestinationClickhouseSshTunnelMethodNoTunnel;
    destinationClickhouseSshTunnelMethodPasswordAuthentication: outputs.GetDestinationClickhouseConfigurationTunnelMethodDestinationClickhouseSshTunnelMethodPasswordAuthentication;
    destinationClickhouseSshTunnelMethodSshKeyAuthentication: outputs.GetDestinationClickhouseConfigurationTunnelMethodDestinationClickhouseSshTunnelMethodSshKeyAuthentication;
    destinationClickhouseUpdateSshTunnelMethodNoTunnel: outputs.GetDestinationClickhouseConfigurationTunnelMethodDestinationClickhouseUpdateSshTunnelMethodNoTunnel;
    destinationClickhouseUpdateSshTunnelMethodPasswordAuthentication: outputs.GetDestinationClickhouseConfigurationTunnelMethodDestinationClickhouseUpdateSshTunnelMethodPasswordAuthentication;
    destinationClickhouseUpdateSshTunnelMethodSshKeyAuthentication: outputs.GetDestinationClickhouseConfigurationTunnelMethodDestinationClickhouseUpdateSshTunnelMethodSshKeyAuthentication;
}

export interface GetDestinationClickhouseConfigurationTunnelMethodDestinationClickhouseSshTunnelMethodNoTunnel {
    tunnelMethod: string;
}

export interface GetDestinationClickhouseConfigurationTunnelMethodDestinationClickhouseSshTunnelMethodPasswordAuthentication {
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
    tunnelUserPassword: string;
}

export interface GetDestinationClickhouseConfigurationTunnelMethodDestinationClickhouseSshTunnelMethodSshKeyAuthentication {
    sshKey: string;
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
}

export interface GetDestinationClickhouseConfigurationTunnelMethodDestinationClickhouseUpdateSshTunnelMethodNoTunnel {
    tunnelMethod: string;
}

export interface GetDestinationClickhouseConfigurationTunnelMethodDestinationClickhouseUpdateSshTunnelMethodPasswordAuthentication {
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
    tunnelUserPassword: string;
}

export interface GetDestinationClickhouseConfigurationTunnelMethodDestinationClickhouseUpdateSshTunnelMethodSshKeyAuthentication {
    sshKey: string;
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
}

export interface GetDestinationConvexConfiguration {
    /**
     * API access key used to send data to a Convex deployment.
     */
    accessKey: string;
    /**
     * URL of the Convex deployment that is the destination
     */
    deploymentUrl: string;
    /**
     * must be one of ["convex"]
     */
    destinationType: string;
}

export interface GetDestinationCumulioConfiguration {
    /**
     * URL of the Cumul.io API (e.g. 'https://api.cumul.io', 'https://api.us.cumul.io', or VPC-specific API url). Defaults to 'https://api.cumul.io'.
     */
    apiHost: string;
    /**
     * An API key generated in Cumul.io's platform (can be generated here: https://app.cumul.io/start/profile/integration).
     */
    apiKey: string;
    /**
     * The corresponding API token generated in Cumul.io's platform (can be generated here: https://app.cumul.io/start/profile/integration).
     */
    apiToken: string;
    /**
     * must be one of ["cumulio"]
     */
    destinationType: string;
}

export interface GetDestinationDatabendConfiguration {
    /**
     * Name of the database.
     */
    database: string;
    /**
     * must be one of ["databend"]
     */
    destinationType: string;
    /**
     * Hostname of the database.
     */
    host: string;
    /**
     * Password associated with the username.
     */
    password: string;
    /**
     * Port of the database.
     */
    port: number;
    /**
     * The default  table was written to.
     */
    table: string;
    /**
     * Username to use to access the database.
     */
    username: string;
}

export interface GetDestinationDatabricksConfiguration {
    /**
     * You must agree to the Databricks JDBC Driver \n\nTerms & Conditions\n\n to use this connector.
     */
    acceptTerms: boolean;
    /**
     * Storage on which the delta lake is built.
     */
    dataSource: outputs.GetDestinationDatabricksConfigurationDataSource;
    /**
     * The name of the catalog. If not specified otherwise, the "hiveMetastore" will be used.
     */
    database: string;
    /**
     * Databricks Cluster HTTP Path.
     */
    databricksHttpPath: string;
    /**
     * Databricks Personal Access Token for making authenticated requests.
     */
    databricksPersonalAccessToken: string;
    /**
     * Databricks Cluster Port.
     */
    databricksPort: string;
    /**
     * Databricks Cluster Server Hostname.
     */
    databricksServerHostname: string;
    /**
     * must be one of ["databricks"]
     */
    destinationType: string;
    /**
     * Support schema evolution for all streams. If "false", the connector might fail when a stream's schema changes.
     */
    enableSchemaEvolution: boolean;
    /**
     * Default to 'true'. Switch it to 'false' for debugging purpose.
     */
    purgeStagingData: boolean;
    /**
     * The default schema tables are written. If not specified otherwise, the "default" will be used.
     */
    schema: string;
}

export interface GetDestinationDatabricksConfigurationDataSource {
    destinationDatabricksDataSourceAmazonS3: outputs.GetDestinationDatabricksConfigurationDataSourceDestinationDatabricksDataSourceAmazonS3;
    destinationDatabricksDataSourceAzureBlobStorage: outputs.GetDestinationDatabricksConfigurationDataSourceDestinationDatabricksDataSourceAzureBlobStorage;
    destinationDatabricksDataSourceRecommendedManagedTables: outputs.GetDestinationDatabricksConfigurationDataSourceDestinationDatabricksDataSourceRecommendedManagedTables;
    destinationDatabricksUpdateDataSourceAmazonS3: outputs.GetDestinationDatabricksConfigurationDataSourceDestinationDatabricksUpdateDataSourceAmazonS3;
    destinationDatabricksUpdateDataSourceAzureBlobStorage: outputs.GetDestinationDatabricksConfigurationDataSourceDestinationDatabricksUpdateDataSourceAzureBlobStorage;
    destinationDatabricksUpdateDataSourceRecommendedManagedTables: outputs.GetDestinationDatabricksConfigurationDataSourceDestinationDatabricksUpdateDataSourceRecommendedManagedTables;
}

export interface GetDestinationDatabricksConfigurationDataSourceDestinationDatabricksDataSourceAmazonS3 {
    dataSourceType: string;
    fileNamePattern: string;
    s3AccessKeyId: string;
    s3BucketName: string;
    s3BucketPath: string;
    s3BucketRegion: string;
    s3SecretAccessKey: string;
}

export interface GetDestinationDatabricksConfigurationDataSourceDestinationDatabricksDataSourceAzureBlobStorage {
    azureBlobStorageAccountName: string;
    azureBlobStorageContainerName: string;
    azureBlobStorageEndpointDomainName: string;
    azureBlobStorageSasToken: string;
    dataSourceType: string;
}

export interface GetDestinationDatabricksConfigurationDataSourceDestinationDatabricksDataSourceRecommendedManagedTables {
    dataSourceType: string;
}

export interface GetDestinationDatabricksConfigurationDataSourceDestinationDatabricksUpdateDataSourceAmazonS3 {
    dataSourceType: string;
    fileNamePattern: string;
    s3AccessKeyId: string;
    s3BucketName: string;
    s3BucketPath: string;
    s3BucketRegion: string;
    s3SecretAccessKey: string;
}

export interface GetDestinationDatabricksConfigurationDataSourceDestinationDatabricksUpdateDataSourceAzureBlobStorage {
    azureBlobStorageAccountName: string;
    azureBlobStorageContainerName: string;
    azureBlobStorageEndpointDomainName: string;
    azureBlobStorageSasToken: string;
    dataSourceType: string;
}

export interface GetDestinationDatabricksConfigurationDataSourceDestinationDatabricksUpdateDataSourceRecommendedManagedTables {
    dataSourceType: string;
}

export interface GetDestinationDevNullConfiguration {
    /**
     * must be one of ["dev-null"]
     */
    destinationType: string;
    /**
     * The type of destination to be used
     */
    testDestination: outputs.GetDestinationDevNullConfigurationTestDestination;
}

export interface GetDestinationDevNullConfigurationTestDestination {
    destinationDevNullTestDestinationSilent: outputs.GetDestinationDevNullConfigurationTestDestinationDestinationDevNullTestDestinationSilent;
    destinationDevNullUpdateTestDestinationSilent: outputs.GetDestinationDevNullConfigurationTestDestinationDestinationDevNullUpdateTestDestinationSilent;
}

export interface GetDestinationDevNullConfigurationTestDestinationDestinationDevNullTestDestinationSilent {
    testDestinationType: string;
}

export interface GetDestinationDevNullConfigurationTestDestinationDestinationDevNullUpdateTestDestinationSilent {
    testDestinationType: string;
}

export interface GetDestinationDynamodbConfiguration {
    /**
     * The access key id to access the DynamoDB. Airbyte requires Read and Write permissions to the DynamoDB.
     */
    accessKeyId: string;
    /**
     * must be one of ["dynamodb"]
     */
    destinationType: string;
    /**
     * This is your DynamoDB endpoint url.(if you are working with AWS DynamoDB, just leave empty).
     */
    dynamodbEndpoint: string;
    /**
     * must be one of ["", "us-east-1", "us-east-2", "us-west-1", "us-west-2", "af-south-1", "ap-east-1", "ap-south-1", "ap-northeast-1", "ap-northeast-2", "ap-northeast-3", "ap-southeast-1", "ap-southeast-2", "ca-central-1", "cn-north-1", "cn-northwest-1", "eu-central-1", "eu-north-1", "eu-south-1", "eu-west-1", "eu-west-2", "eu-west-3", "sa-east-1", "me-south-1", "us-gov-east-1", "us-gov-west-1"]
     * The region of the DynamoDB.
     */
    dynamodbRegion: string;
    /**
     * The prefix to use when naming DynamoDB tables.
     */
    dynamodbTableNamePrefix: string;
    /**
     * The corresponding secret to the access key id.
     */
    secretAccessKey: string;
}

export interface GetDestinationElasticsearchConfiguration {
    /**
     * The type of authentication to be used
     */
    authenticationMethod: outputs.GetDestinationElasticsearchConfigurationAuthenticationMethod;
    /**
     * CA certificate
     */
    caCertificate: string;
    /**
     * must be one of ["elasticsearch"]
     */
    destinationType: string;
    /**
     * The full url of the Elasticsearch server
     */
    endpoint: string;
    /**
     * If a primary key identifier is defined in the source, an upsert will be performed using the primary key value as the elasticsearch doc id. Does not support composite primary keys.
     */
    upsert: boolean;
}

export interface GetDestinationElasticsearchConfigurationAuthenticationMethod {
    destinationElasticsearchAuthenticationMethodApiKeySecret: outputs.GetDestinationElasticsearchConfigurationAuthenticationMethodDestinationElasticsearchAuthenticationMethodApiKeySecret;
    destinationElasticsearchAuthenticationMethodUsernamePassword: outputs.GetDestinationElasticsearchConfigurationAuthenticationMethodDestinationElasticsearchAuthenticationMethodUsernamePassword;
    destinationElasticsearchUpdateAuthenticationMethodApiKeySecret: outputs.GetDestinationElasticsearchConfigurationAuthenticationMethodDestinationElasticsearchUpdateAuthenticationMethodApiKeySecret;
    destinationElasticsearchUpdateAuthenticationMethodUsernamePassword: outputs.GetDestinationElasticsearchConfigurationAuthenticationMethodDestinationElasticsearchUpdateAuthenticationMethodUsernamePassword;
}

export interface GetDestinationElasticsearchConfigurationAuthenticationMethodDestinationElasticsearchAuthenticationMethodApiKeySecret {
    apiKeyId: string;
    apiKeySecret: string;
    method: string;
}

export interface GetDestinationElasticsearchConfigurationAuthenticationMethodDestinationElasticsearchAuthenticationMethodUsernamePassword {
    method: string;
    password: string;
    username: string;
}

export interface GetDestinationElasticsearchConfigurationAuthenticationMethodDestinationElasticsearchUpdateAuthenticationMethodApiKeySecret {
    apiKeyId: string;
    apiKeySecret: string;
    method: string;
}

export interface GetDestinationElasticsearchConfigurationAuthenticationMethodDestinationElasticsearchUpdateAuthenticationMethodUsernamePassword {
    method: string;
    password: string;
    username: string;
}

export interface GetDestinationFireboltConfiguration {
    /**
     * Firebolt account to login.
     */
    account: string;
    /**
     * The database to connect to.
     */
    database: string;
    /**
     * must be one of ["firebolt"]
     */
    destinationType: string;
    /**
     * Engine name or url to connect to.
     */
    engine: string;
    /**
     * The host name of your Firebolt database.
     */
    host: string;
    /**
     * Loading method used to select the way data will be uploaded to Firebolt
     */
    loadingMethod: outputs.GetDestinationFireboltConfigurationLoadingMethod;
    /**
     * Firebolt password.
     */
    password: string;
    /**
     * Firebolt email address you use to login.
     */
    username: string;
}

export interface GetDestinationFireboltConfigurationLoadingMethod {
    destinationFireboltLoadingMethodExternalTableViaS3: outputs.GetDestinationFireboltConfigurationLoadingMethodDestinationFireboltLoadingMethodExternalTableViaS3;
    destinationFireboltLoadingMethodSqlInserts: outputs.GetDestinationFireboltConfigurationLoadingMethodDestinationFireboltLoadingMethodSqlInserts;
    destinationFireboltUpdateLoadingMethodExternalTableViaS3: outputs.GetDestinationFireboltConfigurationLoadingMethodDestinationFireboltUpdateLoadingMethodExternalTableViaS3;
    destinationFireboltUpdateLoadingMethodSqlInserts: outputs.GetDestinationFireboltConfigurationLoadingMethodDestinationFireboltUpdateLoadingMethodSqlInserts;
}

export interface GetDestinationFireboltConfigurationLoadingMethodDestinationFireboltLoadingMethodExternalTableViaS3 {
    awsKeyId: string;
    awsKeySecret: string;
    method: string;
    s3Bucket: string;
    s3Region: string;
}

export interface GetDestinationFireboltConfigurationLoadingMethodDestinationFireboltLoadingMethodSqlInserts {
    method: string;
}

export interface GetDestinationFireboltConfigurationLoadingMethodDestinationFireboltUpdateLoadingMethodExternalTableViaS3 {
    awsKeyId: string;
    awsKeySecret: string;
    method: string;
    s3Bucket: string;
    s3Region: string;
}

export interface GetDestinationFireboltConfigurationLoadingMethodDestinationFireboltUpdateLoadingMethodSqlInserts {
    method: string;
}

export interface GetDestinationFirestoreConfiguration {
    /**
     * The contents of the JSON service account key. Check out the \n\ndocs\n\n if you need help generating this key. Default credentials will be used if this field is left empty.
     */
    credentialsJson: string;
    /**
     * must be one of ["firestore"]
     */
    destinationType: string;
    /**
     * The GCP project ID for the project containing the target BigQuery dataset.
     */
    projectId: string;
}

export interface GetDestinationGcsConfiguration {
    /**
     * An HMAC key is a type of credential and can be associated with a service account or a user account in Cloud Storage. Read more \n\nhere\n\n.
     */
    credential: outputs.GetDestinationGcsConfigurationCredential;
    /**
     * must be one of ["gcs"]
     */
    destinationType: string;
    /**
     * Output data format. One of the following formats must be selected - \n\nAVRO\n\n format, \n\nPARQUET\n\n format, \n\nCSV\n\n format, or \n\nJSONL\n\n format.
     */
    format: outputs.GetDestinationGcsConfigurationFormat;
    /**
     * You can find the bucket name in the App Engine Admin console Application Settings page, under the label Google Cloud Storage Bucket. Read more \n\nhere\n\n.
     */
    gcsBucketName: string;
    /**
     * GCS Bucket Path string Subdirectory under the above bucket to sync the data into.
     */
    gcsBucketPath: string;
    /**
     * must be one of ["northamerica-northeast1", "northamerica-northeast2", "us-central1", "us-east1", "us-east4", "us-west1", "us-west2", "us-west3", "us-west4", "southamerica-east1", "southamerica-west1", "europe-central2", "europe-north1", "europe-west1", "europe-west2", "europe-west3", "europe-west4", "europe-west6", "asia-east1", "asia-east2", "asia-northeast1", "asia-northeast2", "asia-northeast3", "asia-south1", "asia-south2", "asia-southeast1", "asia-southeast2", "australia-southeast1", "australia-southeast2", "asia", "eu", "us", "asia1", "eur4", "nam4"]
     * Select a Region of the GCS Bucket. Read more \n\nhere\n\n.
     */
    gcsBucketRegion: string;
}

export interface GetDestinationGcsConfigurationCredential {
    destinationGcsAuthenticationHmacKey: outputs.GetDestinationGcsConfigurationCredentialDestinationGcsAuthenticationHmacKey;
    destinationGcsUpdateAuthenticationHmacKey: outputs.GetDestinationGcsConfigurationCredentialDestinationGcsUpdateAuthenticationHmacKey;
}

export interface GetDestinationGcsConfigurationCredentialDestinationGcsAuthenticationHmacKey {
    credentialType: string;
    hmacKeyAccessId: string;
    hmacKeySecret: string;
}

export interface GetDestinationGcsConfigurationCredentialDestinationGcsUpdateAuthenticationHmacKey {
    credentialType: string;
    hmacKeyAccessId: string;
    hmacKeySecret: string;
}

export interface GetDestinationGcsConfigurationFormat {
    destinationGcsOutputFormatAvroApacheAvro: outputs.GetDestinationGcsConfigurationFormatDestinationGcsOutputFormatAvroApacheAvro;
    destinationGcsOutputFormatCsvCommaSeparatedValues: outputs.GetDestinationGcsConfigurationFormatDestinationGcsOutputFormatCsvCommaSeparatedValues;
    destinationGcsOutputFormatJsonLinesNewlineDelimitedJson: outputs.GetDestinationGcsConfigurationFormatDestinationGcsOutputFormatJsonLinesNewlineDelimitedJson;
    destinationGcsOutputFormatParquetColumnarStorage: outputs.GetDestinationGcsConfigurationFormatDestinationGcsOutputFormatParquetColumnarStorage;
    destinationGcsUpdateOutputFormatAvroApacheAvro: outputs.GetDestinationGcsConfigurationFormatDestinationGcsUpdateOutputFormatAvroApacheAvro;
    destinationGcsUpdateOutputFormatCsvCommaSeparatedValues: outputs.GetDestinationGcsConfigurationFormatDestinationGcsUpdateOutputFormatCsvCommaSeparatedValues;
    destinationGcsUpdateOutputFormatJsonLinesNewlineDelimitedJson: outputs.GetDestinationGcsConfigurationFormatDestinationGcsUpdateOutputFormatJsonLinesNewlineDelimitedJson;
    destinationGcsUpdateOutputFormatParquetColumnarStorage: outputs.GetDestinationGcsConfigurationFormatDestinationGcsUpdateOutputFormatParquetColumnarStorage;
}

export interface GetDestinationGcsConfigurationFormatDestinationGcsOutputFormatAvroApacheAvro {
    compressionCodec: outputs.GetDestinationGcsConfigurationFormatDestinationGcsOutputFormatAvroApacheAvroCompressionCodec;
    formatType: string;
}

export interface GetDestinationGcsConfigurationFormatDestinationGcsOutputFormatAvroApacheAvroCompressionCodec {
    destinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2: outputs.GetDestinationGcsConfigurationFormatDestinationGcsOutputFormatAvroApacheAvroCompressionCodecDestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2;
    destinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflate: outputs.GetDestinationGcsConfigurationFormatDestinationGcsOutputFormatAvroApacheAvroCompressionCodecDestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflate;
    destinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompression: outputs.GetDestinationGcsConfigurationFormatDestinationGcsOutputFormatAvroApacheAvroCompressionCodecDestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompression;
    destinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappy: outputs.GetDestinationGcsConfigurationFormatDestinationGcsOutputFormatAvroApacheAvroCompressionCodecDestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappy;
    destinationGcsOutputFormatAvroApacheAvroCompressionCodecXz: outputs.GetDestinationGcsConfigurationFormatDestinationGcsOutputFormatAvroApacheAvroCompressionCodecDestinationGcsOutputFormatAvroApacheAvroCompressionCodecXz;
    destinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandard: outputs.GetDestinationGcsConfigurationFormatDestinationGcsOutputFormatAvroApacheAvroCompressionCodecDestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandard;
}

export interface GetDestinationGcsConfigurationFormatDestinationGcsOutputFormatAvroApacheAvroCompressionCodecDestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2 {
    codec: string;
}

export interface GetDestinationGcsConfigurationFormatDestinationGcsOutputFormatAvroApacheAvroCompressionCodecDestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflate {
    codec: string;
    compressionLevel: number;
}

export interface GetDestinationGcsConfigurationFormatDestinationGcsOutputFormatAvroApacheAvroCompressionCodecDestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompression {
    codec: string;
}

export interface GetDestinationGcsConfigurationFormatDestinationGcsOutputFormatAvroApacheAvroCompressionCodecDestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappy {
    codec: string;
}

export interface GetDestinationGcsConfigurationFormatDestinationGcsOutputFormatAvroApacheAvroCompressionCodecDestinationGcsOutputFormatAvroApacheAvroCompressionCodecXz {
    codec: string;
    compressionLevel: number;
}

export interface GetDestinationGcsConfigurationFormatDestinationGcsOutputFormatAvroApacheAvroCompressionCodecDestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandard {
    codec: string;
    compressionLevel: number;
    includeChecksum: boolean;
}

export interface GetDestinationGcsConfigurationFormatDestinationGcsOutputFormatCsvCommaSeparatedValues {
    compression: outputs.GetDestinationGcsConfigurationFormatDestinationGcsOutputFormatCsvCommaSeparatedValuesCompression;
    flattening: string;
    formatType: string;
}

export interface GetDestinationGcsConfigurationFormatDestinationGcsOutputFormatCsvCommaSeparatedValuesCompression {
    destinationGcsOutputFormatCsvCommaSeparatedValuesCompressionGzip: outputs.GetDestinationGcsConfigurationFormatDestinationGcsOutputFormatCsvCommaSeparatedValuesCompressionDestinationGcsOutputFormatCsvCommaSeparatedValuesCompressionGzip;
    destinationGcsOutputFormatCsvCommaSeparatedValuesCompressionNoCompression: outputs.GetDestinationGcsConfigurationFormatDestinationGcsOutputFormatCsvCommaSeparatedValuesCompressionDestinationGcsOutputFormatCsvCommaSeparatedValuesCompressionNoCompression;
}

export interface GetDestinationGcsConfigurationFormatDestinationGcsOutputFormatCsvCommaSeparatedValuesCompressionDestinationGcsOutputFormatCsvCommaSeparatedValuesCompressionGzip {
    compressionType: string;
}

export interface GetDestinationGcsConfigurationFormatDestinationGcsOutputFormatCsvCommaSeparatedValuesCompressionDestinationGcsOutputFormatCsvCommaSeparatedValuesCompressionNoCompression {
    compressionType: string;
}

export interface GetDestinationGcsConfigurationFormatDestinationGcsOutputFormatJsonLinesNewlineDelimitedJson {
    compression: outputs.GetDestinationGcsConfigurationFormatDestinationGcsOutputFormatJsonLinesNewlineDelimitedJsonCompression;
    formatType: string;
}

export interface GetDestinationGcsConfigurationFormatDestinationGcsOutputFormatJsonLinesNewlineDelimitedJsonCompression {
    destinationGcsOutputFormatJsonLinesNewlineDelimitedJsonCompressionGzip: outputs.GetDestinationGcsConfigurationFormatDestinationGcsOutputFormatJsonLinesNewlineDelimitedJsonCompressionDestinationGcsOutputFormatJsonLinesNewlineDelimitedJsonCompressionGzip;
    destinationGcsOutputFormatJsonLinesNewlineDelimitedJsonCompressionNoCompression: outputs.GetDestinationGcsConfigurationFormatDestinationGcsOutputFormatJsonLinesNewlineDelimitedJsonCompressionDestinationGcsOutputFormatJsonLinesNewlineDelimitedJsonCompressionNoCompression;
}

export interface GetDestinationGcsConfigurationFormatDestinationGcsOutputFormatJsonLinesNewlineDelimitedJsonCompressionDestinationGcsOutputFormatJsonLinesNewlineDelimitedJsonCompressionGzip {
    compressionType: string;
}

export interface GetDestinationGcsConfigurationFormatDestinationGcsOutputFormatJsonLinesNewlineDelimitedJsonCompressionDestinationGcsOutputFormatJsonLinesNewlineDelimitedJsonCompressionNoCompression {
    compressionType: string;
}

export interface GetDestinationGcsConfigurationFormatDestinationGcsOutputFormatParquetColumnarStorage {
    blockSizeMb: number;
    compressionCodec: string;
    dictionaryEncoding: boolean;
    dictionaryPageSizeKb: number;
    formatType: string;
    maxPaddingSizeMb: number;
    pageSizeKb: number;
}

export interface GetDestinationGcsConfigurationFormatDestinationGcsUpdateOutputFormatAvroApacheAvro {
    compressionCodec: outputs.GetDestinationGcsConfigurationFormatDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodec;
    formatType: string;
}

export interface GetDestinationGcsConfigurationFormatDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodec {
    destinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecBzip2: outputs.GetDestinationGcsConfigurationFormatDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecBzip2;
    destinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecDeflate: outputs.GetDestinationGcsConfigurationFormatDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecDeflate;
    destinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecNoCompression: outputs.GetDestinationGcsConfigurationFormatDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecNoCompression;
    destinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecSnappy: outputs.GetDestinationGcsConfigurationFormatDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecSnappy;
    destinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecXz: outputs.GetDestinationGcsConfigurationFormatDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecXz;
    destinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecZstandard: outputs.GetDestinationGcsConfigurationFormatDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecZstandard;
}

export interface GetDestinationGcsConfigurationFormatDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecBzip2 {
    codec: string;
}

export interface GetDestinationGcsConfigurationFormatDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecDeflate {
    codec: string;
    compressionLevel: number;
}

export interface GetDestinationGcsConfigurationFormatDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecNoCompression {
    codec: string;
}

export interface GetDestinationGcsConfigurationFormatDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecSnappy {
    codec: string;
}

export interface GetDestinationGcsConfigurationFormatDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecXz {
    codec: string;
    compressionLevel: number;
}

export interface GetDestinationGcsConfigurationFormatDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecZstandard {
    codec: string;
    compressionLevel: number;
    includeChecksum: boolean;
}

export interface GetDestinationGcsConfigurationFormatDestinationGcsUpdateOutputFormatCsvCommaSeparatedValues {
    compression: outputs.GetDestinationGcsConfigurationFormatDestinationGcsUpdateOutputFormatCsvCommaSeparatedValuesCompression;
    flattening: string;
    formatType: string;
}

export interface GetDestinationGcsConfigurationFormatDestinationGcsUpdateOutputFormatCsvCommaSeparatedValuesCompression {
    destinationGcsUpdateOutputFormatCsvCommaSeparatedValuesCompressionGzip: outputs.GetDestinationGcsConfigurationFormatDestinationGcsUpdateOutputFormatCsvCommaSeparatedValuesCompressionDestinationGcsUpdateOutputFormatCsvCommaSeparatedValuesCompressionGzip;
    destinationGcsUpdateOutputFormatCsvCommaSeparatedValuesCompressionNoCompression: outputs.GetDestinationGcsConfigurationFormatDestinationGcsUpdateOutputFormatCsvCommaSeparatedValuesCompressionDestinationGcsUpdateOutputFormatCsvCommaSeparatedValuesCompressionNoCompression;
}

export interface GetDestinationGcsConfigurationFormatDestinationGcsUpdateOutputFormatCsvCommaSeparatedValuesCompressionDestinationGcsUpdateOutputFormatCsvCommaSeparatedValuesCompressionGzip {
    compressionType: string;
}

export interface GetDestinationGcsConfigurationFormatDestinationGcsUpdateOutputFormatCsvCommaSeparatedValuesCompressionDestinationGcsUpdateOutputFormatCsvCommaSeparatedValuesCompressionNoCompression {
    compressionType: string;
}

export interface GetDestinationGcsConfigurationFormatDestinationGcsUpdateOutputFormatJsonLinesNewlineDelimitedJson {
    compression: outputs.GetDestinationGcsConfigurationFormatDestinationGcsUpdateOutputFormatJsonLinesNewlineDelimitedJsonCompression;
    formatType: string;
}

export interface GetDestinationGcsConfigurationFormatDestinationGcsUpdateOutputFormatJsonLinesNewlineDelimitedJsonCompression {
    destinationGcsUpdateOutputFormatJsonLinesNewlineDelimitedJsonCompressionGzip: outputs.GetDestinationGcsConfigurationFormatDestinationGcsUpdateOutputFormatJsonLinesNewlineDelimitedJsonCompressionDestinationGcsUpdateOutputFormatJsonLinesNewlineDelimitedJsonCompressionGzip;
    destinationGcsUpdateOutputFormatJsonLinesNewlineDelimitedJsonCompressionNoCompression: outputs.GetDestinationGcsConfigurationFormatDestinationGcsUpdateOutputFormatJsonLinesNewlineDelimitedJsonCompressionDestinationGcsUpdateOutputFormatJsonLinesNewlineDelimitedJsonCompressionNoCompression;
}

export interface GetDestinationGcsConfigurationFormatDestinationGcsUpdateOutputFormatJsonLinesNewlineDelimitedJsonCompressionDestinationGcsUpdateOutputFormatJsonLinesNewlineDelimitedJsonCompressionGzip {
    compressionType: string;
}

export interface GetDestinationGcsConfigurationFormatDestinationGcsUpdateOutputFormatJsonLinesNewlineDelimitedJsonCompressionDestinationGcsUpdateOutputFormatJsonLinesNewlineDelimitedJsonCompressionNoCompression {
    compressionType: string;
}

export interface GetDestinationGcsConfigurationFormatDestinationGcsUpdateOutputFormatParquetColumnarStorage {
    blockSizeMb: number;
    compressionCodec: string;
    dictionaryEncoding: boolean;
    dictionaryPageSizeKb: number;
    formatType: string;
    maxPaddingSizeMb: number;
    pageSizeKb: number;
}

export interface GetDestinationGoogleSheetsConfiguration {
    /**
     * Google API Credentials for connecting to Google Sheets and Google Drive APIs
     */
    credentials: outputs.GetDestinationGoogleSheetsConfigurationCredentials;
    /**
     * must be one of ["google-sheets"]
     */
    destinationType: string;
    /**
     * The link to your spreadsheet. See \n\nthis guide\n\n for more details.
     */
    spreadsheetId: string;
}

export interface GetDestinationGoogleSheetsConfigurationCredentials {
    clientId: string;
    clientSecret: string;
    refreshToken: string;
}

export interface GetDestinationKeenConfiguration {
    /**
     * To get Keen Master API Key, navigate to the Access tab from the left-hand, side panel and check the Project Details section.
     */
    apiKey: string;
    /**
     * must be one of ["keen"]
     */
    destinationType: string;
    /**
     * Allow connector to guess keen.timestamp value based on the streamed data.
     */
    inferTimestamp: boolean;
    /**
     * To get Keen Project ID, navigate to the Access tab from the left-hand, side panel and check the Project Details section.
     */
    projectId: string;
}

export interface GetDestinationKinesisConfiguration {
    /**
     * Generate the AWS Access Key for current user.
     */
    accessKey: string;
    /**
     * Buffer size for storing kinesis records before being batch streamed.
     */
    bufferSize: number;
    /**
     * must be one of ["kinesis"]
     */
    destinationType: string;
    /**
     * AWS Kinesis endpoint.
     */
    endpoint: string;
    /**
     * The AWS Private Key - a string of numbers and letters that are unique for each account, also known as a "recovery phrase".
     */
    privateKey: string;
    /**
     * AWS region. Your account determines the Regions that are available to you.
     */
    region: string;
    /**
     * Number of shards to which the data should be streamed.
     */
    shardCount: number;
}

export interface GetDestinationLangchainConfiguration {
    /**
     * must be one of ["langchain"]
     */
    destinationType: string;
    /**
     * Embedding configuration
     */
    embedding: outputs.GetDestinationLangchainConfigurationEmbedding;
    /**
     * Indexing configuration
     */
    indexing: outputs.GetDestinationLangchainConfigurationIndexing;
    processing: outputs.GetDestinationLangchainConfigurationProcessing;
}

export interface GetDestinationLangchainConfigurationEmbedding {
    destinationLangchainEmbeddingFake: outputs.GetDestinationLangchainConfigurationEmbeddingDestinationLangchainEmbeddingFake;
    destinationLangchainEmbeddingOpenAi: outputs.GetDestinationLangchainConfigurationEmbeddingDestinationLangchainEmbeddingOpenAi;
    destinationLangchainUpdateEmbeddingFake: outputs.GetDestinationLangchainConfigurationEmbeddingDestinationLangchainUpdateEmbeddingFake;
    destinationLangchainUpdateEmbeddingOpenAi: outputs.GetDestinationLangchainConfigurationEmbeddingDestinationLangchainUpdateEmbeddingOpenAi;
}

export interface GetDestinationLangchainConfigurationEmbeddingDestinationLangchainEmbeddingFake {
    mode: string;
}

export interface GetDestinationLangchainConfigurationEmbeddingDestinationLangchainEmbeddingOpenAi {
    mode: string;
    openaiKey: string;
}

export interface GetDestinationLangchainConfigurationEmbeddingDestinationLangchainUpdateEmbeddingFake {
    mode: string;
}

export interface GetDestinationLangchainConfigurationEmbeddingDestinationLangchainUpdateEmbeddingOpenAi {
    mode: string;
    openaiKey: string;
}

export interface GetDestinationLangchainConfigurationIndexing {
    destinationLangchainIndexingChromaLocalPersistance: outputs.GetDestinationLangchainConfigurationIndexingDestinationLangchainIndexingChromaLocalPersistance;
    destinationLangchainIndexingDocArrayHnswSearch: outputs.GetDestinationLangchainConfigurationIndexingDestinationLangchainIndexingDocArrayHnswSearch;
    destinationLangchainIndexingPinecone: outputs.GetDestinationLangchainConfigurationIndexingDestinationLangchainIndexingPinecone;
    destinationLangchainUpdateIndexingChromaLocalPersistance: outputs.GetDestinationLangchainConfigurationIndexingDestinationLangchainUpdateIndexingChromaLocalPersistance;
    destinationLangchainUpdateIndexingDocArrayHnswSearch: outputs.GetDestinationLangchainConfigurationIndexingDestinationLangchainUpdateIndexingDocArrayHnswSearch;
    destinationLangchainUpdateIndexingPinecone: outputs.GetDestinationLangchainConfigurationIndexingDestinationLangchainUpdateIndexingPinecone;
}

export interface GetDestinationLangchainConfigurationIndexingDestinationLangchainIndexingChromaLocalPersistance {
    collectionName: string;
    destinationPath: string;
    mode: string;
}

export interface GetDestinationLangchainConfigurationIndexingDestinationLangchainIndexingDocArrayHnswSearch {
    destinationPath: string;
    mode: string;
}

export interface GetDestinationLangchainConfigurationIndexingDestinationLangchainIndexingPinecone {
    index: string;
    mode: string;
    pineconeEnvironment: string;
    pineconeKey: string;
}

export interface GetDestinationLangchainConfigurationIndexingDestinationLangchainUpdateIndexingChromaLocalPersistance {
    collectionName: string;
    destinationPath: string;
    mode: string;
}

export interface GetDestinationLangchainConfigurationIndexingDestinationLangchainUpdateIndexingDocArrayHnswSearch {
    destinationPath: string;
    mode: string;
}

export interface GetDestinationLangchainConfigurationIndexingDestinationLangchainUpdateIndexingPinecone {
    index: string;
    mode: string;
    pineconeEnvironment: string;
    pineconeKey: string;
}

export interface GetDestinationLangchainConfigurationProcessing {
    chunkOverlap: number;
    chunkSize: number;
    textFields: string[];
}

export interface GetDestinationMSsqlConfiguration {
    /**
     * The name of the MSSQL database.
     */
    database: string;
    /**
     * must be one of ["mssql"]
     */
    destinationType: string;
    /**
     * The host name of the MSSQL database.
     */
    host: string;
    /**
     * Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
     */
    jdbcUrlParams: string;
    /**
     * The password associated with this username.
     */
    password: string;
    /**
     * The port of the MSSQL database.
     */
    port: number;
    /**
     * The default schema tables are written to if the source does not specify a namespace. The usual value for this field is "public".
     */
    schema: string;
    /**
     * The encryption method which is used to communicate with the database.
     */
    sslMethod: outputs.GetDestinationMSsqlConfigurationSslMethod;
    /**
     * Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
     */
    tunnelMethod: outputs.GetDestinationMSsqlConfigurationTunnelMethod;
    /**
     * The username which is used to access the database.
     */
    username: string;
}

export interface GetDestinationMSsqlConfigurationSslMethod {
    destinationMssqlSslMethodEncryptedTrustServerCertificate: outputs.GetDestinationMSsqlConfigurationSslMethodDestinationMssqlSslMethodEncryptedTrustServerCertificate;
    destinationMssqlSslMethodEncryptedVerifyCertificate: outputs.GetDestinationMSsqlConfigurationSslMethodDestinationMssqlSslMethodEncryptedVerifyCertificate;
    destinationMssqlUpdateSslMethodEncryptedTrustServerCertificate: outputs.GetDestinationMSsqlConfigurationSslMethodDestinationMssqlUpdateSslMethodEncryptedTrustServerCertificate;
    destinationMssqlUpdateSslMethodEncryptedVerifyCertificate: outputs.GetDestinationMSsqlConfigurationSslMethodDestinationMssqlUpdateSslMethodEncryptedVerifyCertificate;
}

export interface GetDestinationMSsqlConfigurationSslMethodDestinationMssqlSslMethodEncryptedTrustServerCertificate {
    sslMethod: string;
}

export interface GetDestinationMSsqlConfigurationSslMethodDestinationMssqlSslMethodEncryptedVerifyCertificate {
    hostNameInCertificate: string;
    sslMethod: string;
}

export interface GetDestinationMSsqlConfigurationSslMethodDestinationMssqlUpdateSslMethodEncryptedTrustServerCertificate {
    sslMethod: string;
}

export interface GetDestinationMSsqlConfigurationSslMethodDestinationMssqlUpdateSslMethodEncryptedVerifyCertificate {
    hostNameInCertificate: string;
    sslMethod: string;
}

export interface GetDestinationMSsqlConfigurationTunnelMethod {
    destinationMssqlSshTunnelMethodNoTunnel: outputs.GetDestinationMSsqlConfigurationTunnelMethodDestinationMssqlSshTunnelMethodNoTunnel;
    destinationMssqlSshTunnelMethodPasswordAuthentication: outputs.GetDestinationMSsqlConfigurationTunnelMethodDestinationMssqlSshTunnelMethodPasswordAuthentication;
    destinationMssqlSshTunnelMethodSshKeyAuthentication: outputs.GetDestinationMSsqlConfigurationTunnelMethodDestinationMssqlSshTunnelMethodSshKeyAuthentication;
    destinationMssqlUpdateSshTunnelMethodNoTunnel: outputs.GetDestinationMSsqlConfigurationTunnelMethodDestinationMssqlUpdateSshTunnelMethodNoTunnel;
    destinationMssqlUpdateSshTunnelMethodPasswordAuthentication: outputs.GetDestinationMSsqlConfigurationTunnelMethodDestinationMssqlUpdateSshTunnelMethodPasswordAuthentication;
    destinationMssqlUpdateSshTunnelMethodSshKeyAuthentication: outputs.GetDestinationMSsqlConfigurationTunnelMethodDestinationMssqlUpdateSshTunnelMethodSshKeyAuthentication;
}

export interface GetDestinationMSsqlConfigurationTunnelMethodDestinationMssqlSshTunnelMethodNoTunnel {
    tunnelMethod: string;
}

export interface GetDestinationMSsqlConfigurationTunnelMethodDestinationMssqlSshTunnelMethodPasswordAuthentication {
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
    tunnelUserPassword: string;
}

export interface GetDestinationMSsqlConfigurationTunnelMethodDestinationMssqlSshTunnelMethodSshKeyAuthentication {
    sshKey: string;
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
}

export interface GetDestinationMSsqlConfigurationTunnelMethodDestinationMssqlUpdateSshTunnelMethodNoTunnel {
    tunnelMethod: string;
}

export interface GetDestinationMSsqlConfigurationTunnelMethodDestinationMssqlUpdateSshTunnelMethodPasswordAuthentication {
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
    tunnelUserPassword: string;
}

export interface GetDestinationMSsqlConfigurationTunnelMethodDestinationMssqlUpdateSshTunnelMethodSshKeyAuthentication {
    sshKey: string;
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
}

export interface GetDestinationMongodbConfiguration {
    /**
     * Authorization type.
     */
    authType: outputs.GetDestinationMongodbConfigurationAuthType;
    /**
     * Name of the database.
     */
    database: string;
    /**
     * must be one of ["mongodb"]
     */
    destinationType: string;
    /**
     * MongoDb instance to connect to. For MongoDB Atlas and Replica Set TLS connection is used by default.
     */
    instanceType: outputs.GetDestinationMongodbConfigurationInstanceType;
    /**
     * Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
     */
    tunnelMethod: outputs.GetDestinationMongodbConfigurationTunnelMethod;
}

export interface GetDestinationMongodbConfigurationAuthType {
    destinationMongodbAuthorizationTypeLoginPassword: outputs.GetDestinationMongodbConfigurationAuthTypeDestinationMongodbAuthorizationTypeLoginPassword;
    destinationMongodbAuthorizationTypeNone: outputs.GetDestinationMongodbConfigurationAuthTypeDestinationMongodbAuthorizationTypeNone;
    destinationMongodbUpdateAuthorizationTypeLoginPassword: outputs.GetDestinationMongodbConfigurationAuthTypeDestinationMongodbUpdateAuthorizationTypeLoginPassword;
    destinationMongodbUpdateAuthorizationTypeNone: outputs.GetDestinationMongodbConfigurationAuthTypeDestinationMongodbUpdateAuthorizationTypeNone;
}

export interface GetDestinationMongodbConfigurationAuthTypeDestinationMongodbAuthorizationTypeLoginPassword {
    authorization: string;
    password: string;
    username: string;
}

export interface GetDestinationMongodbConfigurationAuthTypeDestinationMongodbAuthorizationTypeNone {
    authorization: string;
}

export interface GetDestinationMongodbConfigurationAuthTypeDestinationMongodbUpdateAuthorizationTypeLoginPassword {
    authorization: string;
    password: string;
    username: string;
}

export interface GetDestinationMongodbConfigurationAuthTypeDestinationMongodbUpdateAuthorizationTypeNone {
    authorization: string;
}

export interface GetDestinationMongodbConfigurationInstanceType {
    destinationMongodbMongoDbInstanceTypeMongoDbAtlas: outputs.GetDestinationMongodbConfigurationInstanceTypeDestinationMongodbMongoDbInstanceTypeMongoDbAtlas;
    destinationMongodbMongoDbInstanceTypeReplicaSet: outputs.GetDestinationMongodbConfigurationInstanceTypeDestinationMongodbMongoDbInstanceTypeReplicaSet;
    destinationMongodbMongoDbInstanceTypeStandaloneMongoDbInstance: outputs.GetDestinationMongodbConfigurationInstanceTypeDestinationMongodbMongoDbInstanceTypeStandaloneMongoDbInstance;
    destinationMongodbUpdateMongoDbInstanceTypeMongoDbAtlas: outputs.GetDestinationMongodbConfigurationInstanceTypeDestinationMongodbUpdateMongoDbInstanceTypeMongoDbAtlas;
    destinationMongodbUpdateMongoDbInstanceTypeReplicaSet: outputs.GetDestinationMongodbConfigurationInstanceTypeDestinationMongodbUpdateMongoDbInstanceTypeReplicaSet;
    destinationMongodbUpdateMongoDbInstanceTypeStandaloneMongoDbInstance: outputs.GetDestinationMongodbConfigurationInstanceTypeDestinationMongodbUpdateMongoDbInstanceTypeStandaloneMongoDbInstance;
}

export interface GetDestinationMongodbConfigurationInstanceTypeDestinationMongodbMongoDbInstanceTypeMongoDbAtlas {
    clusterUrl: string;
    instance: string;
}

export interface GetDestinationMongodbConfigurationInstanceTypeDestinationMongodbMongoDbInstanceTypeReplicaSet {
    instance: string;
    replicaSet: string;
    serverAddresses: string;
}

export interface GetDestinationMongodbConfigurationInstanceTypeDestinationMongodbMongoDbInstanceTypeStandaloneMongoDbInstance {
    host: string;
    instance: string;
    port: number;
}

export interface GetDestinationMongodbConfigurationInstanceTypeDestinationMongodbUpdateMongoDbInstanceTypeMongoDbAtlas {
    clusterUrl: string;
    instance: string;
}

export interface GetDestinationMongodbConfigurationInstanceTypeDestinationMongodbUpdateMongoDbInstanceTypeReplicaSet {
    instance: string;
    replicaSet: string;
    serverAddresses: string;
}

export interface GetDestinationMongodbConfigurationInstanceTypeDestinationMongodbUpdateMongoDbInstanceTypeStandaloneMongoDbInstance {
    host: string;
    instance: string;
    port: number;
}

export interface GetDestinationMongodbConfigurationTunnelMethod {
    destinationMongodbSshTunnelMethodNoTunnel: outputs.GetDestinationMongodbConfigurationTunnelMethodDestinationMongodbSshTunnelMethodNoTunnel;
    destinationMongodbSshTunnelMethodPasswordAuthentication: outputs.GetDestinationMongodbConfigurationTunnelMethodDestinationMongodbSshTunnelMethodPasswordAuthentication;
    destinationMongodbSshTunnelMethodSshKeyAuthentication: outputs.GetDestinationMongodbConfigurationTunnelMethodDestinationMongodbSshTunnelMethodSshKeyAuthentication;
    destinationMongodbUpdateSshTunnelMethodNoTunnel: outputs.GetDestinationMongodbConfigurationTunnelMethodDestinationMongodbUpdateSshTunnelMethodNoTunnel;
    destinationMongodbUpdateSshTunnelMethodPasswordAuthentication: outputs.GetDestinationMongodbConfigurationTunnelMethodDestinationMongodbUpdateSshTunnelMethodPasswordAuthentication;
    destinationMongodbUpdateSshTunnelMethodSshKeyAuthentication: outputs.GetDestinationMongodbConfigurationTunnelMethodDestinationMongodbUpdateSshTunnelMethodSshKeyAuthentication;
}

export interface GetDestinationMongodbConfigurationTunnelMethodDestinationMongodbSshTunnelMethodNoTunnel {
    tunnelMethod: string;
}

export interface GetDestinationMongodbConfigurationTunnelMethodDestinationMongodbSshTunnelMethodPasswordAuthentication {
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
    tunnelUserPassword: string;
}

export interface GetDestinationMongodbConfigurationTunnelMethodDestinationMongodbSshTunnelMethodSshKeyAuthentication {
    sshKey: string;
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
}

export interface GetDestinationMongodbConfigurationTunnelMethodDestinationMongodbUpdateSshTunnelMethodNoTunnel {
    tunnelMethod: string;
}

export interface GetDestinationMongodbConfigurationTunnelMethodDestinationMongodbUpdateSshTunnelMethodPasswordAuthentication {
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
    tunnelUserPassword: string;
}

export interface GetDestinationMongodbConfigurationTunnelMethodDestinationMongodbUpdateSshTunnelMethodSshKeyAuthentication {
    sshKey: string;
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
}

export interface GetDestinationMysqlConfiguration {
    /**
     * Name of the database.
     */
    database: string;
    /**
     * must be one of ["mysql"]
     */
    destinationType: string;
    /**
     * Hostname of the database.
     */
    host: string;
    /**
     * Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
     */
    jdbcUrlParams: string;
    /**
     * Password associated with the username.
     */
    password: string;
    /**
     * Port of the database.
     */
    port: number;
    /**
     * Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
     */
    tunnelMethod: outputs.GetDestinationMysqlConfigurationTunnelMethod;
    /**
     * Username to use to access the database.
     */
    username: string;
}

export interface GetDestinationMysqlConfigurationTunnelMethod {
    destinationMysqlSshTunnelMethodNoTunnel: outputs.GetDestinationMysqlConfigurationTunnelMethodDestinationMysqlSshTunnelMethodNoTunnel;
    destinationMysqlSshTunnelMethodPasswordAuthentication: outputs.GetDestinationMysqlConfigurationTunnelMethodDestinationMysqlSshTunnelMethodPasswordAuthentication;
    destinationMysqlSshTunnelMethodSshKeyAuthentication: outputs.GetDestinationMysqlConfigurationTunnelMethodDestinationMysqlSshTunnelMethodSshKeyAuthentication;
    destinationMysqlUpdateSshTunnelMethodNoTunnel: outputs.GetDestinationMysqlConfigurationTunnelMethodDestinationMysqlUpdateSshTunnelMethodNoTunnel;
    destinationMysqlUpdateSshTunnelMethodPasswordAuthentication: outputs.GetDestinationMysqlConfigurationTunnelMethodDestinationMysqlUpdateSshTunnelMethodPasswordAuthentication;
    destinationMysqlUpdateSshTunnelMethodSshKeyAuthentication: outputs.GetDestinationMysqlConfigurationTunnelMethodDestinationMysqlUpdateSshTunnelMethodSshKeyAuthentication;
}

export interface GetDestinationMysqlConfigurationTunnelMethodDestinationMysqlSshTunnelMethodNoTunnel {
    tunnelMethod: string;
}

export interface GetDestinationMysqlConfigurationTunnelMethodDestinationMysqlSshTunnelMethodPasswordAuthentication {
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
    tunnelUserPassword: string;
}

export interface GetDestinationMysqlConfigurationTunnelMethodDestinationMysqlSshTunnelMethodSshKeyAuthentication {
    sshKey: string;
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
}

export interface GetDestinationMysqlConfigurationTunnelMethodDestinationMysqlUpdateSshTunnelMethodNoTunnel {
    tunnelMethod: string;
}

export interface GetDestinationMysqlConfigurationTunnelMethodDestinationMysqlUpdateSshTunnelMethodPasswordAuthentication {
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
    tunnelUserPassword: string;
}

export interface GetDestinationMysqlConfigurationTunnelMethodDestinationMysqlUpdateSshTunnelMethodSshKeyAuthentication {
    sshKey: string;
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
}

export interface GetDestinationOracleConfiguration {
    /**
     * must be one of ["oracle"]
     */
    destinationType: string;
    /**
     * The hostname of the database.
     */
    host: string;
    /**
     * Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
     */
    jdbcUrlParams: string;
    /**
     * The password associated with the username.
     */
    password: string;
    /**
     * The port of the database.
     */
    port: number;
    /**
     * The default schema is used as the target schema for all statements issued from the connection that do not explicitly specify a schema name. The usual value for this field is "airbyte".  In Oracle, schemas and users are the same thing, so the "user" parameter is used as the login credentials and this is used for the default Airbyte message schema.
     */
    schema: string;
    /**
     * The System Identifier uniquely distinguishes the instance from any other instance on the same computer.
     */
    sid: string;
    /**
     * Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
     */
    tunnelMethod: outputs.GetDestinationOracleConfigurationTunnelMethod;
    /**
     * The username to access the database. This user must have CREATE USER privileges in the database.
     */
    username: string;
}

export interface GetDestinationOracleConfigurationTunnelMethod {
    destinationOracleSshTunnelMethodNoTunnel: outputs.GetDestinationOracleConfigurationTunnelMethodDestinationOracleSshTunnelMethodNoTunnel;
    destinationOracleSshTunnelMethodPasswordAuthentication: outputs.GetDestinationOracleConfigurationTunnelMethodDestinationOracleSshTunnelMethodPasswordAuthentication;
    destinationOracleSshTunnelMethodSshKeyAuthentication: outputs.GetDestinationOracleConfigurationTunnelMethodDestinationOracleSshTunnelMethodSshKeyAuthentication;
    destinationOracleUpdateSshTunnelMethodNoTunnel: outputs.GetDestinationOracleConfigurationTunnelMethodDestinationOracleUpdateSshTunnelMethodNoTunnel;
    destinationOracleUpdateSshTunnelMethodPasswordAuthentication: outputs.GetDestinationOracleConfigurationTunnelMethodDestinationOracleUpdateSshTunnelMethodPasswordAuthentication;
    destinationOracleUpdateSshTunnelMethodSshKeyAuthentication: outputs.GetDestinationOracleConfigurationTunnelMethodDestinationOracleUpdateSshTunnelMethodSshKeyAuthentication;
}

export interface GetDestinationOracleConfigurationTunnelMethodDestinationOracleSshTunnelMethodNoTunnel {
    tunnelMethod: string;
}

export interface GetDestinationOracleConfigurationTunnelMethodDestinationOracleSshTunnelMethodPasswordAuthentication {
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
    tunnelUserPassword: string;
}

export interface GetDestinationOracleConfigurationTunnelMethodDestinationOracleSshTunnelMethodSshKeyAuthentication {
    sshKey: string;
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
}

export interface GetDestinationOracleConfigurationTunnelMethodDestinationOracleUpdateSshTunnelMethodNoTunnel {
    tunnelMethod: string;
}

export interface GetDestinationOracleConfigurationTunnelMethodDestinationOracleUpdateSshTunnelMethodPasswordAuthentication {
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
    tunnelUserPassword: string;
}

export interface GetDestinationOracleConfigurationTunnelMethodDestinationOracleUpdateSshTunnelMethodSshKeyAuthentication {
    sshKey: string;
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
}

export interface GetDestinationPostgresConfiguration {
    /**
     * Name of the database.
     */
    database: string;
    /**
     * must be one of ["postgres"]
     */
    destinationType: string;
    /**
     * Hostname of the database.
     */
    host: string;
    /**
     * Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
     */
    jdbcUrlParams: string;
    /**
     * Password associated with the username.
     */
    password: string;
    /**
     * Port of the database.
     */
    port: number;
    /**
     * The default schema tables are written to if the source does not specify a namespace. The usual value for this field is "public".
     */
    schema: string;
    /**
     * SSL connection modes.
     * \n\ndisable\n\n - Chose this mode to disable encryption of communication between Airbyte and destination database
     * \n\nallow\n\n - Chose this mode to enable encryption only when required by the source database
     * \n\nprefer\n\n - Chose this mode to allow unencrypted connection only if the source database does not support encryption
     * \n\nrequire\n\n - Chose this mode to always require encryption. If the source database server does not support encryption, connection will fail
     * \n\nverify-ca\n\n - Chose this mode to always require encryption and to verify that the source database server has a valid SSL certificate
     * \n\nverify-full\n\n - This is the most secure mode. Chose this mode to always require encryption and to verify the identity of the source database server
     * See more information - \n\n in the docs\n\n.
     */
    sslMode: outputs.GetDestinationPostgresConfigurationSslMode;
    /**
     * Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
     */
    tunnelMethod: outputs.GetDestinationPostgresConfigurationTunnelMethod;
    /**
     * Username to use to access the database.
     */
    username: string;
}

export interface GetDestinationPostgresConfigurationSslMode {
    destinationPostgresSslModesAllow: outputs.GetDestinationPostgresConfigurationSslModeDestinationPostgresSslModesAllow;
    destinationPostgresSslModesDisable: outputs.GetDestinationPostgresConfigurationSslModeDestinationPostgresSslModesDisable;
    destinationPostgresSslModesPrefer: outputs.GetDestinationPostgresConfigurationSslModeDestinationPostgresSslModesPrefer;
    destinationPostgresSslModesRequire: outputs.GetDestinationPostgresConfigurationSslModeDestinationPostgresSslModesRequire;
    destinationPostgresSslModesVerifyCa: outputs.GetDestinationPostgresConfigurationSslModeDestinationPostgresSslModesVerifyCa;
    destinationPostgresSslModesVerifyFull: outputs.GetDestinationPostgresConfigurationSslModeDestinationPostgresSslModesVerifyFull;
    destinationPostgresUpdateSslModesAllow: outputs.GetDestinationPostgresConfigurationSslModeDestinationPostgresUpdateSslModesAllow;
    destinationPostgresUpdateSslModesDisable: outputs.GetDestinationPostgresConfigurationSslModeDestinationPostgresUpdateSslModesDisable;
    destinationPostgresUpdateSslModesPrefer: outputs.GetDestinationPostgresConfigurationSslModeDestinationPostgresUpdateSslModesPrefer;
    destinationPostgresUpdateSslModesRequire: outputs.GetDestinationPostgresConfigurationSslModeDestinationPostgresUpdateSslModesRequire;
    destinationPostgresUpdateSslModesVerifyCa: outputs.GetDestinationPostgresConfigurationSslModeDestinationPostgresUpdateSslModesVerifyCa;
    destinationPostgresUpdateSslModesVerifyFull: outputs.GetDestinationPostgresConfigurationSslModeDestinationPostgresUpdateSslModesVerifyFull;
}

export interface GetDestinationPostgresConfigurationSslModeDestinationPostgresSslModesAllow {
    mode: string;
}

export interface GetDestinationPostgresConfigurationSslModeDestinationPostgresSslModesDisable {
    mode: string;
}

export interface GetDestinationPostgresConfigurationSslModeDestinationPostgresSslModesPrefer {
    mode: string;
}

export interface GetDestinationPostgresConfigurationSslModeDestinationPostgresSslModesRequire {
    mode: string;
}

export interface GetDestinationPostgresConfigurationSslModeDestinationPostgresSslModesVerifyCa {
    caCertificate: string;
    clientKeyPassword: string;
    mode: string;
}

export interface GetDestinationPostgresConfigurationSslModeDestinationPostgresSslModesVerifyFull {
    caCertificate: string;
    clientCertificate: string;
    clientKey: string;
    clientKeyPassword: string;
    mode: string;
}

export interface GetDestinationPostgresConfigurationSslModeDestinationPostgresUpdateSslModesAllow {
    mode: string;
}

export interface GetDestinationPostgresConfigurationSslModeDestinationPostgresUpdateSslModesDisable {
    mode: string;
}

export interface GetDestinationPostgresConfigurationSslModeDestinationPostgresUpdateSslModesPrefer {
    mode: string;
}

export interface GetDestinationPostgresConfigurationSslModeDestinationPostgresUpdateSslModesRequire {
    mode: string;
}

export interface GetDestinationPostgresConfigurationSslModeDestinationPostgresUpdateSslModesVerifyCa {
    caCertificate: string;
    clientKeyPassword: string;
    mode: string;
}

export interface GetDestinationPostgresConfigurationSslModeDestinationPostgresUpdateSslModesVerifyFull {
    caCertificate: string;
    clientCertificate: string;
    clientKey: string;
    clientKeyPassword: string;
    mode: string;
}

export interface GetDestinationPostgresConfigurationTunnelMethod {
    destinationPostgresSshTunnelMethodNoTunnel: outputs.GetDestinationPostgresConfigurationTunnelMethodDestinationPostgresSshTunnelMethodNoTunnel;
    destinationPostgresSshTunnelMethodPasswordAuthentication: outputs.GetDestinationPostgresConfigurationTunnelMethodDestinationPostgresSshTunnelMethodPasswordAuthentication;
    destinationPostgresSshTunnelMethodSshKeyAuthentication: outputs.GetDestinationPostgresConfigurationTunnelMethodDestinationPostgresSshTunnelMethodSshKeyAuthentication;
    destinationPostgresUpdateSshTunnelMethodNoTunnel: outputs.GetDestinationPostgresConfigurationTunnelMethodDestinationPostgresUpdateSshTunnelMethodNoTunnel;
    destinationPostgresUpdateSshTunnelMethodPasswordAuthentication: outputs.GetDestinationPostgresConfigurationTunnelMethodDestinationPostgresUpdateSshTunnelMethodPasswordAuthentication;
    destinationPostgresUpdateSshTunnelMethodSshKeyAuthentication: outputs.GetDestinationPostgresConfigurationTunnelMethodDestinationPostgresUpdateSshTunnelMethodSshKeyAuthentication;
}

export interface GetDestinationPostgresConfigurationTunnelMethodDestinationPostgresSshTunnelMethodNoTunnel {
    tunnelMethod: string;
}

export interface GetDestinationPostgresConfigurationTunnelMethodDestinationPostgresSshTunnelMethodPasswordAuthentication {
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
    tunnelUserPassword: string;
}

export interface GetDestinationPostgresConfigurationTunnelMethodDestinationPostgresSshTunnelMethodSshKeyAuthentication {
    sshKey: string;
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
}

export interface GetDestinationPostgresConfigurationTunnelMethodDestinationPostgresUpdateSshTunnelMethodNoTunnel {
    tunnelMethod: string;
}

export interface GetDestinationPostgresConfigurationTunnelMethodDestinationPostgresUpdateSshTunnelMethodPasswordAuthentication {
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
    tunnelUserPassword: string;
}

export interface GetDestinationPostgresConfigurationTunnelMethodDestinationPostgresUpdateSshTunnelMethodSshKeyAuthentication {
    sshKey: string;
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
}

export interface GetDestinationPubsubConfiguration {
    /**
     * Number of ms before the buffer is flushed
     */
    batchingDelayThreshold: number;
    /**
     * Number of messages before the buffer is flushed
     */
    batchingElementCountThreshold: number;
    /**
     * If TRUE messages will be buffered instead of sending them one by one
     */
    batchingEnabled: boolean;
    /**
     * Number of bytes before the buffer is flushed
     */
    batchingRequestBytesThreshold: number;
    /**
     * The contents of the JSON service account key. Check out the \n\ndocs\n\n if you need help generating this key.
     */
    credentialsJson: string;
    /**
     * must be one of ["pubsub"]
     */
    destinationType: string;
    /**
     * If TRUE PubSub publisher will have \n\nmessage ordering\n\n enabled. Every message will have an ordering key of stream
     */
    orderingEnabled: boolean;
    /**
     * The GCP project ID for the project containing the target PubSub.
     */
    projectId: string;
    /**
     * The PubSub topic ID in the given GCP project ID.
     */
    topicId: string;
}

export interface GetDestinationRedisConfiguration {
    /**
     * must be one of ["hash"]
     * Redis cache type to store data in.
     */
    cacheType: string;
    /**
     * must be one of ["redis"]
     */
    destinationType: string;
    /**
     * Redis host to connect to.
     */
    host: string;
    /**
     * Password associated with Redis.
     */
    password: string;
    /**
     * Port of Redis.
     */
    port: number;
    /**
     * Indicates whether SSL encryption protocol will be used to connect to Redis. It is recommended to use SSL connection if possible.
     */
    ssl: boolean;
    /**
     * SSL connection modes.
     * \n\n\n\nverify-full\n\n - This is the most secure mode. Always require encryption and verifies the identity of the source database server
     */
    sslMode: outputs.GetDestinationRedisConfigurationSslMode;
    /**
     * Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
     */
    tunnelMethod: outputs.GetDestinationRedisConfigurationTunnelMethod;
    /**
     * Username associated with Redis.
     */
    username: string;
}

export interface GetDestinationRedisConfigurationSslMode {
    destinationRedisSslModesDisable: outputs.GetDestinationRedisConfigurationSslModeDestinationRedisSslModesDisable;
    destinationRedisSslModesVerifyFull: outputs.GetDestinationRedisConfigurationSslModeDestinationRedisSslModesVerifyFull;
    destinationRedisUpdateSslModesDisable: outputs.GetDestinationRedisConfigurationSslModeDestinationRedisUpdateSslModesDisable;
    destinationRedisUpdateSslModesVerifyFull: outputs.GetDestinationRedisConfigurationSslModeDestinationRedisUpdateSslModesVerifyFull;
}

export interface GetDestinationRedisConfigurationSslModeDestinationRedisSslModesDisable {
    mode: string;
}

export interface GetDestinationRedisConfigurationSslModeDestinationRedisSslModesVerifyFull {
    caCertificate: string;
    clientCertificate: string;
    clientKey: string;
    clientKeyPassword: string;
    mode: string;
}

export interface GetDestinationRedisConfigurationSslModeDestinationRedisUpdateSslModesDisable {
    mode: string;
}

export interface GetDestinationRedisConfigurationSslModeDestinationRedisUpdateSslModesVerifyFull {
    caCertificate: string;
    clientCertificate: string;
    clientKey: string;
    clientKeyPassword: string;
    mode: string;
}

export interface GetDestinationRedisConfigurationTunnelMethod {
    destinationRedisSshTunnelMethodNoTunnel: outputs.GetDestinationRedisConfigurationTunnelMethodDestinationRedisSshTunnelMethodNoTunnel;
    destinationRedisSshTunnelMethodPasswordAuthentication: outputs.GetDestinationRedisConfigurationTunnelMethodDestinationRedisSshTunnelMethodPasswordAuthentication;
    destinationRedisSshTunnelMethodSshKeyAuthentication: outputs.GetDestinationRedisConfigurationTunnelMethodDestinationRedisSshTunnelMethodSshKeyAuthentication;
    destinationRedisUpdateSshTunnelMethodNoTunnel: outputs.GetDestinationRedisConfigurationTunnelMethodDestinationRedisUpdateSshTunnelMethodNoTunnel;
    destinationRedisUpdateSshTunnelMethodPasswordAuthentication: outputs.GetDestinationRedisConfigurationTunnelMethodDestinationRedisUpdateSshTunnelMethodPasswordAuthentication;
    destinationRedisUpdateSshTunnelMethodSshKeyAuthentication: outputs.GetDestinationRedisConfigurationTunnelMethodDestinationRedisUpdateSshTunnelMethodSshKeyAuthentication;
}

export interface GetDestinationRedisConfigurationTunnelMethodDestinationRedisSshTunnelMethodNoTunnel {
    tunnelMethod: string;
}

export interface GetDestinationRedisConfigurationTunnelMethodDestinationRedisSshTunnelMethodPasswordAuthentication {
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
    tunnelUserPassword: string;
}

export interface GetDestinationRedisConfigurationTunnelMethodDestinationRedisSshTunnelMethodSshKeyAuthentication {
    sshKey: string;
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
}

export interface GetDestinationRedisConfigurationTunnelMethodDestinationRedisUpdateSshTunnelMethodNoTunnel {
    tunnelMethod: string;
}

export interface GetDestinationRedisConfigurationTunnelMethodDestinationRedisUpdateSshTunnelMethodPasswordAuthentication {
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
    tunnelUserPassword: string;
}

export interface GetDestinationRedisConfigurationTunnelMethodDestinationRedisUpdateSshTunnelMethodSshKeyAuthentication {
    sshKey: string;
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
}

export interface GetDestinationRedshiftConfiguration {
    /**
     * Name of the database.
     */
    database: string;
    /**
     * must be one of ["redshift"]
     */
    destinationType: string;
    /**
     * Host Endpoint of the Redshift Cluster (must include the cluster-id, region and end with .redshift.amazonaws.com)
     */
    host: string;
    /**
     * Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
     */
    jdbcUrlParams: string;
    /**
     * Password associated with the username.
     */
    password: string;
    /**
     * Port of the database.
     */
    port: number;
    /**
     * The default schema tables are written to if the source does not specify a namespace. Unless specifically configured, the usual value for this field is "public".
     */
    schema: string;
    /**
     * Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
     */
    tunnelMethod: outputs.GetDestinationRedshiftConfigurationTunnelMethod;
    /**
     * The method how the data will be uploaded to the database.
     */
    uploadingMethod: outputs.GetDestinationRedshiftConfigurationUploadingMethod;
    /**
     * Username to use to access the database.
     */
    username: string;
}

export interface GetDestinationRedshiftConfigurationTunnelMethod {
    destinationRedshiftSshTunnelMethodNoTunnel: outputs.GetDestinationRedshiftConfigurationTunnelMethodDestinationRedshiftSshTunnelMethodNoTunnel;
    destinationRedshiftSshTunnelMethodPasswordAuthentication: outputs.GetDestinationRedshiftConfigurationTunnelMethodDestinationRedshiftSshTunnelMethodPasswordAuthentication;
    destinationRedshiftSshTunnelMethodSshKeyAuthentication: outputs.GetDestinationRedshiftConfigurationTunnelMethodDestinationRedshiftSshTunnelMethodSshKeyAuthentication;
    destinationRedshiftUpdateSshTunnelMethodNoTunnel: outputs.GetDestinationRedshiftConfigurationTunnelMethodDestinationRedshiftUpdateSshTunnelMethodNoTunnel;
    destinationRedshiftUpdateSshTunnelMethodPasswordAuthentication: outputs.GetDestinationRedshiftConfigurationTunnelMethodDestinationRedshiftUpdateSshTunnelMethodPasswordAuthentication;
    destinationRedshiftUpdateSshTunnelMethodSshKeyAuthentication: outputs.GetDestinationRedshiftConfigurationTunnelMethodDestinationRedshiftUpdateSshTunnelMethodSshKeyAuthentication;
}

export interface GetDestinationRedshiftConfigurationTunnelMethodDestinationRedshiftSshTunnelMethodNoTunnel {
    tunnelMethod: string;
}

export interface GetDestinationRedshiftConfigurationTunnelMethodDestinationRedshiftSshTunnelMethodPasswordAuthentication {
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
    tunnelUserPassword: string;
}

export interface GetDestinationRedshiftConfigurationTunnelMethodDestinationRedshiftSshTunnelMethodSshKeyAuthentication {
    sshKey: string;
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
}

export interface GetDestinationRedshiftConfigurationTunnelMethodDestinationRedshiftUpdateSshTunnelMethodNoTunnel {
    tunnelMethod: string;
}

export interface GetDestinationRedshiftConfigurationTunnelMethodDestinationRedshiftUpdateSshTunnelMethodPasswordAuthentication {
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
    tunnelUserPassword: string;
}

export interface GetDestinationRedshiftConfigurationTunnelMethodDestinationRedshiftUpdateSshTunnelMethodSshKeyAuthentication {
    sshKey: string;
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
}

export interface GetDestinationRedshiftConfigurationUploadingMethod {
    destinationRedshiftUpdateUploadingMethodS3Staging: outputs.GetDestinationRedshiftConfigurationUploadingMethodDestinationRedshiftUpdateUploadingMethodS3Staging;
    destinationRedshiftUpdateUploadingMethodStandard: outputs.GetDestinationRedshiftConfigurationUploadingMethodDestinationRedshiftUpdateUploadingMethodStandard;
    destinationRedshiftUploadingMethodS3Staging: outputs.GetDestinationRedshiftConfigurationUploadingMethodDestinationRedshiftUploadingMethodS3Staging;
    destinationRedshiftUploadingMethodStandard: outputs.GetDestinationRedshiftConfigurationUploadingMethodDestinationRedshiftUploadingMethodStandard;
}

export interface GetDestinationRedshiftConfigurationUploadingMethodDestinationRedshiftUpdateUploadingMethodS3Staging {
    accessKeyId: string;
    encryption: outputs.GetDestinationRedshiftConfigurationUploadingMethodDestinationRedshiftUpdateUploadingMethodS3StagingEncryption;
    fileBufferCount: number;
    fileNamePattern: string;
    method: string;
    purgeStagingData: boolean;
    s3BucketName: string;
    s3BucketPath: string;
    s3BucketRegion: string;
    secretAccessKey: string;
}

export interface GetDestinationRedshiftConfigurationUploadingMethodDestinationRedshiftUpdateUploadingMethodS3StagingEncryption {
    destinationRedshiftUpdateUploadingMethodS3StagingEncryptionAesCbcEnvelopeEncryption: outputs.GetDestinationRedshiftConfigurationUploadingMethodDestinationRedshiftUpdateUploadingMethodS3StagingEncryptionDestinationRedshiftUpdateUploadingMethodS3StagingEncryptionAesCbcEnvelopeEncryption;
    destinationRedshiftUpdateUploadingMethodS3StagingEncryptionNoEncryption: outputs.GetDestinationRedshiftConfigurationUploadingMethodDestinationRedshiftUpdateUploadingMethodS3StagingEncryptionDestinationRedshiftUpdateUploadingMethodS3StagingEncryptionNoEncryption;
}

export interface GetDestinationRedshiftConfigurationUploadingMethodDestinationRedshiftUpdateUploadingMethodS3StagingEncryptionDestinationRedshiftUpdateUploadingMethodS3StagingEncryptionAesCbcEnvelopeEncryption {
    encryptionType: string;
    keyEncryptingKey: string;
}

export interface GetDestinationRedshiftConfigurationUploadingMethodDestinationRedshiftUpdateUploadingMethodS3StagingEncryptionDestinationRedshiftUpdateUploadingMethodS3StagingEncryptionNoEncryption {
    encryptionType: string;
}

export interface GetDestinationRedshiftConfigurationUploadingMethodDestinationRedshiftUpdateUploadingMethodStandard {
    method: string;
}

export interface GetDestinationRedshiftConfigurationUploadingMethodDestinationRedshiftUploadingMethodS3Staging {
    accessKeyId: string;
    encryption: outputs.GetDestinationRedshiftConfigurationUploadingMethodDestinationRedshiftUploadingMethodS3StagingEncryption;
    fileBufferCount: number;
    fileNamePattern: string;
    method: string;
    purgeStagingData: boolean;
    s3BucketName: string;
    s3BucketPath: string;
    s3BucketRegion: string;
    secretAccessKey: string;
}

export interface GetDestinationRedshiftConfigurationUploadingMethodDestinationRedshiftUploadingMethodS3StagingEncryption {
    destinationRedshiftUploadingMethodS3StagingEncryptionAesCbcEnvelopeEncryption: outputs.GetDestinationRedshiftConfigurationUploadingMethodDestinationRedshiftUploadingMethodS3StagingEncryptionDestinationRedshiftUploadingMethodS3StagingEncryptionAesCbcEnvelopeEncryption;
    destinationRedshiftUploadingMethodS3StagingEncryptionNoEncryption: outputs.GetDestinationRedshiftConfigurationUploadingMethodDestinationRedshiftUploadingMethodS3StagingEncryptionDestinationRedshiftUploadingMethodS3StagingEncryptionNoEncryption;
}

export interface GetDestinationRedshiftConfigurationUploadingMethodDestinationRedshiftUploadingMethodS3StagingEncryptionDestinationRedshiftUploadingMethodS3StagingEncryptionAesCbcEnvelopeEncryption {
    encryptionType: string;
    keyEncryptingKey: string;
}

export interface GetDestinationRedshiftConfigurationUploadingMethodDestinationRedshiftUploadingMethodS3StagingEncryptionDestinationRedshiftUploadingMethodS3StagingEncryptionNoEncryption {
    encryptionType: string;
}

export interface GetDestinationRedshiftConfigurationUploadingMethodDestinationRedshiftUploadingMethodStandard {
    method: string;
}

export interface GetDestinationS3Configuration {
    /**
     * The access key ID to access the S3 bucket. Airbyte requires Read and Write permissions to the given bucket. Read more \n\nhere\n\n.
     */
    accessKeyId: string;
    /**
     * must be one of ["s3"]
     */
    destinationType: string;
    /**
     * The pattern allows you to set the file-name format for the S3 staging file(s)
     */
    fileNamePattern: string;
    /**
     * Format of the data output. See \n\nhere\n\n for more details
     */
    format: outputs.GetDestinationS3ConfigurationFormat;
    /**
     * The name of the S3 bucket. Read more \n\nhere\n\n.
     */
    s3BucketName: string;
    /**
     * Directory under the S3 bucket where data will be written. Read more \n\nhere\n\n
     */
    s3BucketPath: string;
    /**
     * must be one of ["", "us-east-1", "us-east-2", "us-west-1", "us-west-2", "af-south-1", "ap-east-1", "ap-south-1", "ap-northeast-1", "ap-northeast-2", "ap-northeast-3", "ap-southeast-1", "ap-southeast-2", "ca-central-1", "cn-north-1", "cn-northwest-1", "eu-central-1", "eu-north-1", "eu-south-1", "eu-west-1", "eu-west-2", "eu-west-3", "sa-east-1", "me-south-1", "us-gov-east-1", "us-gov-west-1"]
     * The region of the S3 bucket. See \n\nhere\n\n for all region codes.
     */
    s3BucketRegion: string;
    /**
     * Your S3 endpoint url. Read more \n\nhere\n\n
     */
    s3Endpoint: string;
    /**
     * Format string on how data will be organized inside the S3 bucket directory. Read more \n\nhere\n\n
     */
    s3PathFormat: string;
    /**
     * The corresponding secret to the access key ID. Read more \n\nhere\n\n
     */
    secretAccessKey: string;
}

export interface GetDestinationS3ConfigurationFormat {
    destinationS3OutputFormatAvroApacheAvro: outputs.GetDestinationS3ConfigurationFormatDestinationS3OutputFormatAvroApacheAvro;
    destinationS3OutputFormatCsvCommaSeparatedValues: outputs.GetDestinationS3ConfigurationFormatDestinationS3OutputFormatCsvCommaSeparatedValues;
    destinationS3OutputFormatJsonLinesNewlineDelimitedJson: outputs.GetDestinationS3ConfigurationFormatDestinationS3OutputFormatJsonLinesNewlineDelimitedJson;
    destinationS3OutputFormatParquetColumnarStorage: outputs.GetDestinationS3ConfigurationFormatDestinationS3OutputFormatParquetColumnarStorage;
    destinationS3UpdateOutputFormatAvroApacheAvro: outputs.GetDestinationS3ConfigurationFormatDestinationS3UpdateOutputFormatAvroApacheAvro;
    destinationS3UpdateOutputFormatCsvCommaSeparatedValues: outputs.GetDestinationS3ConfigurationFormatDestinationS3UpdateOutputFormatCsvCommaSeparatedValues;
    destinationS3UpdateOutputFormatJsonLinesNewlineDelimitedJson: outputs.GetDestinationS3ConfigurationFormatDestinationS3UpdateOutputFormatJsonLinesNewlineDelimitedJson;
    destinationS3UpdateOutputFormatParquetColumnarStorage: outputs.GetDestinationS3ConfigurationFormatDestinationS3UpdateOutputFormatParquetColumnarStorage;
}

export interface GetDestinationS3ConfigurationFormatDestinationS3OutputFormatAvroApacheAvro {
    compressionCodec: outputs.GetDestinationS3ConfigurationFormatDestinationS3OutputFormatAvroApacheAvroCompressionCodec;
    formatType: string;
}

export interface GetDestinationS3ConfigurationFormatDestinationS3OutputFormatAvroApacheAvroCompressionCodec {
    destinationS3OutputFormatAvroApacheAvroCompressionCodecBzip2: outputs.GetDestinationS3ConfigurationFormatDestinationS3OutputFormatAvroApacheAvroCompressionCodecDestinationS3OutputFormatAvroApacheAvroCompressionCodecBzip2;
    destinationS3OutputFormatAvroApacheAvroCompressionCodecDeflate: outputs.GetDestinationS3ConfigurationFormatDestinationS3OutputFormatAvroApacheAvroCompressionCodecDestinationS3OutputFormatAvroApacheAvroCompressionCodecDeflate;
    destinationS3OutputFormatAvroApacheAvroCompressionCodecNoCompression: outputs.GetDestinationS3ConfigurationFormatDestinationS3OutputFormatAvroApacheAvroCompressionCodecDestinationS3OutputFormatAvroApacheAvroCompressionCodecNoCompression;
    destinationS3OutputFormatAvroApacheAvroCompressionCodecSnappy: outputs.GetDestinationS3ConfigurationFormatDestinationS3OutputFormatAvroApacheAvroCompressionCodecDestinationS3OutputFormatAvroApacheAvroCompressionCodecSnappy;
    destinationS3OutputFormatAvroApacheAvroCompressionCodecXz: outputs.GetDestinationS3ConfigurationFormatDestinationS3OutputFormatAvroApacheAvroCompressionCodecDestinationS3OutputFormatAvroApacheAvroCompressionCodecXz;
    destinationS3OutputFormatAvroApacheAvroCompressionCodecZstandard: outputs.GetDestinationS3ConfigurationFormatDestinationS3OutputFormatAvroApacheAvroCompressionCodecDestinationS3OutputFormatAvroApacheAvroCompressionCodecZstandard;
}

export interface GetDestinationS3ConfigurationFormatDestinationS3OutputFormatAvroApacheAvroCompressionCodecDestinationS3OutputFormatAvroApacheAvroCompressionCodecBzip2 {
    codec: string;
}

export interface GetDestinationS3ConfigurationFormatDestinationS3OutputFormatAvroApacheAvroCompressionCodecDestinationS3OutputFormatAvroApacheAvroCompressionCodecDeflate {
    codec: string;
    compressionLevel: number;
}

export interface GetDestinationS3ConfigurationFormatDestinationS3OutputFormatAvroApacheAvroCompressionCodecDestinationS3OutputFormatAvroApacheAvroCompressionCodecNoCompression {
    codec: string;
}

export interface GetDestinationS3ConfigurationFormatDestinationS3OutputFormatAvroApacheAvroCompressionCodecDestinationS3OutputFormatAvroApacheAvroCompressionCodecSnappy {
    codec: string;
}

export interface GetDestinationS3ConfigurationFormatDestinationS3OutputFormatAvroApacheAvroCompressionCodecDestinationS3OutputFormatAvroApacheAvroCompressionCodecXz {
    codec: string;
    compressionLevel: number;
}

export interface GetDestinationS3ConfigurationFormatDestinationS3OutputFormatAvroApacheAvroCompressionCodecDestinationS3OutputFormatAvroApacheAvroCompressionCodecZstandard {
    codec: string;
    compressionLevel: number;
    includeChecksum: boolean;
}

export interface GetDestinationS3ConfigurationFormatDestinationS3OutputFormatCsvCommaSeparatedValues {
    compression: outputs.GetDestinationS3ConfigurationFormatDestinationS3OutputFormatCsvCommaSeparatedValuesCompression;
    flattening: string;
    formatType: string;
}

export interface GetDestinationS3ConfigurationFormatDestinationS3OutputFormatCsvCommaSeparatedValuesCompression {
    destinationS3OutputFormatCsvCommaSeparatedValuesCompressionGzip: outputs.GetDestinationS3ConfigurationFormatDestinationS3OutputFormatCsvCommaSeparatedValuesCompressionDestinationS3OutputFormatCsvCommaSeparatedValuesCompressionGzip;
    destinationS3OutputFormatCsvCommaSeparatedValuesCompressionNoCompression: outputs.GetDestinationS3ConfigurationFormatDestinationS3OutputFormatCsvCommaSeparatedValuesCompressionDestinationS3OutputFormatCsvCommaSeparatedValuesCompressionNoCompression;
}

export interface GetDestinationS3ConfigurationFormatDestinationS3OutputFormatCsvCommaSeparatedValuesCompressionDestinationS3OutputFormatCsvCommaSeparatedValuesCompressionGzip {
    compressionType: string;
}

export interface GetDestinationS3ConfigurationFormatDestinationS3OutputFormatCsvCommaSeparatedValuesCompressionDestinationS3OutputFormatCsvCommaSeparatedValuesCompressionNoCompression {
    compressionType: string;
}

export interface GetDestinationS3ConfigurationFormatDestinationS3OutputFormatJsonLinesNewlineDelimitedJson {
    compression: outputs.GetDestinationS3ConfigurationFormatDestinationS3OutputFormatJsonLinesNewlineDelimitedJsonCompression;
    flattening: string;
    formatType: string;
}

export interface GetDestinationS3ConfigurationFormatDestinationS3OutputFormatJsonLinesNewlineDelimitedJsonCompression {
    destinationS3OutputFormatJsonLinesNewlineDelimitedJsonCompressionGzip: outputs.GetDestinationS3ConfigurationFormatDestinationS3OutputFormatJsonLinesNewlineDelimitedJsonCompressionDestinationS3OutputFormatJsonLinesNewlineDelimitedJsonCompressionGzip;
    destinationS3OutputFormatJsonLinesNewlineDelimitedJsonCompressionNoCompression: outputs.GetDestinationS3ConfigurationFormatDestinationS3OutputFormatJsonLinesNewlineDelimitedJsonCompressionDestinationS3OutputFormatJsonLinesNewlineDelimitedJsonCompressionNoCompression;
}

export interface GetDestinationS3ConfigurationFormatDestinationS3OutputFormatJsonLinesNewlineDelimitedJsonCompressionDestinationS3OutputFormatJsonLinesNewlineDelimitedJsonCompressionGzip {
    compressionType: string;
}

export interface GetDestinationS3ConfigurationFormatDestinationS3OutputFormatJsonLinesNewlineDelimitedJsonCompressionDestinationS3OutputFormatJsonLinesNewlineDelimitedJsonCompressionNoCompression {
    compressionType: string;
}

export interface GetDestinationS3ConfigurationFormatDestinationS3OutputFormatParquetColumnarStorage {
    blockSizeMb: number;
    compressionCodec: string;
    dictionaryEncoding: boolean;
    dictionaryPageSizeKb: number;
    formatType: string;
    maxPaddingSizeMb: number;
    pageSizeKb: number;
}

export interface GetDestinationS3ConfigurationFormatDestinationS3UpdateOutputFormatAvroApacheAvro {
    compressionCodec: outputs.GetDestinationS3ConfigurationFormatDestinationS3UpdateOutputFormatAvroApacheAvroCompressionCodec;
    formatType: string;
}

export interface GetDestinationS3ConfigurationFormatDestinationS3UpdateOutputFormatAvroApacheAvroCompressionCodec {
    destinationS3UpdateOutputFormatAvroApacheAvroCompressionCodecBzip2: outputs.GetDestinationS3ConfigurationFormatDestinationS3UpdateOutputFormatAvroApacheAvroCompressionCodecDestinationS3UpdateOutputFormatAvroApacheAvroCompressionCodecBzip2;
    destinationS3UpdateOutputFormatAvroApacheAvroCompressionCodecDeflate: outputs.GetDestinationS3ConfigurationFormatDestinationS3UpdateOutputFormatAvroApacheAvroCompressionCodecDestinationS3UpdateOutputFormatAvroApacheAvroCompressionCodecDeflate;
    destinationS3UpdateOutputFormatAvroApacheAvroCompressionCodecNoCompression: outputs.GetDestinationS3ConfigurationFormatDestinationS3UpdateOutputFormatAvroApacheAvroCompressionCodecDestinationS3UpdateOutputFormatAvroApacheAvroCompressionCodecNoCompression;
    destinationS3UpdateOutputFormatAvroApacheAvroCompressionCodecSnappy: outputs.GetDestinationS3ConfigurationFormatDestinationS3UpdateOutputFormatAvroApacheAvroCompressionCodecDestinationS3UpdateOutputFormatAvroApacheAvroCompressionCodecSnappy;
    destinationS3UpdateOutputFormatAvroApacheAvroCompressionCodecXz: outputs.GetDestinationS3ConfigurationFormatDestinationS3UpdateOutputFormatAvroApacheAvroCompressionCodecDestinationS3UpdateOutputFormatAvroApacheAvroCompressionCodecXz;
    destinationS3UpdateOutputFormatAvroApacheAvroCompressionCodecZstandard: outputs.GetDestinationS3ConfigurationFormatDestinationS3UpdateOutputFormatAvroApacheAvroCompressionCodecDestinationS3UpdateOutputFormatAvroApacheAvroCompressionCodecZstandard;
}

export interface GetDestinationS3ConfigurationFormatDestinationS3UpdateOutputFormatAvroApacheAvroCompressionCodecDestinationS3UpdateOutputFormatAvroApacheAvroCompressionCodecBzip2 {
    codec: string;
}

export interface GetDestinationS3ConfigurationFormatDestinationS3UpdateOutputFormatAvroApacheAvroCompressionCodecDestinationS3UpdateOutputFormatAvroApacheAvroCompressionCodecDeflate {
    codec: string;
    compressionLevel: number;
}

export interface GetDestinationS3ConfigurationFormatDestinationS3UpdateOutputFormatAvroApacheAvroCompressionCodecDestinationS3UpdateOutputFormatAvroApacheAvroCompressionCodecNoCompression {
    codec: string;
}

export interface GetDestinationS3ConfigurationFormatDestinationS3UpdateOutputFormatAvroApacheAvroCompressionCodecDestinationS3UpdateOutputFormatAvroApacheAvroCompressionCodecSnappy {
    codec: string;
}

export interface GetDestinationS3ConfigurationFormatDestinationS3UpdateOutputFormatAvroApacheAvroCompressionCodecDestinationS3UpdateOutputFormatAvroApacheAvroCompressionCodecXz {
    codec: string;
    compressionLevel: number;
}

export interface GetDestinationS3ConfigurationFormatDestinationS3UpdateOutputFormatAvroApacheAvroCompressionCodecDestinationS3UpdateOutputFormatAvroApacheAvroCompressionCodecZstandard {
    codec: string;
    compressionLevel: number;
    includeChecksum: boolean;
}

export interface GetDestinationS3ConfigurationFormatDestinationS3UpdateOutputFormatCsvCommaSeparatedValues {
    compression: outputs.GetDestinationS3ConfigurationFormatDestinationS3UpdateOutputFormatCsvCommaSeparatedValuesCompression;
    flattening: string;
    formatType: string;
}

export interface GetDestinationS3ConfigurationFormatDestinationS3UpdateOutputFormatCsvCommaSeparatedValuesCompression {
    destinationS3UpdateOutputFormatCsvCommaSeparatedValuesCompressionGzip: outputs.GetDestinationS3ConfigurationFormatDestinationS3UpdateOutputFormatCsvCommaSeparatedValuesCompressionDestinationS3UpdateOutputFormatCsvCommaSeparatedValuesCompressionGzip;
    destinationS3UpdateOutputFormatCsvCommaSeparatedValuesCompressionNoCompression: outputs.GetDestinationS3ConfigurationFormatDestinationS3UpdateOutputFormatCsvCommaSeparatedValuesCompressionDestinationS3UpdateOutputFormatCsvCommaSeparatedValuesCompressionNoCompression;
}

export interface GetDestinationS3ConfigurationFormatDestinationS3UpdateOutputFormatCsvCommaSeparatedValuesCompressionDestinationS3UpdateOutputFormatCsvCommaSeparatedValuesCompressionGzip {
    compressionType: string;
}

export interface GetDestinationS3ConfigurationFormatDestinationS3UpdateOutputFormatCsvCommaSeparatedValuesCompressionDestinationS3UpdateOutputFormatCsvCommaSeparatedValuesCompressionNoCompression {
    compressionType: string;
}

export interface GetDestinationS3ConfigurationFormatDestinationS3UpdateOutputFormatJsonLinesNewlineDelimitedJson {
    compression: outputs.GetDestinationS3ConfigurationFormatDestinationS3UpdateOutputFormatJsonLinesNewlineDelimitedJsonCompression;
    flattening: string;
    formatType: string;
}

export interface GetDestinationS3ConfigurationFormatDestinationS3UpdateOutputFormatJsonLinesNewlineDelimitedJsonCompression {
    destinationS3UpdateOutputFormatJsonLinesNewlineDelimitedJsonCompressionGzip: outputs.GetDestinationS3ConfigurationFormatDestinationS3UpdateOutputFormatJsonLinesNewlineDelimitedJsonCompressionDestinationS3UpdateOutputFormatJsonLinesNewlineDelimitedJsonCompressionGzip;
    destinationS3UpdateOutputFormatJsonLinesNewlineDelimitedJsonCompressionNoCompression: outputs.GetDestinationS3ConfigurationFormatDestinationS3UpdateOutputFormatJsonLinesNewlineDelimitedJsonCompressionDestinationS3UpdateOutputFormatJsonLinesNewlineDelimitedJsonCompressionNoCompression;
}

export interface GetDestinationS3ConfigurationFormatDestinationS3UpdateOutputFormatJsonLinesNewlineDelimitedJsonCompressionDestinationS3UpdateOutputFormatJsonLinesNewlineDelimitedJsonCompressionGzip {
    compressionType: string;
}

export interface GetDestinationS3ConfigurationFormatDestinationS3UpdateOutputFormatJsonLinesNewlineDelimitedJsonCompressionDestinationS3UpdateOutputFormatJsonLinesNewlineDelimitedJsonCompressionNoCompression {
    compressionType: string;
}

export interface GetDestinationS3ConfigurationFormatDestinationS3UpdateOutputFormatParquetColumnarStorage {
    blockSizeMb: number;
    compressionCodec: string;
    dictionaryEncoding: boolean;
    dictionaryPageSizeKb: number;
    formatType: string;
    maxPaddingSizeMb: number;
    pageSizeKb: number;
}

export interface GetDestinationS3GlueConfiguration {
    /**
     * The access key ID to access the S3 bucket. Airbyte requires Read and Write permissions to the given bucket. Read more \n\nhere\n\n.
     */
    accessKeyId: string;
    /**
     * must be one of ["s3-glue"]
     */
    destinationType: string;
    /**
     * The pattern allows you to set the file-name format for the S3 staging file(s)
     */
    fileNamePattern: string;
    /**
     * Format of the data output. See \n\nhere\n\n for more details
     */
    format: outputs.GetDestinationS3GlueConfigurationFormat;
    /**
     * Name of the glue database for creating the tables, leave blank if no integration
     */
    glueDatabase: string;
    /**
     * must be one of ["org.openx.data.jsonserde.JsonSerDe", "org.apache.hive.hcatalog.data.JsonSerDe"]
     * The library that your query engine will use for reading and writing data in your lake.
     */
    glueSerializationLibrary: string;
    /**
     * The name of the S3 bucket. Read more \n\nhere\n\n.
     */
    s3BucketName: string;
    /**
     * Directory under the S3 bucket where data will be written. Read more \n\nhere\n\n
     */
    s3BucketPath: string;
    /**
     * must be one of ["", "us-east-1", "us-east-2", "us-west-1", "us-west-2", "af-south-1", "ap-east-1", "ap-south-1", "ap-northeast-1", "ap-northeast-2", "ap-northeast-3", "ap-southeast-1", "ap-southeast-2", "ca-central-1", "cn-north-1", "cn-northwest-1", "eu-central-1", "eu-north-1", "eu-south-1", "eu-west-1", "eu-west-2", "eu-west-3", "sa-east-1", "me-south-1", "us-gov-east-1", "us-gov-west-1"]
     * The region of the S3 bucket. See \n\nhere\n\n for all region codes.
     */
    s3BucketRegion: string;
    /**
     * Your S3 endpoint url. Read more \n\nhere\n\n
     */
    s3Endpoint: string;
    /**
     * Format string on how data will be organized inside the S3 bucket directory. Read more \n\nhere\n\n
     */
    s3PathFormat: string;
    /**
     * The corresponding secret to the access key ID. Read more \n\nhere\n\n
     */
    secretAccessKey: string;
}

export interface GetDestinationS3GlueConfigurationFormat {
    destinationS3GlueOutputFormatJsonLinesNewlineDelimitedJson: outputs.GetDestinationS3GlueConfigurationFormatDestinationS3GlueOutputFormatJsonLinesNewlineDelimitedJson;
    destinationS3GlueUpdateOutputFormatJsonLinesNewlineDelimitedJson: outputs.GetDestinationS3GlueConfigurationFormatDestinationS3GlueUpdateOutputFormatJsonLinesNewlineDelimitedJson;
}

export interface GetDestinationS3GlueConfigurationFormatDestinationS3GlueOutputFormatJsonLinesNewlineDelimitedJson {
    compression: outputs.GetDestinationS3GlueConfigurationFormatDestinationS3GlueOutputFormatJsonLinesNewlineDelimitedJsonCompression;
    flattening: string;
    formatType: string;
}

export interface GetDestinationS3GlueConfigurationFormatDestinationS3GlueOutputFormatJsonLinesNewlineDelimitedJsonCompression {
    destinationS3GlueOutputFormatJsonLinesNewlineDelimitedJsonCompressionGzip: outputs.GetDestinationS3GlueConfigurationFormatDestinationS3GlueOutputFormatJsonLinesNewlineDelimitedJsonCompressionDestinationS3GlueOutputFormatJsonLinesNewlineDelimitedJsonCompressionGzip;
    destinationS3GlueOutputFormatJsonLinesNewlineDelimitedJsonCompressionNoCompression: outputs.GetDestinationS3GlueConfigurationFormatDestinationS3GlueOutputFormatJsonLinesNewlineDelimitedJsonCompressionDestinationS3GlueOutputFormatJsonLinesNewlineDelimitedJsonCompressionNoCompression;
}

export interface GetDestinationS3GlueConfigurationFormatDestinationS3GlueOutputFormatJsonLinesNewlineDelimitedJsonCompressionDestinationS3GlueOutputFormatJsonLinesNewlineDelimitedJsonCompressionGzip {
    compressionType: string;
}

export interface GetDestinationS3GlueConfigurationFormatDestinationS3GlueOutputFormatJsonLinesNewlineDelimitedJsonCompressionDestinationS3GlueOutputFormatJsonLinesNewlineDelimitedJsonCompressionNoCompression {
    compressionType: string;
}

export interface GetDestinationS3GlueConfigurationFormatDestinationS3GlueUpdateOutputFormatJsonLinesNewlineDelimitedJson {
    compression: outputs.GetDestinationS3GlueConfigurationFormatDestinationS3GlueUpdateOutputFormatJsonLinesNewlineDelimitedJsonCompression;
    flattening: string;
    formatType: string;
}

export interface GetDestinationS3GlueConfigurationFormatDestinationS3GlueUpdateOutputFormatJsonLinesNewlineDelimitedJsonCompression {
    destinationS3GlueUpdateOutputFormatJsonLinesNewlineDelimitedJsonCompressionGzip: outputs.GetDestinationS3GlueConfigurationFormatDestinationS3GlueUpdateOutputFormatJsonLinesNewlineDelimitedJsonCompressionDestinationS3GlueUpdateOutputFormatJsonLinesNewlineDelimitedJsonCompressionGzip;
    destinationS3GlueUpdateOutputFormatJsonLinesNewlineDelimitedJsonCompressionNoCompression: outputs.GetDestinationS3GlueConfigurationFormatDestinationS3GlueUpdateOutputFormatJsonLinesNewlineDelimitedJsonCompressionDestinationS3GlueUpdateOutputFormatJsonLinesNewlineDelimitedJsonCompressionNoCompression;
}

export interface GetDestinationS3GlueConfigurationFormatDestinationS3GlueUpdateOutputFormatJsonLinesNewlineDelimitedJsonCompressionDestinationS3GlueUpdateOutputFormatJsonLinesNewlineDelimitedJsonCompressionGzip {
    compressionType: string;
}

export interface GetDestinationS3GlueConfigurationFormatDestinationS3GlueUpdateOutputFormatJsonLinesNewlineDelimitedJsonCompressionDestinationS3GlueUpdateOutputFormatJsonLinesNewlineDelimitedJsonCompressionNoCompression {
    compressionType: string;
}

export interface GetDestinationSftpJsonConfiguration {
    /**
     * Path to the directory where json files will be written.
     */
    destinationPath: string;
    /**
     * must be one of ["sftp-json"]
     */
    destinationType: string;
    /**
     * Hostname of the SFTP server.
     */
    host: string;
    /**
     * Password associated with the username.
     */
    password: string;
    /**
     * Port of the SFTP server.
     */
    port: number;
    /**
     * Username to use to access the SFTP server.
     */
    username: string;
}

export interface GetDestinationSnowflakeConfiguration {
    credentials: outputs.GetDestinationSnowflakeConfigurationCredentials;
    /**
     * Enter the name of the \n\ndatabase\n\n you want to sync data into
     */
    database: string;
    /**
     * must be one of ["snowflake"]
     */
    destinationType: string;
    /**
     * Enter your Snowflake account's \n\nlocator\n\n (in the format \n\n.\n\n.\n\n.snowflakecomputing.com)
     */
    host: string;
    /**
     * Enter the additional properties to pass to the JDBC URL string when connecting to the database (formatted as key=value pairs separated by the symbol &). Example: key1=value1&key2=value2&key3=value3
     */
    jdbcUrlParams: string;
    /**
     * (Beta) The schema to write raw tables into
     */
    rawDataSchema: string;
    /**
     * Enter the \n\nrole\n\n that you want to use to access Snowflake
     */
    role: string;
    /**
     * Enter the name of the default \n\nschema\n\n
     */
    schema: string;
    /**
     * (Beta) Use \n\nDestinations V2\n\n. Contact Airbyte Support to participate in the beta program.
     */
    use1s1tFormat: boolean;
    /**
     * Enter the name of the user you want to use to access the database
     */
    username: string;
    /**
     * Enter the name of the \n\nwarehouse\n\n that you want to sync data into
     */
    warehouse: string;
}

export interface GetDestinationSnowflakeConfigurationCredentials {
    destinationSnowflakeAuthorizationMethodKeyPairAuthentication: outputs.GetDestinationSnowflakeConfigurationCredentialsDestinationSnowflakeAuthorizationMethodKeyPairAuthentication;
    destinationSnowflakeAuthorizationMethodOAuth20: outputs.GetDestinationSnowflakeConfigurationCredentialsDestinationSnowflakeAuthorizationMethodOAuth20;
    destinationSnowflakeAuthorizationMethodUsernameAndPassword: outputs.GetDestinationSnowflakeConfigurationCredentialsDestinationSnowflakeAuthorizationMethodUsernameAndPassword;
    destinationSnowflakeUpdateAuthorizationMethodKeyPairAuthentication: outputs.GetDestinationSnowflakeConfigurationCredentialsDestinationSnowflakeUpdateAuthorizationMethodKeyPairAuthentication;
    destinationSnowflakeUpdateAuthorizationMethodOAuth20: outputs.GetDestinationSnowflakeConfigurationCredentialsDestinationSnowflakeUpdateAuthorizationMethodOAuth20;
    destinationSnowflakeUpdateAuthorizationMethodUsernameAndPassword: outputs.GetDestinationSnowflakeConfigurationCredentialsDestinationSnowflakeUpdateAuthorizationMethodUsernameAndPassword;
}

export interface GetDestinationSnowflakeConfigurationCredentialsDestinationSnowflakeAuthorizationMethodKeyPairAuthentication {
    authType: string;
    privateKey: string;
    privateKeyPassword: string;
}

export interface GetDestinationSnowflakeConfigurationCredentialsDestinationSnowflakeAuthorizationMethodOAuth20 {
    accessToken: string;
    authType: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
}

export interface GetDestinationSnowflakeConfigurationCredentialsDestinationSnowflakeAuthorizationMethodUsernameAndPassword {
    authType: string;
    password: string;
}

export interface GetDestinationSnowflakeConfigurationCredentialsDestinationSnowflakeUpdateAuthorizationMethodKeyPairAuthentication {
    authType: string;
    privateKey: string;
    privateKeyPassword: string;
}

export interface GetDestinationSnowflakeConfigurationCredentialsDestinationSnowflakeUpdateAuthorizationMethodOAuth20 {
    accessToken: string;
    authType: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
}

export interface GetDestinationSnowflakeConfigurationCredentialsDestinationSnowflakeUpdateAuthorizationMethodUsernameAndPassword {
    authType: string;
    password: string;
}

export interface GetDestinationTimeplusConfiguration {
    /**
     * Personal API key
     */
    apikey: string;
    /**
     * must be one of ["timeplus"]
     */
    destinationType: string;
    /**
     * Timeplus workspace endpoint
     */
    endpoint: string;
}

export interface GetDestinationTypesenseConfiguration {
    /**
     * Typesense API Key
     */
    apiKey: string;
    /**
     * How many documents should be imported together. Default 1000
     */
    batchSize: string;
    /**
     * must be one of ["typesense"]
     */
    destinationType: string;
    /**
     * Hostname of the Typesense instance without protocol.
     */
    host: string;
    /**
     * Port of the Typesense instance. Ex: 8108, 80, 443. Default is 443
     */
    port: string;
    /**
     * Protocol of the Typesense instance. Ex: http or https. Default is https
     */
    protocol: string;
}

export interface GetDestinationVerticaConfiguration {
    /**
     * Name of the database.
     */
    database: string;
    /**
     * must be one of ["vertica"]
     */
    destinationType: string;
    /**
     * Hostname of the database.
     */
    host: string;
    /**
     * Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
     */
    jdbcUrlParams: string;
    /**
     * Password associated with the username.
     */
    password: string;
    /**
     * Port of the database.
     */
    port: number;
    /**
     * Schema for vertica destination
     */
    schema: string;
    /**
     * Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
     */
    tunnelMethod: outputs.GetDestinationVerticaConfigurationTunnelMethod;
    /**
     * Username to use to access the database.
     */
    username: string;
}

export interface GetDestinationVerticaConfigurationTunnelMethod {
    destinationVerticaSshTunnelMethodNoTunnel: outputs.GetDestinationVerticaConfigurationTunnelMethodDestinationVerticaSshTunnelMethodNoTunnel;
    destinationVerticaSshTunnelMethodPasswordAuthentication: outputs.GetDestinationVerticaConfigurationTunnelMethodDestinationVerticaSshTunnelMethodPasswordAuthentication;
    destinationVerticaSshTunnelMethodSshKeyAuthentication: outputs.GetDestinationVerticaConfigurationTunnelMethodDestinationVerticaSshTunnelMethodSshKeyAuthentication;
    destinationVerticaUpdateSshTunnelMethodNoTunnel: outputs.GetDestinationVerticaConfigurationTunnelMethodDestinationVerticaUpdateSshTunnelMethodNoTunnel;
    destinationVerticaUpdateSshTunnelMethodPasswordAuthentication: outputs.GetDestinationVerticaConfigurationTunnelMethodDestinationVerticaUpdateSshTunnelMethodPasswordAuthentication;
    destinationVerticaUpdateSshTunnelMethodSshKeyAuthentication: outputs.GetDestinationVerticaConfigurationTunnelMethodDestinationVerticaUpdateSshTunnelMethodSshKeyAuthentication;
}

export interface GetDestinationVerticaConfigurationTunnelMethodDestinationVerticaSshTunnelMethodNoTunnel {
    tunnelMethod: string;
}

export interface GetDestinationVerticaConfigurationTunnelMethodDestinationVerticaSshTunnelMethodPasswordAuthentication {
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
    tunnelUserPassword: string;
}

export interface GetDestinationVerticaConfigurationTunnelMethodDestinationVerticaSshTunnelMethodSshKeyAuthentication {
    sshKey: string;
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
}

export interface GetDestinationVerticaConfigurationTunnelMethodDestinationVerticaUpdateSshTunnelMethodNoTunnel {
    tunnelMethod: string;
}

export interface GetDestinationVerticaConfigurationTunnelMethodDestinationVerticaUpdateSshTunnelMethodPasswordAuthentication {
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
    tunnelUserPassword: string;
}

export interface GetDestinationVerticaConfigurationTunnelMethodDestinationVerticaUpdateSshTunnelMethodSshKeyAuthentication {
    sshKey: string;
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
}

export interface GetDestinationXataConfiguration {
    /**
     * API Key to connect.
     */
    apiKey: string;
    /**
     * URL pointing to your workspace.
     */
    dbUrl: string;
    /**
     * must be one of ["xata"]
     */
    destinationType: string;
}

export interface GetSourceAhaConfiguration {
    /**
     * API Key
     */
    apiKey: string;
    /**
     * must be one of ["aha"]
     */
    sourceType: string;
    /**
     * URL
     */
    url: string;
}

export interface GetSourceAircallConfiguration {
    /**
     * App ID found at settings https://dashboard.aircall.io/integrations/api-keys
     */
    apiId: string;
    /**
     * App token found at settings (Ref- https://dashboard.aircall.io/integrations/api-keys)
     */
    apiToken: string;
    /**
     * must be one of ["aircall"]
     */
    sourceType: string;
    /**
     * Date time filter for incremental filter, Specify which date to extract from.
     */
    startDate: string;
}

export interface GetSourceAirtableConfiguration {
    credentials: outputs.GetSourceAirtableConfigurationCredentials;
    /**
     * must be one of ["airtable"]
     */
    sourceType: string;
}

export interface GetSourceAirtableConfigurationCredentials {
    sourceAirtableAuthenticationOAuth20: outputs.GetSourceAirtableConfigurationCredentialsSourceAirtableAuthenticationOAuth20;
    sourceAirtableAuthenticationPersonalAccessToken: outputs.GetSourceAirtableConfigurationCredentialsSourceAirtableAuthenticationPersonalAccessToken;
    sourceAirtableUpdateAuthenticationOAuth20: outputs.GetSourceAirtableConfigurationCredentialsSourceAirtableUpdateAuthenticationOAuth20;
    sourceAirtableUpdateAuthenticationPersonalAccessToken: outputs.GetSourceAirtableConfigurationCredentialsSourceAirtableUpdateAuthenticationPersonalAccessToken;
}

export interface GetSourceAirtableConfigurationCredentialsSourceAirtableAuthenticationOAuth20 {
    accessToken: string;
    authMethod: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
    tokenExpiryDate: string;
}

export interface GetSourceAirtableConfigurationCredentialsSourceAirtableAuthenticationPersonalAccessToken {
    apiKey: string;
    authMethod: string;
}

export interface GetSourceAirtableConfigurationCredentialsSourceAirtableUpdateAuthenticationOAuth20 {
    accessToken: string;
    authMethod: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
    tokenExpiryDate: string;
}

export interface GetSourceAirtableConfigurationCredentialsSourceAirtableUpdateAuthenticationPersonalAccessToken {
    apiKey: string;
    authMethod: string;
}

export interface GetSourceAlloydbConfiguration {
    /**
     * Name of the database.
     */
    database: string;
    /**
     * Hostname of the database.
     */
    host: string;
    /**
     * Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (Eg. key1=value1&key2=value2&key3=value3). For more information read about \n\nJDBC URL parameters\n\n.
     */
    jdbcUrlParams: string;
    /**
     * Password associated with the username.
     */
    password: string;
    /**
     * Port of the database.
     */
    port: number;
    /**
     * Replication method for extracting data from the database.
     */
    replicationMethod: outputs.GetSourceAlloydbConfigurationReplicationMethod;
    /**
     * The list of schemas (case sensitive) to sync from. Defaults to public.
     */
    schemas: string[];
    /**
     * must be one of ["alloydb"]
     */
    sourceType: string;
    /**
     * SSL connection modes.
     * Read more \n\n in the docs\n\n.
     */
    sslMode: outputs.GetSourceAlloydbConfigurationSslMode;
    /**
     * Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
     */
    tunnelMethod: outputs.GetSourceAlloydbConfigurationTunnelMethod;
    /**
     * Username to access the database.
     */
    username: string;
}

export interface GetSourceAlloydbConfigurationReplicationMethod {
    sourceAlloydbReplicationMethodLogicalReplicationCdc: outputs.GetSourceAlloydbConfigurationReplicationMethodSourceAlloydbReplicationMethodLogicalReplicationCdc;
    sourceAlloydbReplicationMethodStandard: outputs.GetSourceAlloydbConfigurationReplicationMethodSourceAlloydbReplicationMethodStandard;
    sourceAlloydbReplicationMethodStandardXmin: outputs.GetSourceAlloydbConfigurationReplicationMethodSourceAlloydbReplicationMethodStandardXmin;
    sourceAlloydbUpdateReplicationMethodLogicalReplicationCdc: outputs.GetSourceAlloydbConfigurationReplicationMethodSourceAlloydbUpdateReplicationMethodLogicalReplicationCdc;
    sourceAlloydbUpdateReplicationMethodStandard: outputs.GetSourceAlloydbConfigurationReplicationMethodSourceAlloydbUpdateReplicationMethodStandard;
    sourceAlloydbUpdateReplicationMethodStandardXmin: outputs.GetSourceAlloydbConfigurationReplicationMethodSourceAlloydbUpdateReplicationMethodStandardXmin;
}

export interface GetSourceAlloydbConfigurationReplicationMethodSourceAlloydbReplicationMethodLogicalReplicationCdc {
    additionalProperties?: string;
    initialWaitingSeconds: number;
    lsnCommitBehaviour: string;
    method: string;
    plugin: string;
    publication: string;
    queueSize: number;
    replicationSlot: string;
}

export interface GetSourceAlloydbConfigurationReplicationMethodSourceAlloydbReplicationMethodStandard {
    method: string;
}

export interface GetSourceAlloydbConfigurationReplicationMethodSourceAlloydbReplicationMethodStandardXmin {
    method: string;
}

export interface GetSourceAlloydbConfigurationReplicationMethodSourceAlloydbUpdateReplicationMethodLogicalReplicationCdc {
    additionalProperties?: string;
    initialWaitingSeconds: number;
    lsnCommitBehaviour: string;
    method: string;
    plugin: string;
    publication: string;
    queueSize: number;
    replicationSlot: string;
}

export interface GetSourceAlloydbConfigurationReplicationMethodSourceAlloydbUpdateReplicationMethodStandard {
    method: string;
}

export interface GetSourceAlloydbConfigurationReplicationMethodSourceAlloydbUpdateReplicationMethodStandardXmin {
    method: string;
}

export interface GetSourceAlloydbConfigurationSslMode {
    sourceAlloydbSslModesAllow: outputs.GetSourceAlloydbConfigurationSslModeSourceAlloydbSslModesAllow;
    sourceAlloydbSslModesDisable: outputs.GetSourceAlloydbConfigurationSslModeSourceAlloydbSslModesDisable;
    sourceAlloydbSslModesPrefer: outputs.GetSourceAlloydbConfigurationSslModeSourceAlloydbSslModesPrefer;
    sourceAlloydbSslModesRequire: outputs.GetSourceAlloydbConfigurationSslModeSourceAlloydbSslModesRequire;
    sourceAlloydbSslModesVerifyCa: outputs.GetSourceAlloydbConfigurationSslModeSourceAlloydbSslModesVerifyCa;
    sourceAlloydbSslModesVerifyFull: outputs.GetSourceAlloydbConfigurationSslModeSourceAlloydbSslModesVerifyFull;
    sourceAlloydbUpdateSslModesAllow: outputs.GetSourceAlloydbConfigurationSslModeSourceAlloydbUpdateSslModesAllow;
    sourceAlloydbUpdateSslModesDisable: outputs.GetSourceAlloydbConfigurationSslModeSourceAlloydbUpdateSslModesDisable;
    sourceAlloydbUpdateSslModesPrefer: outputs.GetSourceAlloydbConfigurationSslModeSourceAlloydbUpdateSslModesPrefer;
    sourceAlloydbUpdateSslModesRequire: outputs.GetSourceAlloydbConfigurationSslModeSourceAlloydbUpdateSslModesRequire;
    sourceAlloydbUpdateSslModesVerifyCa: outputs.GetSourceAlloydbConfigurationSslModeSourceAlloydbUpdateSslModesVerifyCa;
    sourceAlloydbUpdateSslModesVerifyFull: outputs.GetSourceAlloydbConfigurationSslModeSourceAlloydbUpdateSslModesVerifyFull;
}

export interface GetSourceAlloydbConfigurationSslModeSourceAlloydbSslModesAllow {
    additionalProperties?: string;
    mode: string;
}

export interface GetSourceAlloydbConfigurationSslModeSourceAlloydbSslModesDisable {
    additionalProperties?: string;
    mode: string;
}

export interface GetSourceAlloydbConfigurationSslModeSourceAlloydbSslModesPrefer {
    additionalProperties?: string;
    mode: string;
}

export interface GetSourceAlloydbConfigurationSslModeSourceAlloydbSslModesRequire {
    additionalProperties?: string;
    mode: string;
}

export interface GetSourceAlloydbConfigurationSslModeSourceAlloydbSslModesVerifyCa {
    additionalProperties?: string;
    caCertificate: string;
    clientCertificate: string;
    clientKey: string;
    clientKeyPassword: string;
    mode: string;
}

export interface GetSourceAlloydbConfigurationSslModeSourceAlloydbSslModesVerifyFull {
    additionalProperties?: string;
    caCertificate: string;
    clientCertificate: string;
    clientKey: string;
    clientKeyPassword: string;
    mode: string;
}

export interface GetSourceAlloydbConfigurationSslModeSourceAlloydbUpdateSslModesAllow {
    additionalProperties?: string;
    mode: string;
}

export interface GetSourceAlloydbConfigurationSslModeSourceAlloydbUpdateSslModesDisable {
    additionalProperties?: string;
    mode: string;
}

export interface GetSourceAlloydbConfigurationSslModeSourceAlloydbUpdateSslModesPrefer {
    additionalProperties?: string;
    mode: string;
}

export interface GetSourceAlloydbConfigurationSslModeSourceAlloydbUpdateSslModesRequire {
    additionalProperties?: string;
    mode: string;
}

export interface GetSourceAlloydbConfigurationSslModeSourceAlloydbUpdateSslModesVerifyCa {
    additionalProperties?: string;
    caCertificate: string;
    clientCertificate: string;
    clientKey: string;
    clientKeyPassword: string;
    mode: string;
}

export interface GetSourceAlloydbConfigurationSslModeSourceAlloydbUpdateSslModesVerifyFull {
    additionalProperties?: string;
    caCertificate: string;
    clientCertificate: string;
    clientKey: string;
    clientKeyPassword: string;
    mode: string;
}

export interface GetSourceAlloydbConfigurationTunnelMethod {
    sourceAlloydbSshTunnelMethodNoTunnel: outputs.GetSourceAlloydbConfigurationTunnelMethodSourceAlloydbSshTunnelMethodNoTunnel;
    sourceAlloydbSshTunnelMethodPasswordAuthentication: outputs.GetSourceAlloydbConfigurationTunnelMethodSourceAlloydbSshTunnelMethodPasswordAuthentication;
    sourceAlloydbSshTunnelMethodSshKeyAuthentication: outputs.GetSourceAlloydbConfigurationTunnelMethodSourceAlloydbSshTunnelMethodSshKeyAuthentication;
    sourceAlloydbUpdateSshTunnelMethodNoTunnel: outputs.GetSourceAlloydbConfigurationTunnelMethodSourceAlloydbUpdateSshTunnelMethodNoTunnel;
    sourceAlloydbUpdateSshTunnelMethodPasswordAuthentication: outputs.GetSourceAlloydbConfigurationTunnelMethodSourceAlloydbUpdateSshTunnelMethodPasswordAuthentication;
    sourceAlloydbUpdateSshTunnelMethodSshKeyAuthentication: outputs.GetSourceAlloydbConfigurationTunnelMethodSourceAlloydbUpdateSshTunnelMethodSshKeyAuthentication;
}

export interface GetSourceAlloydbConfigurationTunnelMethodSourceAlloydbSshTunnelMethodNoTunnel {
    tunnelMethod: string;
}

export interface GetSourceAlloydbConfigurationTunnelMethodSourceAlloydbSshTunnelMethodPasswordAuthentication {
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
    tunnelUserPassword: string;
}

export interface GetSourceAlloydbConfigurationTunnelMethodSourceAlloydbSshTunnelMethodSshKeyAuthentication {
    sshKey: string;
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
}

export interface GetSourceAlloydbConfigurationTunnelMethodSourceAlloydbUpdateSshTunnelMethodNoTunnel {
    tunnelMethod: string;
}

export interface GetSourceAlloydbConfigurationTunnelMethodSourceAlloydbUpdateSshTunnelMethodPasswordAuthentication {
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
    tunnelUserPassword: string;
}

export interface GetSourceAlloydbConfigurationTunnelMethodSourceAlloydbUpdateSshTunnelMethodSshKeyAuthentication {
    sshKey: string;
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
}

export interface GetSourceAmazonAdsConfiguration {
    /**
     * must be one of ["oauth2.0"]
     */
    authType: string;
    /**
     * The client ID of your Amazon Ads developer application. See the \n\ndocs\n\n for more information.
     */
    clientId: string;
    /**
     * The client secret of your Amazon Ads developer application. See the \n\ndocs\n\n for more information.
     */
    clientSecret: string;
    /**
     * The amount of days to go back in time to get the updated data from Amazon Ads
     */
    lookBackWindow: number;
    /**
     * Profile IDs you want to fetch data for. See \n\ndocs\n\n for more details.
     */
    profiles: number[];
    /**
     * Amazon Ads refresh token. See the \n\ndocs\n\n for more information on how to obtain this token.
     */
    refreshToken: string;
    /**
     * must be one of ["NA", "EU", "FE"]
     * Region to pull data from (EU/NA/FE). See \n\ndocs\n\n for more details.
     */
    region: string;
    /**
     * Optional configuration which accepts an array of string of record types. Leave blank for default behaviour to pull all report types. Use this config option only if you want to pull specific report type(s). See \n\ndocs\n\n for more details
     */
    reportRecordTypes: string[];
    /**
     * must be one of ["amazon-ads"]
     */
    sourceType: string;
    /**
     * The Start date for collecting reports, should not be more than 60 days in the past. In YYYY-MM-DD format
     */
    startDate: string;
    /**
     * Reflects the state of the Display, Product, and Brand Campaign streams as enabled, paused, or archived. If you do not populate this field, it will be ignored completely.
     */
    stateFilters: string[];
}

export interface GetSourceAmazonSellerPartnerConfiguration {
    /**
     * Additional information to configure report options. This varies by report type, not every report implement this kind of feature. Must be a valid json string.
     */
    advancedStreamOptions: string;
    /**
     * must be one of ["oauth2.0"]
     */
    authType: string;
    /**
     * Specifies the AWS access key used as part of the credentials to authenticate the user.
     */
    awsAccessKey: string;
    /**
     * must be one of ["PRODUCTION", "SANDBOX"]
     * Select the AWS Environment.
     */
    awsEnvironment: string;
    /**
     * Specifies the AWS secret key used as part of the credentials to authenticate the user.
     */
    awsSecretKey: string;
    /**
     * Your Login with Amazon Client ID.
     */
    lwaAppId: string;
    /**
     * Your Login with Amazon Client Secret.
     */
    lwaClientSecret: string;
    /**
     * Sometimes report can take up to 30 minutes to generate. This will set the limit for how long to wait for a successful report.
     */
    maxWaitSeconds: number;
    /**
     * Will be used for stream slicing for initial fullRefresh sync when no updated state is present for reports that support sliced incremental sync.
     */
    periodInDays: number;
    /**
     * The Refresh Token obtained via OAuth flow authorization.
     */
    refreshToken: string;
    /**
     * must be one of ["AE", "AU", "BE", "BR", "CA", "DE", "EG", "ES", "FR", "GB", "IN", "IT", "JP", "MX", "NL", "PL", "SA", "SE", "SG", "TR", "UK", "US"]
     * Select the AWS Region.
     */
    region: string;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Any data after this date will not be replicated.
     */
    replicationEndDate: string;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
     */
    replicationStartDate: string;
    /**
     * Additional information passed to reports. This varies by report type. Must be a valid json string.
     */
    reportOptions: string;
    /**
     * Specifies the Amazon Resource Name (ARN) of an IAM role that you want to use to perform operations requested using this profile. (Needs permission to 'Assume Role' STS).
     */
    roleArn: string;
    /**
     * must be one of ["amazon-seller-partner"]
     */
    sourceType: string;
}

export interface GetSourceAmazonSqsConfiguration {
    /**
     * The Access Key ID of the AWS IAM Role to use for pulling messages
     */
    accessKey: string;
    /**
     * Comma separated list of Mesage Attribute names to return
     */
    attributesToReturn: string;
    /**
     * If Enabled, messages will be deleted from the SQS Queue after being read. If Disabled, messages are left in the queue and can be read more than once. WARNING: Enabling this option can result in data loss in cases of failure, use with caution, see documentation for more detail.
     */
    deleteMessages: boolean;
    /**
     * Max amount of messages to get in one batch (10 max)
     */
    maxBatchSize: number;
    /**
     * Max amount of time in seconds to wait for messages in a single poll (20 max)
     */
    maxWaitTime: number;
    /**
     * URL of the SQS Queue
     */
    queueUrl: string;
    /**
     * must be one of ["us-east-1", "us-east-2", "us-west-1", "us-west-2", "af-south-1", "ap-east-1", "ap-south-1", "ap-northeast-1", "ap-northeast-2", "ap-northeast-3", "ap-southeast-1", "ap-southeast-2", "ca-central-1", "cn-north-1", "cn-northwest-1", "eu-central-1", "eu-north-1", "eu-south-1", "eu-west-1", "eu-west-2", "eu-west-3", "sa-east-1", "me-south-1", "us-gov-east-1", "us-gov-west-1"]
     * AWS Region of the SQS Queue
     */
    region: string;
    /**
     * The Secret Key of the AWS IAM Role to use for pulling messages
     */
    secretKey: string;
    /**
     * must be one of ["amazon-sqs"]
     */
    sourceType: string;
    /**
     * Modify the Visibility Timeout of the individual message from the Queue's default (seconds).
     */
    visibilityTimeout: number;
}

export interface GetSourceAmplitudeConfiguration {
    /**
     * Amplitude API Key. See the \n\nsetup guide\n\n for more information on how to obtain this key.
     */
    apiKey: string;
    /**
     * must be one of ["Standard Server", "EU Residency Server"]
     * Amplitude data region server
     */
    dataRegion: string;
    /**
     * According to \n\nConsiderations\n\n too big time range in request can cause a timeout error. In this case, set shorter time interval in hours.
     */
    requestTimeRange: number;
    /**
     * Amplitude Secret Key. See the \n\nsetup guide\n\n for more information on how to obtain this key.
     */
    secretKey: string;
    /**
     * must be one of ["amplitude"]
     */
    sourceType: string;
    /**
     * UTC date and time in the format 2021-01-25T00:00:00Z. Any data before this date will not be replicated.
     */
    startDate: string;
}

export interface GetSourceApifyDatasetConfiguration {
    /**
     * If set to true, only clean items will be downloaded from the dataset. See description of what clean means in \n\nApify API docs\n\n. If not sure, set clean to false.
     */
    clean: boolean;
    /**
     * ID of the dataset you would like to load to Airbyte.
     */
    datasetId: string;
    /**
     * must be one of ["apify-dataset"]
     */
    sourceType: string;
}

export interface GetSourceAppfollowConfiguration {
    /**
     * API Key provided by Appfollow
     */
    apiSecret: string;
    /**
     * must be one of ["appfollow"]
     */
    sourceType: string;
}

export interface GetSourceAsanaConfiguration {
    /**
     * Choose how to authenticate to Github
     */
    credentials: outputs.GetSourceAsanaConfigurationCredentials;
    /**
     * must be one of ["asana"]
     */
    sourceType: string;
}

export interface GetSourceAsanaConfigurationCredentials {
    sourceAsanaAuthenticationMechanismAuthenticateViaAsanaOauth: outputs.GetSourceAsanaConfigurationCredentialsSourceAsanaAuthenticationMechanismAuthenticateViaAsanaOauth;
    sourceAsanaAuthenticationMechanismAuthenticateWithPersonalAccessToken: outputs.GetSourceAsanaConfigurationCredentialsSourceAsanaAuthenticationMechanismAuthenticateWithPersonalAccessToken;
    sourceAsanaUpdateAuthenticationMechanismAuthenticateViaAsanaOauth: outputs.GetSourceAsanaConfigurationCredentialsSourceAsanaUpdateAuthenticationMechanismAuthenticateViaAsanaOauth;
    sourceAsanaUpdateAuthenticationMechanismAuthenticateWithPersonalAccessToken: outputs.GetSourceAsanaConfigurationCredentialsSourceAsanaUpdateAuthenticationMechanismAuthenticateWithPersonalAccessToken;
}

export interface GetSourceAsanaConfigurationCredentialsSourceAsanaAuthenticationMechanismAuthenticateViaAsanaOauth {
    clientId: string;
    clientSecret: string;
    optionTitle: string;
    refreshToken: string;
}

export interface GetSourceAsanaConfigurationCredentialsSourceAsanaAuthenticationMechanismAuthenticateWithPersonalAccessToken {
    optionTitle: string;
    personalAccessToken: string;
}

export interface GetSourceAsanaConfigurationCredentialsSourceAsanaUpdateAuthenticationMechanismAuthenticateViaAsanaOauth {
    clientId: string;
    clientSecret: string;
    optionTitle: string;
    refreshToken: string;
}

export interface GetSourceAsanaConfigurationCredentialsSourceAsanaUpdateAuthenticationMechanismAuthenticateWithPersonalAccessToken {
    optionTitle: string;
    personalAccessToken: string;
}

export interface GetSourceAuth0Configuration {
    /**
     * The Authentication API is served over HTTPS. All URLs referenced in the documentation have the following base `https://YOUR_DOMAIN`
     */
    baseUrl: string;
    credentials: outputs.GetSourceAuth0ConfigurationCredentials;
    /**
     * must be one of ["auth0"]
     */
    sourceType: string;
}

export interface GetSourceAuth0ConfigurationCredentials {
    sourceAuth0AuthenticationMethodOAuth2AccessToken: outputs.GetSourceAuth0ConfigurationCredentialsSourceAuth0AuthenticationMethodOAuth2AccessToken;
    sourceAuth0AuthenticationMethodOAuth2ConfidentialApplication: outputs.GetSourceAuth0ConfigurationCredentialsSourceAuth0AuthenticationMethodOAuth2ConfidentialApplication;
    sourceAuth0UpdateAuthenticationMethodOAuth2AccessToken: outputs.GetSourceAuth0ConfigurationCredentialsSourceAuth0UpdateAuthenticationMethodOAuth2AccessToken;
    sourceAuth0UpdateAuthenticationMethodOAuth2ConfidentialApplication: outputs.GetSourceAuth0ConfigurationCredentialsSourceAuth0UpdateAuthenticationMethodOAuth2ConfidentialApplication;
}

export interface GetSourceAuth0ConfigurationCredentialsSourceAuth0AuthenticationMethodOAuth2AccessToken {
    accessToken: string;
    authType: string;
}

export interface GetSourceAuth0ConfigurationCredentialsSourceAuth0AuthenticationMethodOAuth2ConfidentialApplication {
    audience: string;
    authType: string;
    clientId: string;
    clientSecret: string;
}

export interface GetSourceAuth0ConfigurationCredentialsSourceAuth0UpdateAuthenticationMethodOAuth2AccessToken {
    accessToken: string;
    authType: string;
}

export interface GetSourceAuth0ConfigurationCredentialsSourceAuth0UpdateAuthenticationMethodOAuth2ConfidentialApplication {
    audience: string;
    authType: string;
    clientId: string;
    clientSecret: string;
}

export interface GetSourceAwsCloudtrailConfiguration {
    /**
     * AWS CloudTrail Access Key ID. See the \n\ndocs\n\n for more information on how to obtain this key.
     */
    awsKeyId: string;
    /**
     * The default AWS Region to use, for example, us-west-1 or us-west-2. When specifying a Region inline during client initialization, this property is named region_name.
     */
    awsRegionName: string;
    /**
     * AWS CloudTrail Access Key ID. See the \n\ndocs\n\n for more information on how to obtain this key.
     */
    awsSecretKey: string;
    /**
     * must be one of ["aws-cloudtrail"]
     */
    sourceType: string;
    /**
     * The date you would like to replicate data. Data in AWS CloudTrail is available for last 90 days only. Format: YYYY-MM-DD.
     */
    startDate: string;
}

export interface GetSourceAzureBlobStorageConfiguration {
    /**
     * The Azure blob storage account key.
     */
    azureBlobStorageAccountKey: string;
    /**
     * The account's name of the Azure Blob Storage.
     */
    azureBlobStorageAccountName: string;
    /**
     * The Azure blob storage prefix to be applied
     */
    azureBlobStorageBlobsPrefix: string;
    /**
     * The name of the Azure blob storage container.
     */
    azureBlobStorageContainerName: string;
    /**
     * This is Azure Blob Storage endpoint domain name. Leave default value (or leave it empty if run container from command line) to use Microsoft native from example.
     */
    azureBlobStorageEndpoint: string;
    /**
     * The Azure blob storage blobs to scan for inferring the schema, useful on large amounts of data with consistent structure
     */
    azureBlobStorageSchemaInferenceLimit: number;
    /**
     * Input data format
     */
    format: outputs.GetSourceAzureBlobStorageConfigurationFormat;
    /**
     * must be one of ["azure-blob-storage"]
     */
    sourceType: string;
}

export interface GetSourceAzureBlobStorageConfigurationFormat {
    sourceAzureBlobStorageInputFormatJsonLinesNewlineDelimitedJson: outputs.GetSourceAzureBlobStorageConfigurationFormatSourceAzureBlobStorageInputFormatJsonLinesNewlineDelimitedJson;
    sourceAzureBlobStorageUpdateInputFormatJsonLinesNewlineDelimitedJson: outputs.GetSourceAzureBlobStorageConfigurationFormatSourceAzureBlobStorageUpdateInputFormatJsonLinesNewlineDelimitedJson;
}

export interface GetSourceAzureBlobStorageConfigurationFormatSourceAzureBlobStorageInputFormatJsonLinesNewlineDelimitedJson {
    formatType: string;
}

export interface GetSourceAzureBlobStorageConfigurationFormatSourceAzureBlobStorageUpdateInputFormatJsonLinesNewlineDelimitedJson {
    formatType: string;
}

export interface GetSourceAzureTableConfiguration {
    /**
     * must be one of ["azure-table"]
     */
    sourceType: string;
    /**
     * Azure Table Storage Access Key. See the \n\ndocs\n\n for more information on how to obtain this key.
     */
    storageAccessKey: string;
    /**
     * The name of your storage account.
     */
    storageAccountName: string;
    /**
     * Azure Table Storage service account URL suffix. See the \n\ndocs\n\n for more information on how to obtain endpoint suffix
     */
    storageEndpointSuffix: string;
}

export interface GetSourceBambooHrConfiguration {
    /**
     * Api key of bamboo hr
     */
    apiKey: string;
    /**
     * Comma-separated list of fields to include in custom reports.
     */
    customReportsFields: string;
    /**
     * If true, the custom reports endpoint will include the default fields defined here: https://documentation.bamboohr.com/docs/list-of-field-names.
     */
    customReportsIncludeDefaultFields: boolean;
    /**
     * must be one of ["bamboo-hr"]
     */
    sourceType: string;
    /**
     * Sub Domain of bamboo hr
     */
    subdomain: string;
}

export interface GetSourceBigcommerceConfiguration {
    /**
     * Access Token for making authenticated requests.
     */
    accessToken: string;
    /**
     * must be one of ["bigcommerce"]
     */
    sourceType: string;
    /**
     * The date you would like to replicate data. Format: YYYY-MM-DD.
     */
    startDate: string;
    /**
     * The hash code of the store. For https://api.bigcommerce.com/stores/HASH*CODE/v3/, The store's hash code is 'HASH*CODE'.
     */
    storeHash: string;
}

export interface GetSourceBigqueryConfiguration {
    /**
     * The contents of your Service Account Key JSON file. See the \n\ndocs\n\n for more information on how to obtain this key.
     */
    credentialsJson: string;
    /**
     * The dataset ID to search for tables and views. If you are only loading data from one dataset, setting this option could result in much faster schema discovery.
     */
    datasetId: string;
    /**
     * The GCP project ID for the project containing the target BigQuery dataset.
     */
    projectId: string;
    /**
     * must be one of ["bigquery"]
     */
    sourceType: string;
}

export interface GetSourceBingAdsConfiguration {
    /**
     * must be one of ["oauth2.0"]
     */
    authMethod: string;
    /**
     * The Client ID of your Microsoft Advertising developer application.
     */
    clientId: string;
    /**
     * The Client Secret of your Microsoft Advertising developer application.
     */
    clientSecret: string;
    /**
     * Developer token associated with user. See more info \n\n in the docs\n\n.
     */
    developerToken: string;
    /**
     * Also known as attribution or conversion window. How far into the past to look for records (in days). If your conversion window has an hours/minutes granularity, round it up to the number of days exceeding. Used only for performance report streams in incremental mode.
     */
    lookbackWindow: number;
    /**
     * Refresh Token to renew the expired Access Token.
     */
    refreshToken: string;
    /**
     * The start date from which to begin replicating report data. Any data generated before this date will not be replicated in reports. This is a UTC date in YYYY-MM-DD format.
     */
    reportsStartDate: string;
    /**
     * must be one of ["bing-ads"]
     */
    sourceType: string;
    /**
     * The Tenant ID of your Microsoft Advertising developer application. Set this to "common" unless you know you need a different value.
     */
    tenantId: string;
}

export interface GetSourceBraintreeConfiguration {
    /**
     * must be one of ["Development", "Sandbox", "Qa", "Production"]
     * Environment specifies where the data will come from.
     */
    environment: string;
    /**
     * The unique identifier for your entire gateway account. See the \n\ndocs\n\n for more information on how to obtain this ID.
     */
    merchantId: string;
    /**
     * Braintree Private Key. See the \n\ndocs\n\n for more information on how to obtain this key.
     */
    privateKey: string;
    /**
     * Braintree Public Key. See the \n\ndocs\n\n for more information on how to obtain this key.
     */
    publicKey: string;
    /**
     * must be one of ["braintree"]
     */
    sourceType: string;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
     */
    startDate: string;
}

export interface GetSourceBrazeConfiguration {
    /**
     * Braze REST API key
     */
    apiKey: string;
    /**
     * must be one of ["braze"]
     */
    sourceType: string;
    /**
     * Rows after this date will be synced
     */
    startDate: string;
    /**
     * Braze REST API endpoint
     */
    url: string;
}

export interface GetSourceChargebeeConfiguration {
    /**
     * must be one of ["1.0", "2.0"]
     * Product Catalog version of your Chargebee site. Instructions on how to find your version you may find \n\nhere\n\n under `API Version` section.
     */
    productCatalog: string;
    /**
     * The site prefix for your Chargebee instance.
     */
    site: string;
    /**
     * Chargebee API Key. See the \n\ndocs\n\n for more information on how to obtain this key.
     */
    siteApiKey: string;
    /**
     * must be one of ["chargebee"]
     */
    sourceType: string;
    /**
     * UTC date and time in the format 2021-01-25T00:00:00Z. Any data before this date will not be replicated.
     */
    startDate: string;
}

export interface GetSourceChartmogulConfiguration {
    /**
     * Your Chartmogul API key. See \n\n the docs \n\n for info on how to obtain this.
     */
    apiKey: string;
    /**
     * must be one of ["day", "week", "month", "quarter"]
     * Some APIs such as \n\nMetrics\n\n require intervals to cluster data.
     */
    interval: string;
    /**
     * must be one of ["chartmogul"]
     */
    sourceType: string;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. When feasible, any data before this date will not be replicated.
     */
    startDate: string;
}

export interface GetSourceClickhouseConfiguration {
    /**
     * The name of the database.
     */
    database: string;
    /**
     * The host endpoint of the Clickhouse cluster.
     */
    host: string;
    /**
     * The password associated with this username.
     */
    password: string;
    /**
     * The port of the database.
     */
    port: number;
    /**
     * must be one of ["clickhouse"]
     */
    sourceType: string;
    /**
     * Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
     */
    tunnelMethod: outputs.GetSourceClickhouseConfigurationTunnelMethod;
    /**
     * The username which is used to access the database.
     */
    username: string;
}

export interface GetSourceClickhouseConfigurationTunnelMethod {
    sourceClickhouseSshTunnelMethodNoTunnel: outputs.GetSourceClickhouseConfigurationTunnelMethodSourceClickhouseSshTunnelMethodNoTunnel;
    sourceClickhouseSshTunnelMethodPasswordAuthentication: outputs.GetSourceClickhouseConfigurationTunnelMethodSourceClickhouseSshTunnelMethodPasswordAuthentication;
    sourceClickhouseSshTunnelMethodSshKeyAuthentication: outputs.GetSourceClickhouseConfigurationTunnelMethodSourceClickhouseSshTunnelMethodSshKeyAuthentication;
    sourceClickhouseUpdateSshTunnelMethodNoTunnel: outputs.GetSourceClickhouseConfigurationTunnelMethodSourceClickhouseUpdateSshTunnelMethodNoTunnel;
    sourceClickhouseUpdateSshTunnelMethodPasswordAuthentication: outputs.GetSourceClickhouseConfigurationTunnelMethodSourceClickhouseUpdateSshTunnelMethodPasswordAuthentication;
    sourceClickhouseUpdateSshTunnelMethodSshKeyAuthentication: outputs.GetSourceClickhouseConfigurationTunnelMethodSourceClickhouseUpdateSshTunnelMethodSshKeyAuthentication;
}

export interface GetSourceClickhouseConfigurationTunnelMethodSourceClickhouseSshTunnelMethodNoTunnel {
    tunnelMethod: string;
}

export interface GetSourceClickhouseConfigurationTunnelMethodSourceClickhouseSshTunnelMethodPasswordAuthentication {
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
    tunnelUserPassword: string;
}

export interface GetSourceClickhouseConfigurationTunnelMethodSourceClickhouseSshTunnelMethodSshKeyAuthentication {
    sshKey: string;
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
}

export interface GetSourceClickhouseConfigurationTunnelMethodSourceClickhouseUpdateSshTunnelMethodNoTunnel {
    tunnelMethod: string;
}

export interface GetSourceClickhouseConfigurationTunnelMethodSourceClickhouseUpdateSshTunnelMethodPasswordAuthentication {
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
    tunnelUserPassword: string;
}

export interface GetSourceClickhouseConfigurationTunnelMethodSourceClickhouseUpdateSshTunnelMethodSshKeyAuthentication {
    sshKey: string;
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
}

export interface GetSourceClickupApiConfiguration {
    /**
     * Every ClickUp API call required authentication. This field is your personal API token. See \n\nhere\n\n.
     */
    apiToken: string;
    /**
     * The ID of your folder in your space. Retrieve it from the `/space/{space_id}/folder` of the ClickUp API. See \n\nhere\n\n.
     */
    folderId: string;
    /**
     * Include or exclude closed tasks. By default, they are excluded. See \n\nhere\n\n.
     */
    includeClosedTasks: boolean;
    /**
     * The ID of your list in your folder. Retrieve it from the `/folder/{folder_id}/list` of the ClickUp API. See \n\nhere\n\n.
     */
    listId: string;
    /**
     * must be one of ["clickup-api"]
     */
    sourceType: string;
    /**
     * The ID of your space in your workspace. Retrieve it from the `/team/{team_id}/space` of the ClickUp API. See \n\nhere\n\n.
     */
    spaceId: string;
    /**
     * The ID of your team in ClickUp. Retrieve it from the `/team` of the ClickUp API. See \n\nhere\n\n.
     */
    teamId: string;
}

export interface GetSourceClockifyConfiguration {
    /**
     * You can get your api accessKey \n\nhere\n\n This API is Case Sensitive.
     */
    apiKey: string;
    /**
     * The URL for the Clockify API. This should only need to be modified if connecting to an enterprise version of Clockify.
     */
    apiUrl: string;
    /**
     * must be one of ["clockify"]
     */
    sourceType: string;
    /**
     * WorkSpace Id
     */
    workspaceId: string;
}

export interface GetSourceCloseComConfiguration {
    /**
     * Close.com API key (usually starts with 'api_'; find yours \n\nhere\n\n).
     */
    apiKey: string;
    /**
     * must be one of ["close-com"]
     */
    sourceType: string;
    /**
     * The start date to sync data; all data after this date will be replicated. Leave blank to retrieve all the data available in the account. Format: YYYY-MM-DD.
     */
    startDate: string;
}

export interface GetSourceCodaConfiguration {
    /**
     * Bearer token
     */
    authToken: string;
    /**
     * must be one of ["coda"]
     */
    sourceType: string;
}

export interface GetSourceCoinApiConfiguration {
    /**
     * API Key
     */
    apiKey: string;
    /**
     * The end date in ISO 8601 format. If not supplied, data will be returned
     * from the start date to the current time, or when the count of result
     * elements reaches its limit.
     */
    endDate: string;
    /**
     * must be one of ["sandbox", "production"]
     * The environment to use. Either sandbox or production.
     */
    environment: string;
    /**
     * The maximum number of elements to return. If not supplied, the default
     * is 100. For numbers larger than 100, each 100 items is counted as one
     * request for pricing purposes. Maximum value is 100000.
     */
    limit: number;
    /**
     * The period to use. See the documentation for a list. https://docs.coinapi.io/#list-all-periods-get
     */
    period: string;
    /**
     * must be one of ["coin-api"]
     */
    sourceType: string;
    /**
     * The start date in ISO 8601 format.
     */
    startDate: string;
    /**
     * The symbol ID to use. See the documentation for a list.
     * https://docs.coinapi.io/#list-all-symbols-get
     */
    symbolId: string;
}

export interface GetSourceCoinmarketcapConfiguration {
    /**
     * Your API Key. See \n\nhere\n\n. The token is case sensitive.
     */
    apiKey: string;
    /**
     * must be one of ["latest", "historical"]
     * /latest: Latest market ticker quotes and averages for cryptocurrencies and exchanges. /historical: Intervals of historic market data like OHLCV data or data for use in charting libraries. See \n\nhere\n\n.
     */
    dataType: string;
    /**
     * must be one of ["coinmarketcap"]
     */
    sourceType: string;
    /**
     * Cryptocurrency symbols. (only used for quotes stream)
     */
    symbols: string[];
}

export interface GetSourceConfigcatConfiguration {
    /**
     * Basic auth password. See \n\nhere\n\n.
     */
    password: string;
    /**
     * must be one of ["configcat"]
     */
    sourceType: string;
    /**
     * Basic auth user name. See \n\nhere\n\n.
     */
    username: string;
}

export interface GetSourceConfluenceConfiguration {
    /**
     * Please follow the Jira confluence for generating an API token: \n\ngenerating an API token\n\n.
     */
    apiToken: string;
    /**
     * Your Confluence domain name
     */
    domainName: string;
    /**
     * Your Confluence login email
     */
    email: string;
    /**
     * must be one of ["confluence"]
     */
    sourceType: string;
}

export interface GetSourceConvexConfiguration {
    /**
     * API access key used to retrieve data from Convex.
     */
    accessKey: string;
    deploymentUrl: string;
    /**
     * must be one of ["convex"]
     */
    sourceType: string;
}

export interface GetSourceDatadogConfiguration {
    /**
     * Datadog API key
     */
    apiKey: string;
    /**
     * Datadog application key
     */
    applicationKey: string;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Data after this date will  not be replicated. An empty value will represent the current datetime for each  execution. This just applies to Incremental syncs.
     */
    endDate: string;
    /**
     * Maximum number of records to collect per request.
     */
    maxRecordsPerRequest: number;
    /**
     * List of queries to be run and used as inputs.
     */
    queries: outputs.GetSourceDatadogConfigurationQuery[];
    /**
     * The search query. This just applies to Incremental syncs. If empty, it'll collect all logs.
     */
    query: string;
    /**
     * must be one of ["datadoghq.com", "us3.datadoghq.com", "us5.datadoghq.com", "datadoghq.eu", "ddog-gov.com"]
     * The site where Datadog data resides in.
     */
    site: string;
    /**
     * must be one of ["datadog"]
     */
    sourceType: string;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated. This just applies to Incremental syncs.
     */
    startDate: string;
}

export interface GetSourceDatadogConfigurationQuery {
    dataSource: string;
    name: string;
    query: string;
}

export interface GetSourceDatascopeConfiguration {
    /**
     * API Key
     */
    apiKey: string;
    /**
     * must be one of ["datascope"]
     */
    sourceType: string;
    /**
     * Start date for the data to be replicated
     */
    startDate: string;
}

export interface GetSourceDelightedConfiguration {
    /**
     * A Delighted API key.
     */
    apiKey: string;
    /**
     * The date from which you'd like to replicate the data
     */
    since: string;
    /**
     * must be one of ["delighted"]
     */
    sourceType: string;
}

export interface GetSourceDixaConfiguration {
    /**
     * Dixa API token
     */
    apiToken: string;
    /**
     * Number of days to batch into one request. Max 31.
     */
    batchSize: number;
    /**
     * must be one of ["dixa"]
     */
    sourceType: string;
    /**
     * The connector pulls records updated from this date onwards.
     */
    startDate: string;
}

export interface GetSourceDockerhubConfiguration {
    /**
     * Username of DockerHub person or organization (for https://hub.docker.com/v2/repositories/USERNAME/ API call)
     */
    dockerUsername: string;
    /**
     * must be one of ["dockerhub"]
     */
    sourceType: string;
}

export interface GetSourceDremioConfiguration {
    /**
     * API Key that is generated when you authenticate to Dremio API
     */
    apiKey: string;
    /**
     * URL of your Dremio instance
     */
    baseUrl: string;
    /**
     * must be one of ["dremio"]
     */
    sourceType: string;
}

export interface GetSourceDynamodbConfiguration {
    /**
     * The access key id to access Dynamodb. Airbyte requires read permissions to the database
     */
    accessKeyId: string;
    /**
     * the URL of the Dynamodb database
     */
    endpoint: string;
    /**
     * must be one of ["", "us-east-1", "us-east-2", "us-west-1", "us-west-2", "af-south-1", "ap-east-1", "ap-south-1", "ap-northeast-1", "ap-northeast-2", "ap-northeast-3", "ap-southeast-1", "ap-southeast-2", "ca-central-1", "cn-north-1", "cn-northwest-1", "eu-central-1", "eu-north-1", "eu-south-1", "eu-west-1", "eu-west-2", "eu-west-3", "sa-east-1", "me-south-1", "us-gov-east-1", "us-gov-west-1"]
     * The region of the Dynamodb database
     */
    region: string;
    /**
     * Comma separated reserved attribute names present in your tables
     */
    reservedAttributeNames: string;
    /**
     * The corresponding secret to the access key id.
     */
    secretAccessKey: string;
    /**
     * must be one of ["dynamodb"]
     */
    sourceType: string;
}

export interface GetSourceE2eTestCloudConfiguration {
    /**
     * Number of records to emit per stream. Min 1. Max 100 billion.
     */
    maxMessages: number;
    /**
     * Interval between messages in ms. Min 0 ms. Max 60000 ms (1 minute).
     */
    messageIntervalMs: number;
    mockCatalog: outputs.GetSourceE2eTestCloudConfigurationMockCatalog;
    /**
     * When the seed is unspecified, the current time millis will be used as the seed. Range: [0, 1000000].
     */
    seed: number;
    /**
     * must be one of ["e2e-test-cloud"]
     */
    sourceType: string;
    /**
     * must be one of ["CONTINUOUS_FEED"]
     */
    type: string;
}

export interface GetSourceE2eTestCloudConfigurationMockCatalog {
    sourceE2eTestCloudMockCatalogMultiSchema: outputs.GetSourceE2eTestCloudConfigurationMockCatalogSourceE2eTestCloudMockCatalogMultiSchema;
    sourceE2eTestCloudMockCatalogSingleSchema: outputs.GetSourceE2eTestCloudConfigurationMockCatalogSourceE2eTestCloudMockCatalogSingleSchema;
    sourceE2eTestCloudUpdateMockCatalogMultiSchema: outputs.GetSourceE2eTestCloudConfigurationMockCatalogSourceE2eTestCloudUpdateMockCatalogMultiSchema;
    sourceE2eTestCloudUpdateMockCatalogSingleSchema: outputs.GetSourceE2eTestCloudConfigurationMockCatalogSourceE2eTestCloudUpdateMockCatalogSingleSchema;
}

export interface GetSourceE2eTestCloudConfigurationMockCatalogSourceE2eTestCloudMockCatalogMultiSchema {
    streamSchemas: string;
    type: string;
}

export interface GetSourceE2eTestCloudConfigurationMockCatalogSourceE2eTestCloudMockCatalogSingleSchema {
    streamDuplication: number;
    streamName: string;
    streamSchema: string;
    type: string;
}

export interface GetSourceE2eTestCloudConfigurationMockCatalogSourceE2eTestCloudUpdateMockCatalogMultiSchema {
    streamSchemas: string;
    type: string;
}

export interface GetSourceE2eTestCloudConfigurationMockCatalogSourceE2eTestCloudUpdateMockCatalogSingleSchema {
    streamDuplication: number;
    streamName: string;
    streamSchema: string;
    type: string;
}

export interface GetSourceEmailoctopusConfiguration {
    /**
     * EmailOctopus API Key. See the \n\ndocs\n\n for information on how to generate this key.
     */
    apiKey: string;
    /**
     * must be one of ["emailoctopus"]
     */
    sourceType: string;
}

export interface GetSourceExchangeRatesConfiguration {
    /**
     * Your API Key. See \n\nhere\n\n. The key is case sensitive.
     */
    accessKey: string;
    /**
     * ISO reference currency. See \n\nhere\n\n. Free plan doesn't support Source Currency Switching, default base currency is EUR
     */
    base: string;
    /**
     * Ignore weekends? (Exchanges don't run on weekends)
     */
    ignoreWeekends: boolean;
    /**
     * must be one of ["exchange-rates"]
     */
    sourceType: string;
    /**
     * Start getting data from that date.
     */
    startDate: string;
}

export interface GetSourceFacebookMarketingConfiguration {
    /**
     * The value of the generated access token. From your Appâ€™s Dashboard, click on "Marketing API" then "Tools". Select permissions \n\nads*management, ads*read, read*insights, business*management\n\n. Then click on "Get token". See the \n\ndocs\n\n for more information.
     */
    accessToken: string;
    /**
     * The Facebook Ad account ID to use when pulling data from the Facebook Marketing API. Open your Meta Ads Manager. The Ad account ID number is in the account dropdown menu or in your browser's address bar. See the \n\ndocs\n\n for more information.
     */
    accountId: string;
    /**
     * Allows actionBreakdowns to be an empty list
     */
    actionBreakdownsAllowEmpty: boolean;
    /**
     * The Client Id for your OAuth app
     */
    clientId: string;
    /**
     * The Client Secret for your OAuth app
     */
    clientSecret: string;
    /**
     * A list which contains ad statistics entries, each entry must have a name and can contains fields, breakdowns or action*breakdowns. Click on "add" to fill this field.
     */
    customInsights: outputs.GetSourceFacebookMarketingConfigurationCustomInsight[];
    /**
     * The date until which you'd like to replicate data for all incremental streams, in the format YYYY-MM-DDT00:00:00Z. All data generated between the start date and this end date will be replicated. Not setting this option will result in always syncing the latest data.
     */
    endDate: string;
    /**
     * Set to active if you want to fetch the thumbnail*url and store the result in thumbnail*data_url for each Ad Creative.
     */
    fetchThumbnailImages: boolean;
    /**
     * Set to active if you want to include data from deleted Campaigns, Ads, and AdSets.
     */
    includeDeleted: boolean;
    /**
     * The attribution window. Facebook freezes insight data 28 days after it was generated, which means that all data from the past 28 days may have changed since we last emitted it, so you can retrieve refreshed insights from the past by setting this parameter. If you set a custom lookback window value in Facebook account, please provide the same value here.
     */
    insightsLookbackWindow: number;
    /**
     * Maximum batch size used when sending batch requests to Facebook API. Most users do not need to set this field unless they specifically need to tune the connector to address specific issues or use cases.
     */
    maxBatchSize: number;
    /**
     * Page size used when sending requests to Facebook API to specify number of records per page when response has pagination. Most users do not need to set this field unless they specifically need to tune the connector to address specific issues or use cases.
     */
    pageSize: number;
    /**
     * must be one of ["facebook-marketing"]
     */
    sourceType: string;
    /**
     * The date from which you'd like to replicate data for all incremental streams, in the format YYYY-MM-DDT00:00:00Z. All data generated after this date will be replicated.
     */
    startDate: string;
}

export interface GetSourceFacebookMarketingConfigurationCustomInsight {
    actionBreakdowns: string[];
    actionReportTime: string;
    breakdowns: string[];
    endDate: string;
    fields: string[];
    insightsLookbackWindow: number;
    level: string;
    name: string;
    startDate: string;
    timeIncrement: number;
}

export interface GetSourceFacebookPagesConfiguration {
    /**
     * Facebook Page Access Token
     */
    accessToken: string;
    /**
     * Page ID
     */
    pageId: string;
    /**
     * must be one of ["facebook-pages"]
     */
    sourceType: string;
}

export interface GetSourceFakerConfiguration {
    /**
     * Should the updatedAt values for every record be new each sync?  Setting this to false will case the source to stop emitting records after COUNT records have been emitted.
     */
    alwaysUpdated: boolean;
    /**
     * How many users should be generated in total.  This setting does not apply to the purchases or products stream.
     */
    count: number;
    /**
     * How many parallel workers should we use to generate fake data?  Choose a value equal to the number of CPUs you will allocate to this source.
     */
    parallelism: number;
    /**
     * How many fake records will be in each page (stream slice), before a state message is emitted?
     */
    recordsPerSlice: number;
    /**
     * Manually control the faker random seed to return the same values on subsequent runs (leave -1 for random)
     */
    seed: number;
    /**
     * must be one of ["faker"]
     */
    sourceType: string;
}

export interface GetSourceFaunaConfiguration {
    /**
     * Settings for the Fauna Collection.
     */
    collection: outputs.GetSourceFaunaConfigurationCollection;
    /**
     * Domain of Fauna to query. Defaults db.fauna.com. See \n\nthe docs\n\n.
     */
    domain: string;
    /**
     * Endpoint port.
     */
    port: number;
    /**
     * URL scheme.
     */
    scheme: string;
    /**
     * Fauna secret, used when authenticating with the database.
     */
    secret: string;
    /**
     * must be one of ["fauna"]
     */
    sourceType: string;
}

export interface GetSourceFaunaConfigurationCollection {
    deletions: outputs.GetSourceFaunaConfigurationCollectionDeletions;
    pageSize: number;
}

export interface GetSourceFaunaConfigurationCollectionDeletions {
    sourceFaunaCollectionDeletionModeDisabled: outputs.GetSourceFaunaConfigurationCollectionDeletionsSourceFaunaCollectionDeletionModeDisabled;
    sourceFaunaCollectionDeletionModeEnabled: outputs.GetSourceFaunaConfigurationCollectionDeletionsSourceFaunaCollectionDeletionModeEnabled;
    sourceFaunaUpdateCollectionDeletionModeDisabled: outputs.GetSourceFaunaConfigurationCollectionDeletionsSourceFaunaUpdateCollectionDeletionModeDisabled;
    sourceFaunaUpdateCollectionDeletionModeEnabled: outputs.GetSourceFaunaConfigurationCollectionDeletionsSourceFaunaUpdateCollectionDeletionModeEnabled;
}

export interface GetSourceFaunaConfigurationCollectionDeletionsSourceFaunaCollectionDeletionModeDisabled {
    deletionMode: string;
}

export interface GetSourceFaunaConfigurationCollectionDeletionsSourceFaunaCollectionDeletionModeEnabled {
    column: string;
    deletionMode: string;
}

export interface GetSourceFaunaConfigurationCollectionDeletionsSourceFaunaUpdateCollectionDeletionModeDisabled {
    deletionMode: string;
}

export interface GetSourceFaunaConfigurationCollectionDeletionsSourceFaunaUpdateCollectionDeletionModeEnabled {
    column: string;
    deletionMode: string;
}

export interface GetSourceFileSecureConfiguration {
    /**
     * The Name of the final table to replicate this file into (should include letters, numbers dash and underscores only).
     */
    datasetName: string;
    /**
     * must be one of ["csv", "json", "jsonl", "excel", "excelBinary", "feather", "parquet", "yaml"]
     * The Format of the file which should be replicated (Warning: some formats may be experimental, please refer to the docs).
     */
    format: string;
    /**
     * The storage Provider or Location of the file(s) which should be replicated.
     */
    provider: outputs.GetSourceFileSecureConfigurationProvider;
    /**
     * This should be a string in JSON format. It depends on the chosen file format to provide additional options and tune its behavior.
     */
    readerOptions: string;
    /**
     * must be one of ["file-secure"]
     */
    sourceType: string;
    /**
     * The URL path to access the file which should be replicated.
     */
    url: string;
}

export interface GetSourceFileSecureConfigurationProvider {
    sourceFileSecureStorageProviderAzBlobAzureBlobStorage: outputs.GetSourceFileSecureConfigurationProviderSourceFileSecureStorageProviderAzBlobAzureBlobStorage;
    sourceFileSecureStorageProviderGcsGoogleCloudStorage: outputs.GetSourceFileSecureConfigurationProviderSourceFileSecureStorageProviderGcsGoogleCloudStorage;
    sourceFileSecureStorageProviderHttpsPublicWeb: outputs.GetSourceFileSecureConfigurationProviderSourceFileSecureStorageProviderHttpsPublicWeb;
    sourceFileSecureStorageProviderS3AmazonWebServices: outputs.GetSourceFileSecureConfigurationProviderSourceFileSecureStorageProviderS3AmazonWebServices;
    sourceFileSecureStorageProviderScpSecureCopyProtocol: outputs.GetSourceFileSecureConfigurationProviderSourceFileSecureStorageProviderScpSecureCopyProtocol;
    sourceFileSecureStorageProviderSftpSecureFileTransferProtocol: outputs.GetSourceFileSecureConfigurationProviderSourceFileSecureStorageProviderSftpSecureFileTransferProtocol;
    sourceFileSecureStorageProviderSshSecureShell: outputs.GetSourceFileSecureConfigurationProviderSourceFileSecureStorageProviderSshSecureShell;
    sourceFileSecureUpdateStorageProviderAzBlobAzureBlobStorage: outputs.GetSourceFileSecureConfigurationProviderSourceFileSecureUpdateStorageProviderAzBlobAzureBlobStorage;
    sourceFileSecureUpdateStorageProviderGcsGoogleCloudStorage: outputs.GetSourceFileSecureConfigurationProviderSourceFileSecureUpdateStorageProviderGcsGoogleCloudStorage;
    sourceFileSecureUpdateStorageProviderHttpsPublicWeb: outputs.GetSourceFileSecureConfigurationProviderSourceFileSecureUpdateStorageProviderHttpsPublicWeb;
    sourceFileSecureUpdateStorageProviderS3AmazonWebServices: outputs.GetSourceFileSecureConfigurationProviderSourceFileSecureUpdateStorageProviderS3AmazonWebServices;
    sourceFileSecureUpdateStorageProviderScpSecureCopyProtocol: outputs.GetSourceFileSecureConfigurationProviderSourceFileSecureUpdateStorageProviderScpSecureCopyProtocol;
    sourceFileSecureUpdateStorageProviderSftpSecureFileTransferProtocol: outputs.GetSourceFileSecureConfigurationProviderSourceFileSecureUpdateStorageProviderSftpSecureFileTransferProtocol;
    sourceFileSecureUpdateStorageProviderSshSecureShell: outputs.GetSourceFileSecureConfigurationProviderSourceFileSecureUpdateStorageProviderSshSecureShell;
}

export interface GetSourceFileSecureConfigurationProviderSourceFileSecureStorageProviderAzBlobAzureBlobStorage {
    sasToken: string;
    sharedKey: string;
    storage: string;
    storageAccount: string;
}

export interface GetSourceFileSecureConfigurationProviderSourceFileSecureStorageProviderGcsGoogleCloudStorage {
    serviceAccountJson: string;
    storage: string;
}

export interface GetSourceFileSecureConfigurationProviderSourceFileSecureStorageProviderHttpsPublicWeb {
    storage: string;
    userAgent: boolean;
}

export interface GetSourceFileSecureConfigurationProviderSourceFileSecureStorageProviderS3AmazonWebServices {
    awsAccessKeyId: string;
    awsSecretAccessKey: string;
    storage: string;
}

export interface GetSourceFileSecureConfigurationProviderSourceFileSecureStorageProviderScpSecureCopyProtocol {
    host: string;
    password: string;
    port: string;
    storage: string;
    user: string;
}

export interface GetSourceFileSecureConfigurationProviderSourceFileSecureStorageProviderSftpSecureFileTransferProtocol {
    host: string;
    password: string;
    port: string;
    storage: string;
    user: string;
}

export interface GetSourceFileSecureConfigurationProviderSourceFileSecureStorageProviderSshSecureShell {
    host: string;
    password: string;
    port: string;
    storage: string;
    user: string;
}

export interface GetSourceFileSecureConfigurationProviderSourceFileSecureUpdateStorageProviderAzBlobAzureBlobStorage {
    sasToken: string;
    sharedKey: string;
    storage: string;
    storageAccount: string;
}

export interface GetSourceFileSecureConfigurationProviderSourceFileSecureUpdateStorageProviderGcsGoogleCloudStorage {
    serviceAccountJson: string;
    storage: string;
}

export interface GetSourceFileSecureConfigurationProviderSourceFileSecureUpdateStorageProviderHttpsPublicWeb {
    storage: string;
    userAgent: boolean;
}

export interface GetSourceFileSecureConfigurationProviderSourceFileSecureUpdateStorageProviderS3AmazonWebServices {
    awsAccessKeyId: string;
    awsSecretAccessKey: string;
    storage: string;
}

export interface GetSourceFileSecureConfigurationProviderSourceFileSecureUpdateStorageProviderScpSecureCopyProtocol {
    host: string;
    password: string;
    port: string;
    storage: string;
    user: string;
}

export interface GetSourceFileSecureConfigurationProviderSourceFileSecureUpdateStorageProviderSftpSecureFileTransferProtocol {
    host: string;
    password: string;
    port: string;
    storage: string;
    user: string;
}

export interface GetSourceFileSecureConfigurationProviderSourceFileSecureUpdateStorageProviderSshSecureShell {
    host: string;
    password: string;
    port: string;
    storage: string;
    user: string;
}

export interface GetSourceFireboltConfiguration {
    /**
     * Firebolt account to login.
     */
    account: string;
    /**
     * The database to connect to.
     */
    database: string;
    /**
     * Engine name or url to connect to.
     */
    engine: string;
    /**
     * The host name of your Firebolt database.
     */
    host: string;
    /**
     * Firebolt password.
     */
    password: string;
    /**
     * must be one of ["firebolt"]
     */
    sourceType: string;
    /**
     * Firebolt email address you use to login.
     */
    username: string;
}

export interface GetSourceFreshcallerConfiguration {
    /**
     * Freshcaller API Key. See the \n\ndocs\n\n for more information on how to obtain this key.
     */
    apiKey: string;
    /**
     * Used to construct Base URL for the Freshcaller APIs
     */
    domain: string;
    /**
     * The number of requests per minute that this source allowed to use. There is a rate limit of 50 requests per minute per app per account.
     */
    requestsPerMinute: number;
    /**
     * must be one of ["freshcaller"]
     */
    sourceType: string;
    /**
     * UTC date and time. Any data created after this date will be replicated.
     */
    startDate: string;
    /**
     * Lag in minutes for each sync, i.e., at time T, data for the time range [prev*sync*time, T-30] will be fetched
     */
    syncLagMinutes: number;
}

export interface GetSourceFreshdeskConfiguration {
    /**
     * Freshdesk API Key. See the \n\ndocs\n\n for more information on how to obtain this key.
     */
    apiKey: string;
    /**
     * Freshdesk domain
     */
    domain: string;
    /**
     * The number of requests per minute that this source allowed to use. There is a rate limit of 50 requests per minute per app per account.
     */
    requestsPerMinute: number;
    /**
     * must be one of ["freshdesk"]
     */
    sourceType: string;
    /**
     * UTC date and time. Any data created after this date will be replicated. If this parameter is not set, all data will be replicated.
     */
    startDate: string;
}

export interface GetSourceFreshsalesConfiguration {
    /**
     * Freshsales API Key. See \n\nhere\n\n. The key is case sensitive.
     */
    apiKey: string;
    /**
     * The Name of your Freshsales domain
     */
    domainName: string;
    /**
     * must be one of ["freshsales"]
     */
    sourceType: string;
}

export interface GetSourceGainsightPxConfiguration {
    /**
     * The Aptrinsic API Key which is recieved from the dashboard settings (ref - https://app.aptrinsic.com/settings/api-keys)
     */
    apiKey: string;
    /**
     * must be one of ["gainsight-px"]
     */
    sourceType: string;
}

export interface GetSourceGcsConfiguration {
    /**
     * GCS bucket name
     */
    gcsBucket: string;
    /**
     * GCS path to data
     */
    gcsPath: string;
    /**
     * Enter your Google Cloud \n\nservice account key\n\n in JSON format
     */
    serviceAccount: string;
    /**
     * must be one of ["gcs"]
     */
    sourceType: string;
}

export interface GetSourceGetlagoConfiguration {
    /**
     * Your API Key. See \n\nhere\n\n.
     */
    apiKey: string;
    /**
     * must be one of ["getlago"]
     */
    sourceType: string;
}

export interface GetSourceGithubConfiguration {
    /**
     * Space-delimited list of GitHub repository branches to pull commits for, e.g. `airbytehq/airbyte/master`. If no branches are specified for a repository, the default branch will be pulled.
     */
    branch: string;
    /**
     * Choose how to authenticate to GitHub
     */
    credentials: outputs.GetSourceGithubConfigurationCredentials;
    /**
     * Space-delimited list of GitHub organizations/repositories, e.g. `airbytehq/airbyte` for single repository, `airbytehq/*` for get all repositories from organization and `airbytehq/airbyte airbytehq/another-repo` for multiple repositories.
     */
    repository: string;
    /**
     * The GitHub API allows for a maximum of 5000 requests per hour (15000 for Github Enterprise). You can specify a lower value to limit your use of the API quota.
     */
    requestsPerHour: number;
    /**
     * must be one of ["github"]
     */
    sourceType: string;
    /**
     * The date from which you'd like to replicate data from GitHub in the format YYYY-MM-DDT00:00:00Z. For the streams which support this configuration, only data generated on or after the start date will be replicated. This field doesn't apply to all streams, see the \n\ndocs\n\n for more info
     */
    startDate: string;
}

export interface GetSourceGithubConfigurationCredentials {
    sourceGithubAuthenticationOAuth: outputs.GetSourceGithubConfigurationCredentialsSourceGithubAuthenticationOAuth;
    sourceGithubAuthenticationPersonalAccessToken: outputs.GetSourceGithubConfigurationCredentialsSourceGithubAuthenticationPersonalAccessToken;
    sourceGithubUpdateAuthenticationOAuth: outputs.GetSourceGithubConfigurationCredentialsSourceGithubUpdateAuthenticationOAuth;
    sourceGithubUpdateAuthenticationPersonalAccessToken: outputs.GetSourceGithubConfigurationCredentialsSourceGithubUpdateAuthenticationPersonalAccessToken;
}

export interface GetSourceGithubConfigurationCredentialsSourceGithubAuthenticationOAuth {
    accessToken: string;
    clientId: string;
    clientSecret: string;
    optionTitle: string;
}

export interface GetSourceGithubConfigurationCredentialsSourceGithubAuthenticationPersonalAccessToken {
    optionTitle: string;
    personalAccessToken: string;
}

export interface GetSourceGithubConfigurationCredentialsSourceGithubUpdateAuthenticationOAuth {
    accessToken: string;
    clientId: string;
    clientSecret: string;
    optionTitle: string;
}

export interface GetSourceGithubConfigurationCredentialsSourceGithubUpdateAuthenticationPersonalAccessToken {
    optionTitle: string;
    personalAccessToken: string;
}

export interface GetSourceGitlabConfiguration {
    /**
     * Please enter your basic URL from GitLab instance.
     */
    apiUrl: string;
    credentials: outputs.GetSourceGitlabConfigurationCredentials;
    /**
     * Space-delimited list of groups. e.g. airbyte.io.
     */
    groups: string;
    /**
     * Space-delimited list of projects. e.g. airbyte.io/documentation meltano/tap-gitlab.
     */
    projects: string;
    /**
     * must be one of ["gitlab"]
     */
    sourceType: string;
    /**
     * The date from which you'd like to replicate data for GitLab API, in the format YYYY-MM-DDT00:00:00Z. All data generated after this date will be replicated.
     */
    startDate: string;
}

export interface GetSourceGitlabConfigurationCredentials {
    sourceGitlabAuthorizationMethodOAuth20: outputs.GetSourceGitlabConfigurationCredentialsSourceGitlabAuthorizationMethodOAuth20;
    sourceGitlabAuthorizationMethodPrivateToken: outputs.GetSourceGitlabConfigurationCredentialsSourceGitlabAuthorizationMethodPrivateToken;
    sourceGitlabUpdateAuthorizationMethodOAuth20: outputs.GetSourceGitlabConfigurationCredentialsSourceGitlabUpdateAuthorizationMethodOAuth20;
    sourceGitlabUpdateAuthorizationMethodPrivateToken: outputs.GetSourceGitlabConfigurationCredentialsSourceGitlabUpdateAuthorizationMethodPrivateToken;
}

export interface GetSourceGitlabConfigurationCredentialsSourceGitlabAuthorizationMethodOAuth20 {
    accessToken: string;
    authType: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
    tokenExpiryDate: string;
}

export interface GetSourceGitlabConfigurationCredentialsSourceGitlabAuthorizationMethodPrivateToken {
    accessToken: string;
    authType: string;
}

export interface GetSourceGitlabConfigurationCredentialsSourceGitlabUpdateAuthorizationMethodOAuth20 {
    accessToken: string;
    authType: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
    tokenExpiryDate: string;
}

export interface GetSourceGitlabConfigurationCredentialsSourceGitlabUpdateAuthorizationMethodPrivateToken {
    accessToken: string;
    authType: string;
}

export interface GetSourceGlassfrogConfiguration {
    /**
     * API key provided by Glassfrog
     */
    apiKey: string;
    /**
     * must be one of ["glassfrog"]
     */
    sourceType: string;
}

export interface GetSourceGnewsConfiguration {
    apiKey: string;
    country: string;
    endDate: string;
    ins: string[];
    language: string;
    nullables: string[];
    query: string;
    sortby: string;
    sourceType: string;
    startDate: string;
    topHeadlinesQuery: string;
    topHeadlinesTopic: string;
}

export interface GetSourceGoogleAdsConfiguration {
    /**
     * A conversion window is the number of days after an ad interaction (such as an ad click or video view) during which a conversion, such as a purchase, is recorded in Google Ads. For more information, see \n\nGoogle's documentation\n\n.
     */
    conversionWindowDays: number;
    credentials: outputs.GetSourceGoogleAdsConfigurationCredentials;
    customQueries: outputs.GetSourceGoogleAdsConfigurationCustomQuery[];
    /**
     * Comma-separated list of (client) customer IDs. Each customer ID must be specified as a 10-digit number without dashes. For detailed instructions on finding this value, refer to our \n\ndocumentation\n\n.
     */
    customerId: string;
    /**
     * UTC date in the format YYYY-MM-DD. Any data after this date will not be replicated.
     */
    endDate: string;
    /**
     * If your access to the customer account is through a manager account, this field is required, and must be set to the 10-digit customer ID of the manager account. For more information about this field, refer to \n\nGoogle's documentation\n\n.
     */
    loginCustomerId: string;
    /**
     * must be one of ["google-ads"]
     */
    sourceType: string;
    /**
     * UTC date in the format YYYY-MM-DD. Any data before this date will not be replicated.
     */
    startDate: string;
}

export interface GetSourceGoogleAdsConfigurationCredentials {
    accessToken: string;
    clientId: string;
    clientSecret: string;
    developerToken: string;
    refreshToken: string;
}

export interface GetSourceGoogleAdsConfigurationCustomQuery {
    query: string;
    tableName: string;
}

export interface GetSourceGoogleAnalyticsDataApiConfiguration {
    /**
     * Credentials for the service
     */
    credentials: outputs.GetSourceGoogleAnalyticsDataApiConfigurationCredentials;
    /**
     * A JSON array describing the custom reports you want to sync from Google Analytics. See \n\nthe documentation\n\n for more information about the exact format you can use to fill out this field.
     */
    customReports: string;
    /**
     * The start date from which to replicate report data in the format YYYY-MM-DD. Data generated before this date will not be included in the report. Not applied to custom Cohort reports.
     */
    dateRangesStartDate: string;
    /**
     * The Property ID is a unique number assigned to each property in Google Analytics, found in your GA4 property URL. This ID allows the connector to track the specific events associated with your property. Refer to the \n\nGoogle Analytics documentation\n\n to locate your property ID.
     */
    propertyId: string;
    /**
     * must be one of ["google-analytics-data-api"]
     */
    sourceType: string;
    /**
     * The interval in days for each data request made to the Google Analytics API. A larger value speeds up data sync, but increases the chance of data sampling, which may result in inaccuracies. We recommend a value of 1 to minimize sampling, unless speed is an absolute priority over accuracy. Acceptable values range from 1 to 364. Does not apply to custom Cohort reports. More information is available in \n\nthe documentation\n\n.
     */
    windowInDays: number;
}

export interface GetSourceGoogleAnalyticsDataApiConfigurationCredentials {
    sourceGoogleAnalyticsDataApiCredentialsAuthenticateViaGoogleOauth: outputs.GetSourceGoogleAnalyticsDataApiConfigurationCredentialsSourceGoogleAnalyticsDataApiCredentialsAuthenticateViaGoogleOauth;
    sourceGoogleAnalyticsDataApiCredentialsServiceAccountKeyAuthentication: outputs.GetSourceGoogleAnalyticsDataApiConfigurationCredentialsSourceGoogleAnalyticsDataApiCredentialsServiceAccountKeyAuthentication;
    sourceGoogleAnalyticsDataApiUpdateCredentialsAuthenticateViaGoogleOauth: outputs.GetSourceGoogleAnalyticsDataApiConfigurationCredentialsSourceGoogleAnalyticsDataApiUpdateCredentialsAuthenticateViaGoogleOauth;
    sourceGoogleAnalyticsDataApiUpdateCredentialsServiceAccountKeyAuthentication: outputs.GetSourceGoogleAnalyticsDataApiConfigurationCredentialsSourceGoogleAnalyticsDataApiUpdateCredentialsServiceAccountKeyAuthentication;
}

export interface GetSourceGoogleAnalyticsDataApiConfigurationCredentialsSourceGoogleAnalyticsDataApiCredentialsAuthenticateViaGoogleOauth {
    accessToken: string;
    authType: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
}

export interface GetSourceGoogleAnalyticsDataApiConfigurationCredentialsSourceGoogleAnalyticsDataApiCredentialsServiceAccountKeyAuthentication {
    authType: string;
    credentialsJson: string;
}

export interface GetSourceGoogleAnalyticsDataApiConfigurationCredentialsSourceGoogleAnalyticsDataApiUpdateCredentialsAuthenticateViaGoogleOauth {
    accessToken: string;
    authType: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
}

export interface GetSourceGoogleAnalyticsDataApiConfigurationCredentialsSourceGoogleAnalyticsDataApiUpdateCredentialsServiceAccountKeyAuthentication {
    authType: string;
    credentialsJson: string;
}

export interface GetSourceGoogleAnalyticsV4Configuration {
    /**
     * Credentials for the service
     */
    credentials: outputs.GetSourceGoogleAnalyticsV4ConfigurationCredentials;
    /**
     * A JSON array describing the custom reports you want to sync from Google Analytics. See \n\nthe docs\n\n for more information about the exact format you can use to fill out this field.
     */
    customReports: string;
    /**
     * must be one of ["google-analytics-v4"]
     */
    sourceType: string;
    /**
     * The date in the format YYYY-MM-DD. Any data before this date will not be replicated.
     */
    startDate: string;
    /**
     * The ID for the Google Analytics View you want to fetch data from. This can be found from the \n\nGoogle Analytics Account Explorer\n\n.
     */
    viewId: string;
    /**
     * The time increment used by the connector when requesting data from the Google Analytics API. More information is available in the \n\nthe docs\n\n. The bigger this value is, the faster the sync will be, but the more likely that sampling will be applied to your data, potentially causing inaccuracies in the returned results. We recommend setting this to 1 unless you have a hard requirement to make the sync faster at the expense of accuracy. The minimum allowed value for this field is 1, and the maximum is 364.
     */
    windowInDays: number;
}

export interface GetSourceGoogleAnalyticsV4ConfigurationCredentials {
    sourceGoogleAnalyticsV4CredentialsAuthenticateViaGoogleOauth: outputs.GetSourceGoogleAnalyticsV4ConfigurationCredentialsSourceGoogleAnalyticsV4CredentialsAuthenticateViaGoogleOauth;
    sourceGoogleAnalyticsV4CredentialsServiceAccountKeyAuthentication: outputs.GetSourceGoogleAnalyticsV4ConfigurationCredentialsSourceGoogleAnalyticsV4CredentialsServiceAccountKeyAuthentication;
    sourceGoogleAnalyticsV4UpdateCredentialsAuthenticateViaGoogleOauth: outputs.GetSourceGoogleAnalyticsV4ConfigurationCredentialsSourceGoogleAnalyticsV4UpdateCredentialsAuthenticateViaGoogleOauth;
    sourceGoogleAnalyticsV4UpdateCredentialsServiceAccountKeyAuthentication: outputs.GetSourceGoogleAnalyticsV4ConfigurationCredentialsSourceGoogleAnalyticsV4UpdateCredentialsServiceAccountKeyAuthentication;
}

export interface GetSourceGoogleAnalyticsV4ConfigurationCredentialsSourceGoogleAnalyticsV4CredentialsAuthenticateViaGoogleOauth {
    accessToken: string;
    authType: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
}

export interface GetSourceGoogleAnalyticsV4ConfigurationCredentialsSourceGoogleAnalyticsV4CredentialsServiceAccountKeyAuthentication {
    authType: string;
    credentialsJson: string;
}

export interface GetSourceGoogleAnalyticsV4ConfigurationCredentialsSourceGoogleAnalyticsV4UpdateCredentialsAuthenticateViaGoogleOauth {
    accessToken: string;
    authType: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
}

export interface GetSourceGoogleAnalyticsV4ConfigurationCredentialsSourceGoogleAnalyticsV4UpdateCredentialsServiceAccountKeyAuthentication {
    authType: string;
    credentialsJson: string;
}

export interface GetSourceGoogleDirectoryConfiguration {
    /**
     * Google APIs use the OAuth 2.0 protocol for authentication and authorization. The Source supports \n\nWeb server application\n\n and \n\nService accounts\n\n scenarios.
     */
    credentials: outputs.GetSourceGoogleDirectoryConfigurationCredentials;
    /**
     * must be one of ["google-directory"]
     */
    sourceType: string;
}

export interface GetSourceGoogleDirectoryConfigurationCredentials {
    sourceGoogleDirectoryGoogleCredentialsServiceAccountKey: outputs.GetSourceGoogleDirectoryConfigurationCredentialsSourceGoogleDirectoryGoogleCredentialsServiceAccountKey;
    sourceGoogleDirectoryGoogleCredentialsSignInViaGoogleOAuth: outputs.GetSourceGoogleDirectoryConfigurationCredentialsSourceGoogleDirectoryGoogleCredentialsSignInViaGoogleOAuth;
    sourceGoogleDirectoryUpdateGoogleCredentialsServiceAccountKey: outputs.GetSourceGoogleDirectoryConfigurationCredentialsSourceGoogleDirectoryUpdateGoogleCredentialsServiceAccountKey;
    sourceGoogleDirectoryUpdateGoogleCredentialsSignInViaGoogleOAuth: outputs.GetSourceGoogleDirectoryConfigurationCredentialsSourceGoogleDirectoryUpdateGoogleCredentialsSignInViaGoogleOAuth;
}

export interface GetSourceGoogleDirectoryConfigurationCredentialsSourceGoogleDirectoryGoogleCredentialsServiceAccountKey {
    credentialsJson: string;
    credentialsTitle: string;
    email: string;
}

export interface GetSourceGoogleDirectoryConfigurationCredentialsSourceGoogleDirectoryGoogleCredentialsSignInViaGoogleOAuth {
    clientId: string;
    clientSecret: string;
    credentialsTitle: string;
    refreshToken: string;
}

export interface GetSourceGoogleDirectoryConfigurationCredentialsSourceGoogleDirectoryUpdateGoogleCredentialsServiceAccountKey {
    credentialsJson: string;
    credentialsTitle: string;
    email: string;
}

export interface GetSourceGoogleDirectoryConfigurationCredentialsSourceGoogleDirectoryUpdateGoogleCredentialsSignInViaGoogleOAuth {
    clientId: string;
    clientSecret: string;
    credentialsTitle: string;
    refreshToken: string;
}

export interface GetSourceGooglePagespeedInsightsConfiguration {
    /**
     * Google PageSpeed API Key. See \n\nhere\n\n. The key is optional - however the API is heavily rate limited when using without API Key. Creating and using the API key therefore is recommended. The key is case sensitive.
     */
    apiKey: string;
    /**
     * Defines which Lighthouse category to run. One or many of: "accessibility", "best-practices", "performance", "pwa", "seo".
     */
    categories: string[];
    /**
     * must be one of ["google-pagespeed-insights"]
     */
    sourceType: string;
    /**
     * The analyses strategy to use. Either "desktop" or "mobile".
     */
    strategies: string[];
    /**
     * The URLs to retrieve pagespeed information from. The connector will attempt to sync PageSpeed reports for all the defined URLs. Format: https://(www.)url.domain
     */
    urls: string[];
}

export interface GetSourceGoogleSearchConsoleConfiguration {
    authorization: outputs.GetSourceGoogleSearchConsoleConfigurationAuthorization;
    /**
     * A JSON array describing the custom reports you want to sync from Google Search Console. See \n\nthe docs\n\n for more information about the exact format you can use to fill out this field.
     */
    customReports: string;
    /**
     * must be one of ["final", "all"]
     * If "final" or if this parameter is omitted, the returned data will include only finalized data. Setting this parameter to "all" should not be used with Incremental Sync mode as it may cause data loss. If "all", data will include fresh data.
     */
    dataState: string;
    /**
     * UTC date in the format 2017-01-25. Any data after this date will not be replicated. Must be greater or equal to the start date field.
     */
    endDate: string;
    /**
     * The URLs of the website property attached to your GSC account. Read more \n\nhere\n\n.
     */
    siteUrls: string[];
    /**
     * must be one of ["google-search-console"]
     */
    sourceType: string;
    /**
     * UTC date in the format 2017-01-25. Any data before this date will not be replicated.
     */
    startDate: string;
}

export interface GetSourceGoogleSearchConsoleConfigurationAuthorization {
    sourceGoogleSearchConsoleAuthenticationTypeOAuth: outputs.GetSourceGoogleSearchConsoleConfigurationAuthorizationSourceGoogleSearchConsoleAuthenticationTypeOAuth;
    sourceGoogleSearchConsoleAuthenticationTypeServiceAccountKeyAuthentication: outputs.GetSourceGoogleSearchConsoleConfigurationAuthorizationSourceGoogleSearchConsoleAuthenticationTypeServiceAccountKeyAuthentication;
    sourceGoogleSearchConsoleUpdateAuthenticationTypeOAuth: outputs.GetSourceGoogleSearchConsoleConfigurationAuthorizationSourceGoogleSearchConsoleUpdateAuthenticationTypeOAuth;
    sourceGoogleSearchConsoleUpdateAuthenticationTypeServiceAccountKeyAuthentication: outputs.GetSourceGoogleSearchConsoleConfigurationAuthorizationSourceGoogleSearchConsoleUpdateAuthenticationTypeServiceAccountKeyAuthentication;
}

export interface GetSourceGoogleSearchConsoleConfigurationAuthorizationSourceGoogleSearchConsoleAuthenticationTypeOAuth {
    accessToken: string;
    authType: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
}

export interface GetSourceGoogleSearchConsoleConfigurationAuthorizationSourceGoogleSearchConsoleAuthenticationTypeServiceAccountKeyAuthentication {
    authType: string;
    email: string;
    serviceAccountInfo: string;
}

export interface GetSourceGoogleSearchConsoleConfigurationAuthorizationSourceGoogleSearchConsoleUpdateAuthenticationTypeOAuth {
    accessToken: string;
    authType: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
}

export interface GetSourceGoogleSearchConsoleConfigurationAuthorizationSourceGoogleSearchConsoleUpdateAuthenticationTypeServiceAccountKeyAuthentication {
    authType: string;
    email: string;
    serviceAccountInfo: string;
}

export interface GetSourceGoogleSheetsConfiguration {
    /**
     * Credentials for connecting to the Google Sheets API
     */
    credentials: outputs.GetSourceGoogleSheetsConfigurationCredentials;
    /**
     * Enables the conversion of column names to a standardized, SQL-compliant format. For example, 'My Name' > 'my_name'. Enable this option if your destination is SQL-based.
     */
    namesConversion: boolean;
    /**
     * The number of rows fetched when making a Google Sheet API call. Defaults to 200.
     */
    rowBatchSize: number;
    /**
     * must be one of ["google-sheets"]
     */
    sourceType: string;
    /**
     * Enter the link to the Google spreadsheet you want to sync. To copy the link, click the 'Share' button in the top-right corner of the spreadsheet, then click 'Copy link'.
     */
    spreadsheetId: string;
}

export interface GetSourceGoogleSheetsConfigurationCredentials {
    sourceGoogleSheetsAuthenticationAuthenticateViaGoogleOAuth: outputs.GetSourceGoogleSheetsConfigurationCredentialsSourceGoogleSheetsAuthenticationAuthenticateViaGoogleOAuth;
    sourceGoogleSheetsAuthenticationServiceAccountKeyAuthentication: outputs.GetSourceGoogleSheetsConfigurationCredentialsSourceGoogleSheetsAuthenticationServiceAccountKeyAuthentication;
    sourceGoogleSheetsUpdateAuthenticationAuthenticateViaGoogleOAuth: outputs.GetSourceGoogleSheetsConfigurationCredentialsSourceGoogleSheetsUpdateAuthenticationAuthenticateViaGoogleOAuth;
    sourceGoogleSheetsUpdateAuthenticationServiceAccountKeyAuthentication: outputs.GetSourceGoogleSheetsConfigurationCredentialsSourceGoogleSheetsUpdateAuthenticationServiceAccountKeyAuthentication;
}

export interface GetSourceGoogleSheetsConfigurationCredentialsSourceGoogleSheetsAuthenticationAuthenticateViaGoogleOAuth {
    authType: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
}

export interface GetSourceGoogleSheetsConfigurationCredentialsSourceGoogleSheetsAuthenticationServiceAccountKeyAuthentication {
    authType: string;
    serviceAccountInfo: string;
}

export interface GetSourceGoogleSheetsConfigurationCredentialsSourceGoogleSheetsUpdateAuthenticationAuthenticateViaGoogleOAuth {
    authType: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
}

export interface GetSourceGoogleSheetsConfigurationCredentialsSourceGoogleSheetsUpdateAuthenticationServiceAccountKeyAuthentication {
    authType: string;
    serviceAccountInfo: string;
}

export interface GetSourceGoogleWebfontsConfiguration {
    /**
     * Optional, Available params- json, media, proto
     */
    alt: string;
    /**
     * API key is required to access google apis, For getting your's goto google console and generate api key for Webfonts
     */
    apiKey: string;
    /**
     * Optional, boolean type
     */
    prettyPrint: string;
    /**
     * Optional, to find how to sort
     */
    sort: string;
    /**
     * must be one of ["google-webfonts"]
     */
    sourceType: string;
}

export interface GetSourceGoogleWorkspaceAdminReportsConfiguration {
    /**
     * The contents of the JSON service account key. See the \n\ndocs\n\n for more information on how to generate this key.
     */
    credentialsJson: string;
    /**
     * The email of the user, which has permissions to access the Google Workspace Admin APIs.
     */
    email: string;
    /**
     * Sets the range of time shown in the report. Reports API allows from up to 180 days ago.
     */
    lookback: number;
    /**
     * must be one of ["google-workspace-admin-reports"]
     */
    sourceType: string;
}

export interface GetSourceGreenhouseConfiguration {
    /**
     * Greenhouse API Key. See the \n\ndocs\n\n for more information on how to generate this key.
     */
    apiKey: string;
    /**
     * must be one of ["greenhouse"]
     */
    sourceType: string;
}

export interface GetSourceGridlyConfiguration {
    apiKey: string;
    /**
     * ID of a grid, or can be ID of a branch
     */
    gridId: string;
    /**
     * must be one of ["gridly"]
     */
    sourceType: string;
}

export interface GetSourceHarvestConfiguration {
    /**
     * Harvest account ID. Required for all Harvest requests in pair with Personal Access Token
     */
    accountId: string;
    /**
     * Choose how to authenticate to Harvest.
     */
    credentials: outputs.GetSourceHarvestConfigurationCredentials;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Any data after this date will not be replicated.
     */
    replicationEndDate: string;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
     */
    replicationStartDate: string;
    /**
     * must be one of ["harvest"]
     */
    sourceType: string;
}

export interface GetSourceHarvestConfigurationCredentials {
    sourceHarvestAuthenticationMechanismAuthenticateViaHarvestOAuth: outputs.GetSourceHarvestConfigurationCredentialsSourceHarvestAuthenticationMechanismAuthenticateViaHarvestOAuth;
    sourceHarvestAuthenticationMechanismAuthenticateWithPersonalAccessToken: outputs.GetSourceHarvestConfigurationCredentialsSourceHarvestAuthenticationMechanismAuthenticateWithPersonalAccessToken;
    sourceHarvestUpdateAuthenticationMechanismAuthenticateViaHarvestOAuth: outputs.GetSourceHarvestConfigurationCredentialsSourceHarvestUpdateAuthenticationMechanismAuthenticateViaHarvestOAuth;
    sourceHarvestUpdateAuthenticationMechanismAuthenticateWithPersonalAccessToken: outputs.GetSourceHarvestConfigurationCredentialsSourceHarvestUpdateAuthenticationMechanismAuthenticateWithPersonalAccessToken;
}

export interface GetSourceHarvestConfigurationCredentialsSourceHarvestAuthenticationMechanismAuthenticateViaHarvestOAuth {
    additionalProperties?: string;
    authType: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
}

export interface GetSourceHarvestConfigurationCredentialsSourceHarvestAuthenticationMechanismAuthenticateWithPersonalAccessToken {
    additionalProperties?: string;
    apiToken: string;
    authType: string;
}

export interface GetSourceHarvestConfigurationCredentialsSourceHarvestUpdateAuthenticationMechanismAuthenticateViaHarvestOAuth {
    additionalProperties?: string;
    authType: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
}

export interface GetSourceHarvestConfigurationCredentialsSourceHarvestUpdateAuthenticationMechanismAuthenticateWithPersonalAccessToken {
    additionalProperties?: string;
    apiToken: string;
    authType: string;
}

export interface GetSourceHubplannerConfiguration {
    /**
     * Hubplanner API key. See https://github.com/hubplanner/API#authentication for more details.
     */
    apiKey: string;
    /**
     * must be one of ["hubplanner"]
     */
    sourceType: string;
}

export interface GetSourceHubspotConfiguration {
    /**
     * Choose how to authenticate to HubSpot.
     */
    credentials: outputs.GetSourceHubspotConfigurationCredentials;
    /**
     * must be one of ["hubspot"]
     */
    sourceType: string;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
     */
    startDate: string;
}

export interface GetSourceHubspotConfigurationCredentials {
    sourceHubspotAuthenticationOAuth: outputs.GetSourceHubspotConfigurationCredentialsSourceHubspotAuthenticationOAuth;
    sourceHubspotAuthenticationPrivateApp: outputs.GetSourceHubspotConfigurationCredentialsSourceHubspotAuthenticationPrivateApp;
    sourceHubspotUpdateAuthenticationOAuth: outputs.GetSourceHubspotConfigurationCredentialsSourceHubspotUpdateAuthenticationOAuth;
    sourceHubspotUpdateAuthenticationPrivateApp: outputs.GetSourceHubspotConfigurationCredentialsSourceHubspotUpdateAuthenticationPrivateApp;
}

export interface GetSourceHubspotConfigurationCredentialsSourceHubspotAuthenticationOAuth {
    clientId: string;
    clientSecret: string;
    credentialsTitle: string;
    refreshToken: string;
}

export interface GetSourceHubspotConfigurationCredentialsSourceHubspotAuthenticationPrivateApp {
    accessToken: string;
    credentialsTitle: string;
}

export interface GetSourceHubspotConfigurationCredentialsSourceHubspotUpdateAuthenticationOAuth {
    clientId: string;
    clientSecret: string;
    credentialsTitle: string;
    refreshToken: string;
}

export interface GetSourceHubspotConfigurationCredentialsSourceHubspotUpdateAuthenticationPrivateApp {
    accessToken: string;
    credentialsTitle: string;
}

export interface GetSourceInsightlyConfiguration {
    /**
     * must be one of ["insightly"]
     */
    sourceType: string;
    /**
     * The date from which you'd like to replicate data for Insightly in the format YYYY-MM-DDT00:00:00Z. All data generated after this date will be replicated. Note that it will be used only for incremental streams.
     */
    startDate: string;
    /**
     * Your Insightly API token.
     */
    token: string;
}

export interface GetSourceInstagramConfiguration {
    /**
     * The value of the access token generated with \n\ninstagram*basic, instagram*manage*insights, pages*show*list, pages*read_engagement, Instagram Public Content Access\n\n permissions. See the \n\ndocs\n\n for more information
     */
    accessToken: string;
    /**
     * The Client ID for your Oauth application
     */
    clientId: string;
    /**
     * The Client Secret for your Oauth application
     */
    clientSecret: string;
    /**
     * must be one of ["instagram"]
     */
    sourceType: string;
    /**
     * The date from which you'd like to replicate data for User Insights, in the format YYYY-MM-DDT00:00:00Z. All data generated after this date will be replicated.
     */
    startDate: string;
}

export interface GetSourceInstatusConfiguration {
    /**
     * Instatus REST API key
     */
    apiKey: string;
    /**
     * must be one of ["instatus"]
     */
    sourceType: string;
}

export interface GetSourceIntercomConfiguration {
    /**
     * Access token for making authenticated requests. See the \n\nIntercom docs\n\n for more information.
     */
    accessToken: string;
    /**
     * must be one of ["intercom"]
     */
    sourceType: string;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
     */
    startDate: string;
}

export interface GetSourceIp2whoisConfiguration {
    /**
     * Your API Key. See \n\nhere\n\n.
     */
    apiKey: string;
    /**
     * Domain name. See \n\nhere\n\n.
     */
    domain: string;
    /**
     * must be one of ["ip2whois"]
     */
    sourceType: string;
}

export interface GetSourceIterableConfiguration {
    /**
     * Iterable API Key. See the \n\ndocs\n\n for more information on how to obtain this key.
     */
    apiKey: string;
    /**
     * must be one of ["iterable"]
     */
    sourceType: string;
    /**
     * The date from which you'd like to replicate data for Iterable, in the format YYYY-MM-DDT00:00:00Z. All data generated after this date will be replicated.
     */
    startDate: string;
}

export interface GetSourceJiraConfiguration {
    /**
     * Jira API Token. See the \n\ndocs\n\n for more information on how to generate this key. API Token is used for Authorization to your account by BasicAuth.
     */
    apiToken: string;
    /**
     * The Domain for your Jira account, e.g. airbyteio.atlassian.net, airbyteio.jira.com, jira.your-domain.com
     */
    domain: string;
    /**
     * The user email for your Jira account which you used to generate the API token. This field is used for Authorization to your account by BasicAuth.
     */
    email: string;
    /**
     * Allow the use of experimental streams which rely on undocumented Jira API endpoints. See https://docs.airbyte.com/integrations/sources/jira#experimental-tables for more info.
     */
    enableExperimentalStreams: boolean;
    /**
     * Expand the changelog when replicating issues.
     */
    expandIssueChangelog: boolean;
    /**
     * List of Jira project keys to replicate data for, or leave it empty if you want to replicate data for all projects.
     */
    projects: string[];
    /**
     * Render issue fields in HTML format in addition to Jira JSON-like format.
     */
    renderFields: boolean;
    /**
     * must be one of ["jira"]
     */
    sourceType: string;
    /**
     * The date from which you want to replicate data from Jira, use the format YYYY-MM-DDT00:00:00Z. Note that this field only applies to certain streams, and only data generated on or after the start date will be replicated. Or leave it empty if you want to replicate all data. For more information, refer to the \n\ndocumentation\n\n.
     */
    startDate: string;
}

export interface GetSourceK6CloudConfiguration {
    /**
     * Your API Token. See \n\nhere\n\n. The key is case sensitive.
     */
    apiToken: string;
    /**
     * must be one of ["k6-cloud"]
     */
    sourceType: string;
}

export interface GetSourceKlarnaConfiguration {
    /**
     * A string which is associated with your Merchant ID and is used to authorize use of Klarna's APIs (https://developers.klarna.com/api/#authentication)
     */
    password: string;
    /**
     * Propertie defining if connector is used against playground or production environment
     */
    playground: boolean;
    /**
     * must be one of ["eu", "us", "oc"]
     * Base url region (For playground eu https://docs.klarna.com/klarna-payments/api/payments-api/#tag/API-URLs). Supported 'eu', 'us', 'oc'
     */
    region: string;
    /**
     * must be one of ["klarna"]
     */
    sourceType: string;
    /**
     * Consists of your Merchant ID (eid) - a unique number that identifies your e-store, combined with a random string (https://developers.klarna.com/api/#authentication)
     */
    username: string;
}

export interface GetSourceKlaviyoConfiguration {
    /**
     * Klaviyo API Key. See our \n\ndocs\n\n if you need help finding this key.
     */
    apiKey: string;
    /**
     * must be one of ["klaviyo"]
     */
    sourceType: string;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
     */
    startDate: string;
}

export interface GetSourceKustomerSingerConfiguration {
    /**
     * Kustomer API Token. See the \n\ndocs\n\n on how to obtain this
     */
    apiToken: string;
    /**
     * must be one of ["kustomer-singer"]
     */
    sourceType: string;
    /**
     * The date from which you'd like to replicate the data
     */
    startDate: string;
}

export interface GetSourceKyveConfiguration {
    /**
     * The maximum amount of pages to go trough. Set to 'null' for all pages.
     */
    maxPages: number;
    /**
     * The pagesize for pagination, smaller numbers are used in integration tests.
     */
    pageSize: number;
    /**
     * The IDs of the KYVE storage pool you want to archive. (Comma separated)
     */
    poolIds: string;
    /**
     * must be one of ["kyve"]
     */
    sourceType: string;
    /**
     * The start-id defines, from which bundle id the pipeline should start to extract the data (Comma separated)
     */
    startIds: string;
    /**
     * URL to the KYVE Chain API.
     */
    urlBase: string;
}

export interface GetSourceLaunchdarklyConfiguration {
    /**
     * Your Access token. See \n\nhere\n\n.
     */
    accessToken: string;
    /**
     * must be one of ["launchdarkly"]
     */
    sourceType: string;
}

export interface GetSourceLemlistConfiguration {
    /**
     * Lemlist API key.
     */
    apiKey: string;
    /**
     * must be one of ["lemlist"]
     */
    sourceType: string;
}

export interface GetSourceLeverHiringConfiguration {
    /**
     * Choose how to authenticate to Lever Hiring.
     */
    credentials: outputs.GetSourceLeverHiringConfigurationCredentials;
    /**
     * must be one of ["Production", "Sandbox"]
     * The environment in which you'd like to replicate data for Lever. This is used to determine which Lever API endpoint to use.
     */
    environment: string;
    /**
     * must be one of ["lever-hiring"]
     */
    sourceType: string;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated. Note that it will be used only in the following incremental streams: comments, commits, and issues.
     */
    startDate: string;
}

export interface GetSourceLeverHiringConfigurationCredentials {
    sourceLeverHiringAuthenticationMechanismAuthenticateViaLeverApiKey: outputs.GetSourceLeverHiringConfigurationCredentialsSourceLeverHiringAuthenticationMechanismAuthenticateViaLeverApiKey;
    sourceLeverHiringAuthenticationMechanismAuthenticateViaLeverOAuth: outputs.GetSourceLeverHiringConfigurationCredentialsSourceLeverHiringAuthenticationMechanismAuthenticateViaLeverOAuth;
    sourceLeverHiringUpdateAuthenticationMechanismAuthenticateViaLeverApiKey: outputs.GetSourceLeverHiringConfigurationCredentialsSourceLeverHiringUpdateAuthenticationMechanismAuthenticateViaLeverApiKey;
    sourceLeverHiringUpdateAuthenticationMechanismAuthenticateViaLeverOAuth: outputs.GetSourceLeverHiringConfigurationCredentialsSourceLeverHiringUpdateAuthenticationMechanismAuthenticateViaLeverOAuth;
}

export interface GetSourceLeverHiringConfigurationCredentialsSourceLeverHiringAuthenticationMechanismAuthenticateViaLeverApiKey {
    apiKey: string;
    authType: string;
}

export interface GetSourceLeverHiringConfigurationCredentialsSourceLeverHiringAuthenticationMechanismAuthenticateViaLeverOAuth {
    authType: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
}

export interface GetSourceLeverHiringConfigurationCredentialsSourceLeverHiringUpdateAuthenticationMechanismAuthenticateViaLeverApiKey {
    apiKey: string;
    authType: string;
}

export interface GetSourceLeverHiringConfigurationCredentialsSourceLeverHiringUpdateAuthenticationMechanismAuthenticateViaLeverOAuth {
    authType: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
}

export interface GetSourceLinkedinAdsConfiguration {
    /**
     * Specify the account IDs separated by a space, to pull the data from. Leave empty, if you want to pull the data from all associated accounts. See the \n\nLinkedIn Ads docs\n\n for more info.
     */
    accountIds: number[];
    adAnalyticsReports: outputs.GetSourceLinkedinAdsConfigurationAdAnalyticsReport[];
    credentials: outputs.GetSourceLinkedinAdsConfigurationCredentials;
    /**
     * must be one of ["linkedin-ads"]
     */
    sourceType: string;
    /**
     * UTC date in the format 2020-09-17. Any data before this date will not be replicated.
     */
    startDate: string;
}

export interface GetSourceLinkedinAdsConfigurationAdAnalyticsReport {
    name: string;
    pivotBy: string;
    timeGranularity: string;
}

export interface GetSourceLinkedinAdsConfigurationCredentials {
    sourceLinkedinAdsAuthenticationAccessToken: outputs.GetSourceLinkedinAdsConfigurationCredentialsSourceLinkedinAdsAuthenticationAccessToken;
    sourceLinkedinAdsAuthenticationOAuth20: outputs.GetSourceLinkedinAdsConfigurationCredentialsSourceLinkedinAdsAuthenticationOAuth20;
    sourceLinkedinAdsUpdateAuthenticationAccessToken: outputs.GetSourceLinkedinAdsConfigurationCredentialsSourceLinkedinAdsUpdateAuthenticationAccessToken;
    sourceLinkedinAdsUpdateAuthenticationOAuth20: outputs.GetSourceLinkedinAdsConfigurationCredentialsSourceLinkedinAdsUpdateAuthenticationOAuth20;
}

export interface GetSourceLinkedinAdsConfigurationCredentialsSourceLinkedinAdsAuthenticationAccessToken {
    accessToken: string;
    authMethod: string;
}

export interface GetSourceLinkedinAdsConfigurationCredentialsSourceLinkedinAdsAuthenticationOAuth20 {
    authMethod: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
}

export interface GetSourceLinkedinAdsConfigurationCredentialsSourceLinkedinAdsUpdateAuthenticationAccessToken {
    accessToken: string;
    authMethod: string;
}

export interface GetSourceLinkedinAdsConfigurationCredentialsSourceLinkedinAdsUpdateAuthenticationOAuth20 {
    authMethod: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
}

export interface GetSourceLinkedinPagesConfiguration {
    credentials: outputs.GetSourceLinkedinPagesConfigurationCredentials;
    /**
     * Specify the Organization ID
     */
    orgId: string;
    /**
     * must be one of ["linkedin-pages"]
     */
    sourceType: string;
}

export interface GetSourceLinkedinPagesConfigurationCredentials {
    sourceLinkedinPagesAuthenticationAccessToken: outputs.GetSourceLinkedinPagesConfigurationCredentialsSourceLinkedinPagesAuthenticationAccessToken;
    sourceLinkedinPagesAuthenticationOAuth20: outputs.GetSourceLinkedinPagesConfigurationCredentialsSourceLinkedinPagesAuthenticationOAuth20;
    sourceLinkedinPagesUpdateAuthenticationAccessToken: outputs.GetSourceLinkedinPagesConfigurationCredentialsSourceLinkedinPagesUpdateAuthenticationAccessToken;
    sourceLinkedinPagesUpdateAuthenticationOAuth20: outputs.GetSourceLinkedinPagesConfigurationCredentialsSourceLinkedinPagesUpdateAuthenticationOAuth20;
}

export interface GetSourceLinkedinPagesConfigurationCredentialsSourceLinkedinPagesAuthenticationAccessToken {
    accessToken: string;
    authMethod: string;
}

export interface GetSourceLinkedinPagesConfigurationCredentialsSourceLinkedinPagesAuthenticationOAuth20 {
    authMethod: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
}

export interface GetSourceLinkedinPagesConfigurationCredentialsSourceLinkedinPagesUpdateAuthenticationAccessToken {
    accessToken: string;
    authMethod: string;
}

export interface GetSourceLinkedinPagesConfigurationCredentialsSourceLinkedinPagesUpdateAuthenticationOAuth20 {
    authMethod: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
}

export interface GetSourceLinnworksConfiguration {
    /**
     * Linnworks Application ID
     */
    applicationId: string;
    /**
     * Linnworks Application Secret
     */
    applicationSecret: string;
    /**
     * must be one of ["linnworks"]
     */
    sourceType: string;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
     */
    startDate: string;
    token: string;
}

export interface GetSourceLokaliseConfiguration {
    /**
     * Lokalise API Key with read-access. Available at Profile settings > API tokens. See \n\nhere\n\n.
     */
    apiKey: string;
    /**
     * Lokalise project ID. Available at Project Settings > General.
     */
    projectId: string;
    /**
     * must be one of ["lokalise"]
     */
    sourceType: string;
}

export interface GetSourceMailchimpConfiguration {
    campaignId: string;
    credentials: outputs.GetSourceMailchimpConfigurationCredentials;
    /**
     * must be one of ["mailchimp"]
     */
    sourceType: string;
}

export interface GetSourceMailchimpConfigurationCredentials {
    sourceMailchimpAuthenticationApiKey: outputs.GetSourceMailchimpConfigurationCredentialsSourceMailchimpAuthenticationApiKey;
    sourceMailchimpAuthenticationOAuth20: outputs.GetSourceMailchimpConfigurationCredentialsSourceMailchimpAuthenticationOAuth20;
    sourceMailchimpUpdateAuthenticationApiKey: outputs.GetSourceMailchimpConfigurationCredentialsSourceMailchimpUpdateAuthenticationApiKey;
    sourceMailchimpUpdateAuthenticationOAuth20: outputs.GetSourceMailchimpConfigurationCredentialsSourceMailchimpUpdateAuthenticationOAuth20;
}

export interface GetSourceMailchimpConfigurationCredentialsSourceMailchimpAuthenticationApiKey {
    apikey: string;
    authType: string;
}

export interface GetSourceMailchimpConfigurationCredentialsSourceMailchimpAuthenticationOAuth20 {
    accessToken: string;
    authType: string;
    clientId: string;
    clientSecret: string;
}

export interface GetSourceMailchimpConfigurationCredentialsSourceMailchimpUpdateAuthenticationApiKey {
    apikey: string;
    authType: string;
}

export interface GetSourceMailchimpConfigurationCredentialsSourceMailchimpUpdateAuthenticationOAuth20 {
    accessToken: string;
    authType: string;
    clientId: string;
    clientSecret: string;
}

export interface GetSourceMailgunConfiguration {
    /**
     * Domain region code. 'EU' or 'US' are possible values. The default is 'US'.
     */
    domainRegion: string;
    /**
     * Primary account API key to access your Mailgun data.
     */
    privateKey: string;
    /**
     * must be one of ["mailgun"]
     */
    sourceType: string;
    /**
     * UTC date and time in the format 2020-10-01 00:00:00. Any data before this date will not be replicated. If omitted, defaults to 3 days ago.
     */
    startDate: string;
}

export interface GetSourceMailjetSmsConfiguration {
    /**
     * Retrieve SMS messages created before the specified timestamp. Required format - Unix timestamp.
     */
    endDate: number;
    /**
     * must be one of ["mailjet-sms"]
     */
    sourceType: string;
    /**
     * Retrieve SMS messages created after the specified timestamp. Required format - Unix timestamp.
     */
    startDate: number;
    /**
     * Your access token. See \n\nhere\n\n.
     */
    token: string;
}

export interface GetSourceMarketoConfiguration {
    /**
     * The Client ID of your Marketo developer application. See \n\n the docs \n\n for info on how to obtain this.
     */
    clientId: string;
    /**
     * The Client Secret of your Marketo developer application. See \n\n the docs \n\n for info on how to obtain this.
     */
    clientSecret: string;
    /**
     * Your Marketo Base URL. See \n\n the docs \n\n for info on how to obtain this.
     */
    domainUrl: string;
    /**
     * must be one of ["marketo"]
     */
    sourceType: string;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
     */
    startDate: string;
}

export interface GetSourceMetabaseConfiguration {
    /**
     * URL to your metabase instance API
     */
    instanceApiUrl: string;
    password: string;
    /**
     * To generate your session token, you need to run the following command: `curl -X POST \
     * -H "Content-Type: application/json" \
     * -d '{"username": "person@metabase.com", "password": "fakepassword"}' \
     * http://localhost:3000/api/session
     * ` Then copy the value of the `id` field returned by a successful call to that API.
     * Note that by default, sessions are good for 14 days and needs to be regenerated.
     */
    sessionToken: string;
    /**
     * must be one of ["metabase"]
     */
    sourceType: string;
    username: string;
}

export interface GetSourceMicrosoftTeamsConfiguration {
    /**
     * Choose how to authenticate to Microsoft
     */
    credentials: outputs.GetSourceMicrosoftTeamsConfigurationCredentials;
    /**
     * Specifies the length of time over which the Team Device Report stream is aggregated. The supported values are: D7, D30, D90, and D180.
     */
    period: string;
    /**
     * must be one of ["microsoft-teams"]
     */
    sourceType: string;
}

export interface GetSourceMicrosoftTeamsConfigurationCredentials {
    sourceMicrosoftTeamsAuthenticationMechanismAuthenticateViaMicrosoft: outputs.GetSourceMicrosoftTeamsConfigurationCredentialsSourceMicrosoftTeamsAuthenticationMechanismAuthenticateViaMicrosoft;
    sourceMicrosoftTeamsAuthenticationMechanismAuthenticateViaMicrosoftOAuth20: outputs.GetSourceMicrosoftTeamsConfigurationCredentialsSourceMicrosoftTeamsAuthenticationMechanismAuthenticateViaMicrosoftOAuth20;
    sourceMicrosoftTeamsUpdateAuthenticationMechanismAuthenticateViaMicrosoft: outputs.GetSourceMicrosoftTeamsConfigurationCredentialsSourceMicrosoftTeamsUpdateAuthenticationMechanismAuthenticateViaMicrosoft;
    sourceMicrosoftTeamsUpdateAuthenticationMechanismAuthenticateViaMicrosoftOAuth20: outputs.GetSourceMicrosoftTeamsConfigurationCredentialsSourceMicrosoftTeamsUpdateAuthenticationMechanismAuthenticateViaMicrosoftOAuth20;
}

export interface GetSourceMicrosoftTeamsConfigurationCredentialsSourceMicrosoftTeamsAuthenticationMechanismAuthenticateViaMicrosoft {
    authType: string;
    clientId: string;
    clientSecret: string;
    tenantId: string;
}

export interface GetSourceMicrosoftTeamsConfigurationCredentialsSourceMicrosoftTeamsAuthenticationMechanismAuthenticateViaMicrosoftOAuth20 {
    authType: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
    tenantId: string;
}

export interface GetSourceMicrosoftTeamsConfigurationCredentialsSourceMicrosoftTeamsUpdateAuthenticationMechanismAuthenticateViaMicrosoft {
    authType: string;
    clientId: string;
    clientSecret: string;
    tenantId: string;
}

export interface GetSourceMicrosoftTeamsConfigurationCredentialsSourceMicrosoftTeamsUpdateAuthenticationMechanismAuthenticateViaMicrosoftOAuth20 {
    authType: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
    tenantId: string;
}

export interface GetSourceMixpanelConfiguration {
    /**
     * A period of time for attributing results to ads and the lookback period after those actions occur during which ad results are counted. Default attribution window is 5 days.
     */
    attributionWindow: number;
    /**
     * Choose how to authenticate to Mixpanel
     */
    credentials: outputs.GetSourceMixpanelConfigurationCredentials;
    /**
     * Defines window size in days, that used to slice through data. You can reduce it, if amount of data in each window is too big for your environment.
     */
    dateWindowSize: number;
    /**
     * The date in the format YYYY-MM-DD. Any data after this date will not be replicated. Left empty to always sync to most recent date
     */
    endDate: string;
    /**
     * Your project ID number. See the \n\ndocs\n\n for more information on how to obtain this.
     */
    projectId: number;
    /**
     * Time zone in which integer date times are stored. The project timezone may be found in the project settings in the \n\nMixpanel console\n\n.
     */
    projectTimezone: string;
    /**
     * must be one of ["US", "EU"]
     * The region of mixpanel domain instance either US or EU.
     */
    region: string;
    /**
     * Setting this config parameter to TRUE ensures that new properties on events and engage records are captured. Otherwise new properties will be ignored.
     */
    selectPropertiesByDefault: boolean;
    /**
     * must be one of ["mixpanel"]
     */
    sourceType: string;
    /**
     * The date in the format YYYY-MM-DD. Any data before this date will not be replicated. If this option is not set, the connector will replicate data from up to one year ago by default.
     */
    startDate: string;
}

export interface GetSourceMixpanelConfigurationCredentials {
    sourceMixpanelAuthenticationWildcardProjectSecret: outputs.GetSourceMixpanelConfigurationCredentialsSourceMixpanelAuthenticationWildcardProjectSecret;
    sourceMixpanelAuthenticationWildcardServiceAccount: outputs.GetSourceMixpanelConfigurationCredentialsSourceMixpanelAuthenticationWildcardServiceAccount;
    sourceMixpanelUpdateAuthenticationWildcardProjectSecret: outputs.GetSourceMixpanelConfigurationCredentialsSourceMixpanelUpdateAuthenticationWildcardProjectSecret;
    sourceMixpanelUpdateAuthenticationWildcardServiceAccount: outputs.GetSourceMixpanelConfigurationCredentialsSourceMixpanelUpdateAuthenticationWildcardServiceAccount;
}

export interface GetSourceMixpanelConfigurationCredentialsSourceMixpanelAuthenticationWildcardProjectSecret {
    apiSecret: string;
    optionTitle: string;
}

export interface GetSourceMixpanelConfigurationCredentialsSourceMixpanelAuthenticationWildcardServiceAccount {
    optionTitle: string;
    secret: string;
    username: string;
}

export interface GetSourceMixpanelConfigurationCredentialsSourceMixpanelUpdateAuthenticationWildcardProjectSecret {
    apiSecret: string;
    optionTitle: string;
}

export interface GetSourceMixpanelConfigurationCredentialsSourceMixpanelUpdateAuthenticationWildcardServiceAccount {
    optionTitle: string;
    secret: string;
    username: string;
}

export interface GetSourceMondayConfiguration {
    credentials: outputs.GetSourceMondayConfigurationCredentials;
    /**
     * must be one of ["monday"]
     */
    sourceType: string;
}

export interface GetSourceMondayConfigurationCredentials {
    sourceMondayAuthorizationMethodApiToken: outputs.GetSourceMondayConfigurationCredentialsSourceMondayAuthorizationMethodApiToken;
    sourceMondayAuthorizationMethodOAuth20: outputs.GetSourceMondayConfigurationCredentialsSourceMondayAuthorizationMethodOAuth20;
    sourceMondayUpdateAuthorizationMethodApiToken: outputs.GetSourceMondayConfigurationCredentialsSourceMondayUpdateAuthorizationMethodApiToken;
    sourceMondayUpdateAuthorizationMethodOAuth20: outputs.GetSourceMondayConfigurationCredentialsSourceMondayUpdateAuthorizationMethodOAuth20;
}

export interface GetSourceMondayConfigurationCredentialsSourceMondayAuthorizationMethodApiToken {
    apiToken: string;
    authType: string;
}

export interface GetSourceMondayConfigurationCredentialsSourceMondayAuthorizationMethodOAuth20 {
    accessToken: string;
    authType: string;
    clientId: string;
    clientSecret: string;
    subdomain: string;
}

export interface GetSourceMondayConfigurationCredentialsSourceMondayUpdateAuthorizationMethodApiToken {
    apiToken: string;
    authType: string;
}

export interface GetSourceMondayConfigurationCredentialsSourceMondayUpdateAuthorizationMethodOAuth20 {
    accessToken: string;
    authType: string;
    clientId: string;
    clientSecret: string;
    subdomain: string;
}

export interface GetSourceMongodbConfiguration {
    /**
     * The authentication source where the user information is stored.
     */
    authSource: string;
    /**
     * The database you want to replicate.
     */
    database: string;
    /**
     * The MongoDb instance to connect to. For MongoDB Atlas and Replica Set TLS connection is used by default.
     */
    instanceType: outputs.GetSourceMongodbConfigurationInstanceType;
    /**
     * The password associated with this username.
     */
    password: string;
    /**
     * must be one of ["mongodb"]
     */
    sourceType: string;
    /**
     * The username which is used to access the database.
     */
    user: string;
}

export interface GetSourceMongodbConfigurationInstanceType {
    sourceMongodbMongoDbInstanceTypeMongoDbAtlas: outputs.GetSourceMongodbConfigurationInstanceTypeSourceMongodbMongoDbInstanceTypeMongoDbAtlas;
    sourceMongodbMongoDbInstanceTypeReplicaSet: outputs.GetSourceMongodbConfigurationInstanceTypeSourceMongodbMongoDbInstanceTypeReplicaSet;
    sourceMongodbMongoDbInstanceTypeStandaloneMongoDbInstance: outputs.GetSourceMongodbConfigurationInstanceTypeSourceMongodbMongoDbInstanceTypeStandaloneMongoDbInstance;
    sourceMongodbUpdateMongoDbInstanceTypeMongoDbAtlas: outputs.GetSourceMongodbConfigurationInstanceTypeSourceMongodbUpdateMongoDbInstanceTypeMongoDbAtlas;
    sourceMongodbUpdateMongoDbInstanceTypeReplicaSet: outputs.GetSourceMongodbConfigurationInstanceTypeSourceMongodbUpdateMongoDbInstanceTypeReplicaSet;
    sourceMongodbUpdateMongoDbInstanceTypeStandaloneMongoDbInstance: outputs.GetSourceMongodbConfigurationInstanceTypeSourceMongodbUpdateMongoDbInstanceTypeStandaloneMongoDbInstance;
}

export interface GetSourceMongodbConfigurationInstanceTypeSourceMongodbMongoDbInstanceTypeMongoDbAtlas {
    additionalProperties?: string;
    clusterUrl: string;
    instance: string;
}

export interface GetSourceMongodbConfigurationInstanceTypeSourceMongodbMongoDbInstanceTypeReplicaSet {
    instance: string;
    replicaSet: string;
    serverAddresses: string;
}

export interface GetSourceMongodbConfigurationInstanceTypeSourceMongodbMongoDbInstanceTypeStandaloneMongoDbInstance {
    host: string;
    instance: string;
    port: number;
}

export interface GetSourceMongodbConfigurationInstanceTypeSourceMongodbUpdateMongoDbInstanceTypeMongoDbAtlas {
    additionalProperties?: string;
    clusterUrl: string;
    instance: string;
}

export interface GetSourceMongodbConfigurationInstanceTypeSourceMongodbUpdateMongoDbInstanceTypeReplicaSet {
    instance: string;
    replicaSet: string;
    serverAddresses: string;
}

export interface GetSourceMongodbConfigurationInstanceTypeSourceMongodbUpdateMongoDbInstanceTypeStandaloneMongoDbInstance {
    host: string;
    instance: string;
    port: number;
}

export interface GetSourceMongodbInternalPocConfiguration {
    /**
     * The authentication source where the user information is stored.
     */
    authSource: string;
    /**
     * The connection string of the database that you want to replicate..
     */
    connectionString: string;
    /**
     * The password associated with this username.
     */
    password: string;
    /**
     * The name of the replica set to be replicated.
     */
    replicaSet: string;
    /**
     * must be one of ["mongodb-internal-poc"]
     */
    sourceType: string;
    /**
     * The username which is used to access the database.
     */
    user: string;
}

export interface GetSourceMssqlConfiguration {
    /**
     * The name of the database.
     */
    database: string;
    /**
     * The hostname of the database.
     */
    host: string;
    /**
     * Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
     */
    jdbcUrlParams: string;
    /**
     * The password associated with the username.
     */
    password: string;
    /**
     * The port of the database.
     */
    port: number;
    /**
     * The replication method used for extracting data from the database. STANDARD replication requires no setup on the DB side but will not be able to represent deletions incrementally. CDC uses {TBC} to detect inserts, updates, and deletes. This needs to be configured on the source database itself.
     */
    replicationMethod: outputs.GetSourceMssqlConfigurationReplicationMethod;
    /**
     * The list of schemas to sync from. Defaults to user. Case sensitive.
     */
    schemas: string[];
    /**
     * must be one of ["mssql"]
     */
    sourceType: string;
    /**
     * The encryption method which is used when communicating with the database.
     */
    sslMethod: outputs.GetSourceMssqlConfigurationSslMethod;
    /**
     * Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
     */
    tunnelMethod: outputs.GetSourceMssqlConfigurationTunnelMethod;
    /**
     * The username which is used to access the database.
     */
    username: string;
}

export interface GetSourceMssqlConfigurationReplicationMethod {
    sourceMssqlReplicationMethodLogicalReplicationCdc: outputs.GetSourceMssqlConfigurationReplicationMethodSourceMssqlReplicationMethodLogicalReplicationCdc;
    sourceMssqlReplicationMethodStandard: outputs.GetSourceMssqlConfigurationReplicationMethodSourceMssqlReplicationMethodStandard;
    sourceMssqlUpdateReplicationMethodLogicalReplicationCdc: outputs.GetSourceMssqlConfigurationReplicationMethodSourceMssqlUpdateReplicationMethodLogicalReplicationCdc;
    sourceMssqlUpdateReplicationMethodStandard: outputs.GetSourceMssqlConfigurationReplicationMethodSourceMssqlUpdateReplicationMethodStandard;
}

export interface GetSourceMssqlConfigurationReplicationMethodSourceMssqlReplicationMethodLogicalReplicationCdc {
    dataToSync: string;
    initialWaitingSeconds: number;
    method: string;
    snapshotIsolation: string;
}

export interface GetSourceMssqlConfigurationReplicationMethodSourceMssqlReplicationMethodStandard {
    method: string;
}

export interface GetSourceMssqlConfigurationReplicationMethodSourceMssqlUpdateReplicationMethodLogicalReplicationCdc {
    dataToSync: string;
    initialWaitingSeconds: number;
    method: string;
    snapshotIsolation: string;
}

export interface GetSourceMssqlConfigurationReplicationMethodSourceMssqlUpdateReplicationMethodStandard {
    method: string;
}

export interface GetSourceMssqlConfigurationSslMethod {
    sourceMssqlSslMethodEncryptedTrustServerCertificate: outputs.GetSourceMssqlConfigurationSslMethodSourceMssqlSslMethodEncryptedTrustServerCertificate;
    sourceMssqlSslMethodEncryptedVerifyCertificate: outputs.GetSourceMssqlConfigurationSslMethodSourceMssqlSslMethodEncryptedVerifyCertificate;
    sourceMssqlUpdateSslMethodEncryptedTrustServerCertificate: outputs.GetSourceMssqlConfigurationSslMethodSourceMssqlUpdateSslMethodEncryptedTrustServerCertificate;
    sourceMssqlUpdateSslMethodEncryptedVerifyCertificate: outputs.GetSourceMssqlConfigurationSslMethodSourceMssqlUpdateSslMethodEncryptedVerifyCertificate;
}

export interface GetSourceMssqlConfigurationSslMethodSourceMssqlSslMethodEncryptedTrustServerCertificate {
    sslMethod: string;
}

export interface GetSourceMssqlConfigurationSslMethodSourceMssqlSslMethodEncryptedVerifyCertificate {
    hostNameInCertificate: string;
    sslMethod: string;
}

export interface GetSourceMssqlConfigurationSslMethodSourceMssqlUpdateSslMethodEncryptedTrustServerCertificate {
    sslMethod: string;
}

export interface GetSourceMssqlConfigurationSslMethodSourceMssqlUpdateSslMethodEncryptedVerifyCertificate {
    hostNameInCertificate: string;
    sslMethod: string;
}

export interface GetSourceMssqlConfigurationTunnelMethod {
    sourceMssqlSshTunnelMethodNoTunnel: outputs.GetSourceMssqlConfigurationTunnelMethodSourceMssqlSshTunnelMethodNoTunnel;
    sourceMssqlSshTunnelMethodPasswordAuthentication: outputs.GetSourceMssqlConfigurationTunnelMethodSourceMssqlSshTunnelMethodPasswordAuthentication;
    sourceMssqlSshTunnelMethodSshKeyAuthentication: outputs.GetSourceMssqlConfigurationTunnelMethodSourceMssqlSshTunnelMethodSshKeyAuthentication;
    sourceMssqlUpdateSshTunnelMethodNoTunnel: outputs.GetSourceMssqlConfigurationTunnelMethodSourceMssqlUpdateSshTunnelMethodNoTunnel;
    sourceMssqlUpdateSshTunnelMethodPasswordAuthentication: outputs.GetSourceMssqlConfigurationTunnelMethodSourceMssqlUpdateSshTunnelMethodPasswordAuthentication;
    sourceMssqlUpdateSshTunnelMethodSshKeyAuthentication: outputs.GetSourceMssqlConfigurationTunnelMethodSourceMssqlUpdateSshTunnelMethodSshKeyAuthentication;
}

export interface GetSourceMssqlConfigurationTunnelMethodSourceMssqlSshTunnelMethodNoTunnel {
    tunnelMethod: string;
}

export interface GetSourceMssqlConfigurationTunnelMethodSourceMssqlSshTunnelMethodPasswordAuthentication {
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
    tunnelUserPassword: string;
}

export interface GetSourceMssqlConfigurationTunnelMethodSourceMssqlSshTunnelMethodSshKeyAuthentication {
    sshKey: string;
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
}

export interface GetSourceMssqlConfigurationTunnelMethodSourceMssqlUpdateSshTunnelMethodNoTunnel {
    tunnelMethod: string;
}

export interface GetSourceMssqlConfigurationTunnelMethodSourceMssqlUpdateSshTunnelMethodPasswordAuthentication {
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
    tunnelUserPassword: string;
}

export interface GetSourceMssqlConfigurationTunnelMethodSourceMssqlUpdateSshTunnelMethodSshKeyAuthentication {
    sshKey: string;
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
}

export interface GetSourceMyHoursConfiguration {
    /**
     * Your My Hours username
     */
    email: string;
    /**
     * Pagination size used for retrieving logs in days
     */
    logsBatchSize: number;
    /**
     * The password associated to the username
     */
    password: string;
    /**
     * must be one of ["my-hours"]
     */
    sourceType: string;
    /**
     * Start date for collecting time logs
     */
    startDate: string;
}

export interface GetSourceMysqlConfiguration {
    /**
     * The database name.
     */
    database: string;
    /**
     * The host name of the database.
     */
    host: string;
    /**
     * Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3). For more information read about \n\nJDBC URL parameters\n\n.
     */
    jdbcUrlParams: string;
    /**
     * The password associated with the username.
     */
    password: string;
    /**
     * The port to connect to.
     */
    port: number;
    /**
     * Configures how data is extracted from the database.
     */
    replicationMethod: outputs.GetSourceMysqlConfigurationReplicationMethod;
    /**
     * must be one of ["mysql"]
     */
    sourceType: string;
    /**
     * SSL connection modes. Read more \n\n in the docs\n\n.
     */
    sslMode: outputs.GetSourceMysqlConfigurationSslMode;
    /**
     * Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
     */
    tunnelMethod: outputs.GetSourceMysqlConfigurationTunnelMethod;
    /**
     * The username which is used to access the database.
     */
    username: string;
}

export interface GetSourceMysqlConfigurationReplicationMethod {
    sourceMysqlUpdateMethodReadChangesUsingBinaryLogCdc: outputs.GetSourceMysqlConfigurationReplicationMethodSourceMysqlUpdateMethodReadChangesUsingBinaryLogCdc;
    sourceMysqlUpdateMethodScanChangesWithUserDefinedCursor: outputs.GetSourceMysqlConfigurationReplicationMethodSourceMysqlUpdateMethodScanChangesWithUserDefinedCursor;
    sourceMysqlUpdateUpdateMethodReadChangesUsingBinaryLogCdc: outputs.GetSourceMysqlConfigurationReplicationMethodSourceMysqlUpdateUpdateMethodReadChangesUsingBinaryLogCdc;
    sourceMysqlUpdateUpdateMethodScanChangesWithUserDefinedCursor: outputs.GetSourceMysqlConfigurationReplicationMethodSourceMysqlUpdateUpdateMethodScanChangesWithUserDefinedCursor;
}

export interface GetSourceMysqlConfigurationReplicationMethodSourceMysqlUpdateMethodReadChangesUsingBinaryLogCdc {
    initialWaitingSeconds: number;
    method: string;
    serverTimeZone: string;
}

export interface GetSourceMysqlConfigurationReplicationMethodSourceMysqlUpdateMethodScanChangesWithUserDefinedCursor {
    method: string;
}

export interface GetSourceMysqlConfigurationReplicationMethodSourceMysqlUpdateUpdateMethodReadChangesUsingBinaryLogCdc {
    initialWaitingSeconds: number;
    method: string;
    serverTimeZone: string;
}

export interface GetSourceMysqlConfigurationReplicationMethodSourceMysqlUpdateUpdateMethodScanChangesWithUserDefinedCursor {
    method: string;
}

export interface GetSourceMysqlConfigurationSslMode {
    sourceMysqlSslModesPreferred: outputs.GetSourceMysqlConfigurationSslModeSourceMysqlSslModesPreferred;
    sourceMysqlSslModesRequired: outputs.GetSourceMysqlConfigurationSslModeSourceMysqlSslModesRequired;
    sourceMysqlSslModesVerifyCa: outputs.GetSourceMysqlConfigurationSslModeSourceMysqlSslModesVerifyCa;
    sourceMysqlSslModesVerifyIdentity: outputs.GetSourceMysqlConfigurationSslModeSourceMysqlSslModesVerifyIdentity;
    sourceMysqlUpdateSslModesPreferred: outputs.GetSourceMysqlConfigurationSslModeSourceMysqlUpdateSslModesPreferred;
    sourceMysqlUpdateSslModesRequired: outputs.GetSourceMysqlConfigurationSslModeSourceMysqlUpdateSslModesRequired;
    sourceMysqlUpdateSslModesVerifyCa: outputs.GetSourceMysqlConfigurationSslModeSourceMysqlUpdateSslModesVerifyCa;
    sourceMysqlUpdateSslModesVerifyIdentity: outputs.GetSourceMysqlConfigurationSslModeSourceMysqlUpdateSslModesVerifyIdentity;
}

export interface GetSourceMysqlConfigurationSslModeSourceMysqlSslModesPreferred {
    mode: string;
}

export interface GetSourceMysqlConfigurationSslModeSourceMysqlSslModesRequired {
    mode: string;
}

export interface GetSourceMysqlConfigurationSslModeSourceMysqlSslModesVerifyCa {
    caCertificate: string;
    clientCertificate: string;
    clientKey: string;
    clientKeyPassword: string;
    mode: string;
}

export interface GetSourceMysqlConfigurationSslModeSourceMysqlSslModesVerifyIdentity {
    caCertificate: string;
    clientCertificate: string;
    clientKey: string;
    clientKeyPassword: string;
    mode: string;
}

export interface GetSourceMysqlConfigurationSslModeSourceMysqlUpdateSslModesPreferred {
    mode: string;
}

export interface GetSourceMysqlConfigurationSslModeSourceMysqlUpdateSslModesRequired {
    mode: string;
}

export interface GetSourceMysqlConfigurationSslModeSourceMysqlUpdateSslModesVerifyCa {
    caCertificate: string;
    clientCertificate: string;
    clientKey: string;
    clientKeyPassword: string;
    mode: string;
}

export interface GetSourceMysqlConfigurationSslModeSourceMysqlUpdateSslModesVerifyIdentity {
    caCertificate: string;
    clientCertificate: string;
    clientKey: string;
    clientKeyPassword: string;
    mode: string;
}

export interface GetSourceMysqlConfigurationTunnelMethod {
    sourceMysqlSshTunnelMethodNoTunnel: outputs.GetSourceMysqlConfigurationTunnelMethodSourceMysqlSshTunnelMethodNoTunnel;
    sourceMysqlSshTunnelMethodPasswordAuthentication: outputs.GetSourceMysqlConfigurationTunnelMethodSourceMysqlSshTunnelMethodPasswordAuthentication;
    sourceMysqlSshTunnelMethodSshKeyAuthentication: outputs.GetSourceMysqlConfigurationTunnelMethodSourceMysqlSshTunnelMethodSshKeyAuthentication;
    sourceMysqlUpdateSshTunnelMethodNoTunnel: outputs.GetSourceMysqlConfigurationTunnelMethodSourceMysqlUpdateSshTunnelMethodNoTunnel;
    sourceMysqlUpdateSshTunnelMethodPasswordAuthentication: outputs.GetSourceMysqlConfigurationTunnelMethodSourceMysqlUpdateSshTunnelMethodPasswordAuthentication;
    sourceMysqlUpdateSshTunnelMethodSshKeyAuthentication: outputs.GetSourceMysqlConfigurationTunnelMethodSourceMysqlUpdateSshTunnelMethodSshKeyAuthentication;
}

export interface GetSourceMysqlConfigurationTunnelMethodSourceMysqlSshTunnelMethodNoTunnel {
    tunnelMethod: string;
}

export interface GetSourceMysqlConfigurationTunnelMethodSourceMysqlSshTunnelMethodPasswordAuthentication {
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
    tunnelUserPassword: string;
}

export interface GetSourceMysqlConfigurationTunnelMethodSourceMysqlSshTunnelMethodSshKeyAuthentication {
    sshKey: string;
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
}

export interface GetSourceMysqlConfigurationTunnelMethodSourceMysqlUpdateSshTunnelMethodNoTunnel {
    tunnelMethod: string;
}

export interface GetSourceMysqlConfigurationTunnelMethodSourceMysqlUpdateSshTunnelMethodPasswordAuthentication {
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
    tunnelUserPassword: string;
}

export interface GetSourceMysqlConfigurationTunnelMethodSourceMysqlUpdateSshTunnelMethodSshKeyAuthentication {
    sshKey: string;
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
}

export interface GetSourceNetsuiteConfiguration {
    /**
     * Consumer key associated with your integration
     */
    consumerKey: string;
    /**
     * Consumer secret associated with your integration
     */
    consumerSecret: string;
    /**
     * The API names of the Netsuite objects you want to sync. Setting this speeds up the connection setup process by limiting the number of schemas that need to be retrieved from Netsuite.
     */
    objectTypes: string[];
    /**
     * Netsuite realm e.g. 2344535, as for `production` or 2344535_SB1, as for the `sandbox`
     */
    realm: string;
    /**
     * must be one of ["netsuite"]
     */
    sourceType: string;
    /**
     * Starting point for your data replication, in format of "YYYY-MM-DDTHH:mm:ssZ"
     */
    startDatetime: string;
    /**
     * Access token key
     */
    tokenKey: string;
    /**
     * Access token secret
     */
    tokenSecret: string;
    /**
     * The amount of days used to query the data with date chunks. Set smaller value, if you have lots of data.
     */
    windowInDays: number;
}

export interface GetSourceNotionConfiguration {
    /**
     * Pick an authentication method.
     */
    credentials: outputs.GetSourceNotionConfigurationCredentials;
    /**
     * must be one of ["notion"]
     */
    sourceType: string;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00.000Z. Any data before this date will not be replicated.
     */
    startDate: string;
}

export interface GetSourceNotionConfigurationCredentials {
    sourceNotionAuthenticateUsingAccessToken: outputs.GetSourceNotionConfigurationCredentialsSourceNotionAuthenticateUsingAccessToken;
    sourceNotionAuthenticateUsingOAuth20: outputs.GetSourceNotionConfigurationCredentialsSourceNotionAuthenticateUsingOAuth20;
    sourceNotionUpdateAuthenticateUsingAccessToken: outputs.GetSourceNotionConfigurationCredentialsSourceNotionUpdateAuthenticateUsingAccessToken;
    sourceNotionUpdateAuthenticateUsingOAuth20: outputs.GetSourceNotionConfigurationCredentialsSourceNotionUpdateAuthenticateUsingOAuth20;
}

export interface GetSourceNotionConfigurationCredentialsSourceNotionAuthenticateUsingAccessToken {
    authType: string;
    token: string;
}

export interface GetSourceNotionConfigurationCredentialsSourceNotionAuthenticateUsingOAuth20 {
    accessToken: string;
    authType: string;
    clientId: string;
    clientSecret: string;
}

export interface GetSourceNotionConfigurationCredentialsSourceNotionUpdateAuthenticateUsingAccessToken {
    authType: string;
    token: string;
}

export interface GetSourceNotionConfigurationCredentialsSourceNotionUpdateAuthenticateUsingOAuth20 {
    accessToken: string;
    authType: string;
    clientId: string;
    clientSecret: string;
}

export interface GetSourceNytimesConfiguration {
    /**
     * API Key
     */
    apiKey: string;
    /**
     * End date to stop the article retrieval (format YYYY-MM)
     */
    endDate: string;
    /**
     * must be one of ["1", "7", "30"]
     * Period of time (in days)
     */
    period: number;
    /**
     * must be one of ["facebook"]
     * Share Type
     */
    shareType: string;
    /**
     * must be one of ["nytimes"]
     */
    sourceType: string;
    /**
     * Start date to begin the article retrieval (format YYYY-MM)
     */
    startDate: string;
}

export interface GetSourceOktaConfiguration {
    credentials: outputs.GetSourceOktaConfigurationCredentials;
    /**
     * The Okta domain. See the \n\ndocs\n\n for instructions on how to find it.
     */
    domain: string;
    /**
     * must be one of ["okta"]
     */
    sourceType: string;
    /**
     * UTC date and time in the format YYYY-MM-DDTHH:MM:SSZ. Any data before this date will not be replicated.
     */
    startDate: string;
}

export interface GetSourceOktaConfigurationCredentials {
    sourceOktaAuthorizationMethodApiToken: outputs.GetSourceOktaConfigurationCredentialsSourceOktaAuthorizationMethodApiToken;
    sourceOktaAuthorizationMethodOAuth20: outputs.GetSourceOktaConfigurationCredentialsSourceOktaAuthorizationMethodOAuth20;
    sourceOktaUpdateAuthorizationMethodApiToken: outputs.GetSourceOktaConfigurationCredentialsSourceOktaUpdateAuthorizationMethodApiToken;
    sourceOktaUpdateAuthorizationMethodOAuth20: outputs.GetSourceOktaConfigurationCredentialsSourceOktaUpdateAuthorizationMethodOAuth20;
}

export interface GetSourceOktaConfigurationCredentialsSourceOktaAuthorizationMethodApiToken {
    apiToken: string;
    authType: string;
}

export interface GetSourceOktaConfigurationCredentialsSourceOktaAuthorizationMethodOAuth20 {
    authType: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
}

export interface GetSourceOktaConfigurationCredentialsSourceOktaUpdateAuthorizationMethodApiToken {
    apiToken: string;
    authType: string;
}

export interface GetSourceOktaConfigurationCredentialsSourceOktaUpdateAuthorizationMethodOAuth20 {
    authType: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
}

export interface GetSourceOmnisendConfiguration {
    /**
     * API Key
     */
    apiKey: string;
    /**
     * must be one of ["omnisend"]
     */
    sourceType: string;
}

export interface GetSourceOnesignalConfiguration {
    /**
     * Applications keys, see the \n\ndocs\n\n for more information on how to obtain this data
     */
    applications: outputs.GetSourceOnesignalConfigurationApplication[];
    /**
     * Comma-separated list of names and the value (sum/count) for the returned outcome data. See the \n\ndocs\n\n for more details
     */
    outcomeNames: string;
    /**
     * must be one of ["onesignal"]
     */
    sourceType: string;
    /**
     * The date from which you'd like to replicate data for OneSignal API, in the format YYYY-MM-DDT00:00:00Z. All data generated after this date will be replicated.
     */
    startDate: string;
    /**
     * OneSignal User Auth Key, see the \n\ndocs\n\n for more information on how to obtain this key.
     */
    userAuthKey: string;
}

export interface GetSourceOnesignalConfigurationApplication {
    appApiKey: string;
    appId: string;
    appName: string;
}

export interface GetSourceOpenweatherConfiguration {
    /**
     * Your OpenWeather API Key. See \n\nhere\n\n. The key is case sensitive.
     */
    appid: string;
    /**
     * must be one of ["af", "al", "ar", "az", "bg", "ca", "cz", "da", "de", "el", "en", "eu", "fa", "fi", "fr", "gl", "he", "hi", "hr", "hu", "id", "it", "ja", "kr", "la", "lt", "mk", "no", "nl", "pl", "pt", "pt*br", "ro", "ru", "sv", "se", "sk", "sl", "sp", "es", "sr", "th", "tr", "ua", "uk", "vi", "zh*cn", "zhTw", "zu"]
     * You can use lang parameter to get the output in your language. The contents of the description field will be translated. See \n\nhere\n\n for the list of supported languages.
     */
    lang: string;
    /**
     * Latitude for which you want to get weather condition from. (min -90, max 90)
     */
    lat: string;
    /**
     * Longitude for which you want to get weather condition from. (min -180, max 180)
     */
    lon: string;
    /**
     * must be one of ["openweather"]
     */
    sourceType: string;
    /**
     * must be one of ["standard", "metric", "imperial"]
     * Units of measurement. standard, metric and imperial units are available. If you do not use the units parameter, standard units will be applied by default.
     */
    units: string;
}

export interface GetSourceOracleConfiguration {
    /**
     * Connect data that will be used for DB connection
     */
    connectionData: outputs.GetSourceOracleConfigurationConnectionData;
    /**
     * The encryption method with is used when communicating with the database.
     */
    encryption: outputs.GetSourceOracleConfigurationEncryption;
    /**
     * Hostname of the database.
     */
    host: string;
    /**
     * Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
     */
    jdbcUrlParams: string;
    /**
     * The password associated with the username.
     */
    password: string;
    /**
     * Port of the database.
     * Oracle Corporations recommends the following port numbers:
     * 1521 - Default listening port for client connections to the listener.
     * 2484 - Recommended and officially registered listening port for client connections to the listener using TCP/IP with SSL
     */
    port: number;
    /**
     * The list of schemas to sync from. Defaults to user. Case sensitive.
     */
    schemas: string[];
    /**
     * must be one of ["oracle"]
     */
    sourceType: string;
    /**
     * Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
     */
    tunnelMethod: outputs.GetSourceOracleConfigurationTunnelMethod;
    /**
     * The username which is used to access the database.
     */
    username: string;
}

export interface GetSourceOracleConfigurationConnectionData {
    sourceOracleConnectByServiceName: outputs.GetSourceOracleConfigurationConnectionDataSourceOracleConnectByServiceName;
    sourceOracleConnectBySystemIdSid: outputs.GetSourceOracleConfigurationConnectionDataSourceOracleConnectBySystemIdSid;
    sourceOracleUpdateConnectByServiceName: outputs.GetSourceOracleConfigurationConnectionDataSourceOracleUpdateConnectByServiceName;
    sourceOracleUpdateConnectBySystemIdSid: outputs.GetSourceOracleConfigurationConnectionDataSourceOracleUpdateConnectBySystemIdSid;
}

export interface GetSourceOracleConfigurationConnectionDataSourceOracleConnectByServiceName {
    connectionType: string;
    serviceName: string;
}

export interface GetSourceOracleConfigurationConnectionDataSourceOracleConnectBySystemIdSid {
    connectionType: string;
    sid: string;
}

export interface GetSourceOracleConfigurationConnectionDataSourceOracleUpdateConnectByServiceName {
    connectionType: string;
    serviceName: string;
}

export interface GetSourceOracleConfigurationConnectionDataSourceOracleUpdateConnectBySystemIdSid {
    connectionType: string;
    sid: string;
}

export interface GetSourceOracleConfigurationEncryption {
    sourceOracleEncryptionNativeNetworkEncryptionNne: outputs.GetSourceOracleConfigurationEncryptionSourceOracleEncryptionNativeNetworkEncryptionNne;
    sourceOracleEncryptionTlsEncryptedVerifyCertificate: outputs.GetSourceOracleConfigurationEncryptionSourceOracleEncryptionTlsEncryptedVerifyCertificate;
    sourceOracleUpdateEncryptionNativeNetworkEncryptionNne: outputs.GetSourceOracleConfigurationEncryptionSourceOracleUpdateEncryptionNativeNetworkEncryptionNne;
    sourceOracleUpdateEncryptionTlsEncryptedVerifyCertificate: outputs.GetSourceOracleConfigurationEncryptionSourceOracleUpdateEncryptionTlsEncryptedVerifyCertificate;
}

export interface GetSourceOracleConfigurationEncryptionSourceOracleEncryptionNativeNetworkEncryptionNne {
    encryptionAlgorithm: string;
    encryptionMethod: string;
}

export interface GetSourceOracleConfigurationEncryptionSourceOracleEncryptionTlsEncryptedVerifyCertificate {
    encryptionMethod: string;
    sslCertificate: string;
}

export interface GetSourceOracleConfigurationEncryptionSourceOracleUpdateEncryptionNativeNetworkEncryptionNne {
    encryptionAlgorithm: string;
    encryptionMethod: string;
}

export interface GetSourceOracleConfigurationEncryptionSourceOracleUpdateEncryptionTlsEncryptedVerifyCertificate {
    encryptionMethod: string;
    sslCertificate: string;
}

export interface GetSourceOracleConfigurationTunnelMethod {
    sourceOracleSshTunnelMethodNoTunnel: outputs.GetSourceOracleConfigurationTunnelMethodSourceOracleSshTunnelMethodNoTunnel;
    sourceOracleSshTunnelMethodPasswordAuthentication: outputs.GetSourceOracleConfigurationTunnelMethodSourceOracleSshTunnelMethodPasswordAuthentication;
    sourceOracleSshTunnelMethodSshKeyAuthentication: outputs.GetSourceOracleConfigurationTunnelMethodSourceOracleSshTunnelMethodSshKeyAuthentication;
    sourceOracleUpdateSshTunnelMethodNoTunnel: outputs.GetSourceOracleConfigurationTunnelMethodSourceOracleUpdateSshTunnelMethodNoTunnel;
    sourceOracleUpdateSshTunnelMethodPasswordAuthentication: outputs.GetSourceOracleConfigurationTunnelMethodSourceOracleUpdateSshTunnelMethodPasswordAuthentication;
    sourceOracleUpdateSshTunnelMethodSshKeyAuthentication: outputs.GetSourceOracleConfigurationTunnelMethodSourceOracleUpdateSshTunnelMethodSshKeyAuthentication;
}

export interface GetSourceOracleConfigurationTunnelMethodSourceOracleSshTunnelMethodNoTunnel {
    tunnelMethod: string;
}

export interface GetSourceOracleConfigurationTunnelMethodSourceOracleSshTunnelMethodPasswordAuthentication {
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
    tunnelUserPassword: string;
}

export interface GetSourceOracleConfigurationTunnelMethodSourceOracleSshTunnelMethodSshKeyAuthentication {
    sshKey: string;
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
}

export interface GetSourceOracleConfigurationTunnelMethodSourceOracleUpdateSshTunnelMethodNoTunnel {
    tunnelMethod: string;
}

export interface GetSourceOracleConfigurationTunnelMethodSourceOracleUpdateSshTunnelMethodPasswordAuthentication {
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
    tunnelUserPassword: string;
}

export interface GetSourceOracleConfigurationTunnelMethodSourceOracleUpdateSshTunnelMethodSshKeyAuthentication {
    sshKey: string;
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
}

export interface GetSourceOrbConfiguration {
    /**
     * Orb API Key, issued from the Orb admin console.
     */
    apiKey: string;
    /**
     * When set to N, the connector will always refresh resources created within the past N days. By default, updated objects that are not newly created are not incrementally synced.
     */
    lookbackWindowDays: number;
    /**
     * Property key names to extract from all events, in order to enrich ledger entries corresponding to an event deduction.
     */
    numericEventPropertiesKeys: string[];
    /**
     * Orb Plan ID to filter subscriptions that should have usage fetched.
     */
    planId: string;
    /**
     * must be one of ["orb"]
     */
    sourceType: string;
    /**
     * UTC date and time in the format 2022-03-01T00:00:00Z. Any data with createdAt before this data will not be synced. For Subscription Usage, this becomes the `timeframeStart` API parameter.
     */
    startDate: string;
    /**
     * Property key names to extract from all events, in order to enrich ledger entries corresponding to an event deduction.
     */
    stringEventPropertiesKeys: string[];
    /**
     * Property key name to group subscription usage by.
     */
    subscriptionUsageGroupingKey: string;
}

export interface GetSourceOrbitConfiguration {
    /**
     * Authorizes you to work with Orbit workspaces associated with the token.
     */
    apiToken: string;
    /**
     * must be one of ["orbit"]
     */
    sourceType: string;
    /**
     * Date in the format 2022-06-26. Only load members whose last activities are after this date.
     */
    startDate: string;
    /**
     * The unique name of the workspace that your API token is associated with.
     */
    workspace: string;
}

export interface GetSourceOutbrainAmplifyConfiguration {
    /**
     * Credentials for making authenticated requests requires either username/password or access_token.
     */
    credentials: outputs.GetSourceOutbrainAmplifyConfigurationCredentials;
    /**
     * Date in the format YYYY-MM-DD.
     */
    endDate: string;
    /**
     * must be one of ["country", "region", "subregion"]
     * The granularity used for geo location data in reports.
     */
    geoLocationBreakdown: string;
    /**
     * must be one of ["daily", "weekly", "monthly"]
     * The granularity used for periodic data in reports. See \n\nthe docs\n\n.
     */
    reportGranularity: string;
    /**
     * must be one of ["outbrain-amplify"]
     */
    sourceType: string;
    /**
     * Date in the format YYYY-MM-DD eg. 2017-01-25. Any data before this date will not be replicated.
     */
    startDate: string;
}

export interface GetSourceOutbrainAmplifyConfigurationCredentials {
    sourceOutbrainAmplifyAuthenticationMethodAccessToken: outputs.GetSourceOutbrainAmplifyConfigurationCredentialsSourceOutbrainAmplifyAuthenticationMethodAccessToken;
    sourceOutbrainAmplifyAuthenticationMethodUsernamePassword: outputs.GetSourceOutbrainAmplifyConfigurationCredentialsSourceOutbrainAmplifyAuthenticationMethodUsernamePassword;
    sourceOutbrainAmplifyUpdateAuthenticationMethodAccessToken: outputs.GetSourceOutbrainAmplifyConfigurationCredentialsSourceOutbrainAmplifyUpdateAuthenticationMethodAccessToken;
    sourceOutbrainAmplifyUpdateAuthenticationMethodUsernamePassword: outputs.GetSourceOutbrainAmplifyConfigurationCredentialsSourceOutbrainAmplifyUpdateAuthenticationMethodUsernamePassword;
}

export interface GetSourceOutbrainAmplifyConfigurationCredentialsSourceOutbrainAmplifyAuthenticationMethodAccessToken {
    accessToken: string;
    type: string;
}

export interface GetSourceOutbrainAmplifyConfigurationCredentialsSourceOutbrainAmplifyAuthenticationMethodUsernamePassword {
    password: string;
    type: string;
    username: string;
}

export interface GetSourceOutbrainAmplifyConfigurationCredentialsSourceOutbrainAmplifyUpdateAuthenticationMethodAccessToken {
    accessToken: string;
    type: string;
}

export interface GetSourceOutbrainAmplifyConfigurationCredentialsSourceOutbrainAmplifyUpdateAuthenticationMethodUsernamePassword {
    password: string;
    type: string;
    username: string;
}

export interface GetSourceOutreachConfiguration {
    /**
     * The Client ID of your Outreach developer application.
     */
    clientId: string;
    /**
     * The Client Secret of your Outreach developer application.
     */
    clientSecret: string;
    /**
     * A Redirect URI is the location where the authorization server sends the user once the app has been successfully authorized and granted an authorization code or access token.
     */
    redirectUri: string;
    /**
     * The token for obtaining the new access token.
     */
    refreshToken: string;
    /**
     * must be one of ["outreach"]
     */
    sourceType: string;
    /**
     * The date from which you'd like to replicate data for Outreach API, in the format YYYY-MM-DDT00:00:00Z. All data generated after this date will be replicated.
     */
    startDate: string;
}

export interface GetSourcePaypalTransactionConfiguration {
    /**
     * The Client ID of your Paypal developer application.
     */
    clientId: string;
    /**
     * The Client Secret of your Paypal developer application.
     */
    clientSecret: string;
    /**
     * Determines whether to use the sandbox or production environment.
     */
    isSandbox: boolean;
    /**
     * The key to refresh the expired access token.
     */
    refreshToken: string;
    /**
     * must be one of ["paypal-transaction"]
     */
    sourceType: string;
    /**
     * Start Date for data extraction in \n\nISO format\n\n. Date must be in range from 3 years till 12 hrs before present time.
     */
    startDate: string;
}

export interface GetSourcePaystackConfiguration {
    /**
     * When set, the connector will always reload data from the past N days, where N is the value set here. This is useful if your data is updated after creation.
     */
    lookbackWindowDays: number;
    /**
     * The Paystack API key (usually starts with 'sk*live*'; find yours \n\nhere\n\n).
     */
    secretKey: string;
    /**
     * must be one of ["paystack"]
     */
    sourceType: string;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
     */
    startDate: string;
}

export interface GetSourcePendoConfiguration {
    apiKey: string;
    /**
     * must be one of ["pendo"]
     */
    sourceType: string;
}

export interface GetSourcePersistiqConfiguration {
    /**
     * PersistIq API Key. See the \n\ndocs\n\n for more information on where to find that key.
     */
    apiKey: string;
    /**
     * must be one of ["persistiq"]
     */
    sourceType: string;
}

export interface GetSourcePexelsApiConfiguration {
    /**
     * API key is required to access pexels api, For getting your's goto https://www.pexels.com/api/documentation and create account for free.
     */
    apiKey: string;
    /**
     * Optional, Desired photo color. Supported colors red, orange, yellow, green, turquoise, blue, violet, pink, brown, black, gray, white or any hexidecimal color code.
     */
    color: string;
    /**
     * Optional, The locale of the search you are performing. The current supported locales are 'en-US' 'pt-BR' 'es-ES' 'ca-ES' 'de-DE' 'it-IT' 'fr-FR' 'sv-SE' 'id-ID' 'pl-PL' 'ja-JP' 'zh-TW' 'zh-CN' 'ko-KR' 'th-TH' 'nl-NL' 'hu-HU' 'vi-VN' 'cs-CZ' 'da-DK' 'fi-FI' 'uk-UA' 'el-GR' 'ro-RO' 'nb-NO' 'sk-SK' 'tr-TR' 'ru-RU'.
     */
    locale: string;
    /**
     * Optional, Desired photo orientation. The current supported orientations are landscape, portrait or square
     */
    orientation: string;
    /**
     * Optional, the search query, Example Ocean, Tigers, Pears, etc.
     */
    query: string;
    /**
     * Optional, Minimum photo size. The current supported sizes are large(24MP), medium(12MP) or small(4MP).
     */
    size: string;
    /**
     * must be one of ["pexels-api"]
     */
    sourceType: string;
}

export interface GetSourcePinterestConfiguration {
    credentials: outputs.GetSourcePinterestConfigurationCredentials;
    /**
     * must be one of ["pinterest"]
     */
    sourceType: string;
    /**
     * A date in the format YYYY-MM-DD. If you have not set a date, it would be defaulted to latest allowed date by api (89 days from today).
     */
    startDate: string;
    /**
     * Entity statuses based off of campaigns, ad_groups, and ads. If you do not have a status set, it will be ignored completely.
     */
    statuses: string[];
}

export interface GetSourcePinterestConfigurationCredentials {
    sourcePinterestAuthorizationMethodAccessToken: outputs.GetSourcePinterestConfigurationCredentialsSourcePinterestAuthorizationMethodAccessToken;
    sourcePinterestAuthorizationMethodOAuth20: outputs.GetSourcePinterestConfigurationCredentialsSourcePinterestAuthorizationMethodOAuth20;
    sourcePinterestUpdateAuthorizationMethodAccessToken: outputs.GetSourcePinterestConfigurationCredentialsSourcePinterestUpdateAuthorizationMethodAccessToken;
    sourcePinterestUpdateAuthorizationMethodOAuth20: outputs.GetSourcePinterestConfigurationCredentialsSourcePinterestUpdateAuthorizationMethodOAuth20;
}

export interface GetSourcePinterestConfigurationCredentialsSourcePinterestAuthorizationMethodAccessToken {
    accessToken: string;
    authMethod: string;
}

export interface GetSourcePinterestConfigurationCredentialsSourcePinterestAuthorizationMethodOAuth20 {
    authMethod: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
}

export interface GetSourcePinterestConfigurationCredentialsSourcePinterestUpdateAuthorizationMethodAccessToken {
    accessToken: string;
    authMethod: string;
}

export interface GetSourcePinterestConfigurationCredentialsSourcePinterestUpdateAuthorizationMethodOAuth20 {
    authMethod: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
}

export interface GetSourcePipedriveConfiguration {
    authorization: outputs.GetSourcePipedriveConfigurationAuthorization;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated. When specified and not None, then stream will behave as incremental
     */
    replicationStartDate: string;
    /**
     * must be one of ["pipedrive"]
     */
    sourceType: string;
}

export interface GetSourcePipedriveConfigurationAuthorization {
    apiToken: string;
    authType: string;
}

export interface GetSourcePocketConfiguration {
    /**
     * The user's Pocket access token.
     */
    accessToken: string;
    /**
     * Your application's Consumer Key.
     */
    consumerKey: string;
    /**
     * must be one of ["article", "video", "image"]
     * Select the content type of the items to retrieve.
     */
    contentType: string;
    /**
     * must be one of ["simple", "complete"]
     * Select the granularity of the information about each item.
     */
    detailType: string;
    /**
     * Only return items from a particular `domain`.
     */
    domain: string;
    /**
     * Retrieve only favorited items.
     */
    favorite: boolean;
    /**
     * Only return items whose title or url contain the `search` string.
     */
    search: string;
    /**
     * Only return items modified since the given timestamp.
     */
    since: string;
    /**
     * must be one of ["newest", "oldest", "title", "site"]
     * Sort retrieved items by the given criteria.
     */
    sort: string;
    /**
     * must be one of ["pocket"]
     */
    sourceType: string;
    /**
     * must be one of ["unread", "archive", "all"]
     * Select the state of the items to retrieve.
     */
    state: string;
    /**
     * Return only items tagged with this tag name. Use *untagged* for retrieving only untagged items.
     */
    tag: string;
}

export interface GetSourcePokeapiConfiguration {
    /**
     * Pokemon requested from the API.
     */
    pokemonName: string;
    /**
     * must be one of ["pokeapi"]
     */
    sourceType: string;
}

export interface GetSourcePolygonStockApiConfiguration {
    /**
     * Determines whether or not the results are adjusted for splits. By default, results are adjusted and set to true. Set this to false to get results that are NOT adjusted for splits.
     */
    adjusted: string;
    /**
     * Your API ACCESS Key
     */
    apiKey: string;
    /**
     * The target date for the aggregate window.
     */
    endDate: string;
    /**
     * The target date for the aggregate window.
     */
    limit: number;
    /**
     * The size of the timespan multiplier.
     */
    multiplier: number;
    /**
     * Sort the results by timestamp. asc will return results in ascending order (oldest at the top), desc will return results in descending order (newest at the top).
     */
    sort: string;
    /**
     * must be one of ["polygon-stock-api"]
     */
    sourceType: string;
    /**
     * The beginning date for the aggregate window.
     */
    startDate: string;
    /**
     * The exchange symbol that this item is traded under.
     */
    stocksTicker: string;
    /**
     * The size of the time window.
     */
    timespan: string;
}

export interface GetSourcePostgresConfiguration {
    /**
     * Name of the database.
     */
    database: string;
    /**
     * Hostname of the database.
     */
    host: string;
    /**
     * Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (Eg. key1=value1&key2=value2&key3=value3). For more information read about \n\nJDBC URL parameters\n\n.
     */
    jdbcUrlParams: string;
    /**
     * Password associated with the username.
     */
    password: string;
    /**
     * Port of the database.
     */
    port: number;
    /**
     * Replication method for extracting data from the database.
     */
    replicationMethod: outputs.GetSourcePostgresConfigurationReplicationMethod;
    /**
     * The list of schemas (case sensitive) to sync from. Defaults to public.
     */
    schemas: string[];
    /**
     * must be one of ["postgres"]
     */
    sourceType: string;
    /**
     * SSL connection modes.
     * Read more \n\n in the docs\n\n.
     */
    sslMode: outputs.GetSourcePostgresConfigurationSslMode;
    /**
     * Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
     */
    tunnelMethod: outputs.GetSourcePostgresConfigurationTunnelMethod;
    /**
     * Username to access the database.
     */
    username: string;
}

export interface GetSourcePostgresConfigurationReplicationMethod {
    sourcePostgresReplicationMethodLogicalReplicationCdc: outputs.GetSourcePostgresConfigurationReplicationMethodSourcePostgresReplicationMethodLogicalReplicationCdc;
    sourcePostgresReplicationMethodStandard: outputs.GetSourcePostgresConfigurationReplicationMethodSourcePostgresReplicationMethodStandard;
    sourcePostgresReplicationMethodStandardXmin: outputs.GetSourcePostgresConfigurationReplicationMethodSourcePostgresReplicationMethodStandardXmin;
    sourcePostgresUpdateReplicationMethodLogicalReplicationCdc: outputs.GetSourcePostgresConfigurationReplicationMethodSourcePostgresUpdateReplicationMethodLogicalReplicationCdc;
    sourcePostgresUpdateReplicationMethodStandard: outputs.GetSourcePostgresConfigurationReplicationMethodSourcePostgresUpdateReplicationMethodStandard;
    sourcePostgresUpdateReplicationMethodStandardXmin: outputs.GetSourcePostgresConfigurationReplicationMethodSourcePostgresUpdateReplicationMethodStandardXmin;
}

export interface GetSourcePostgresConfigurationReplicationMethodSourcePostgresReplicationMethodLogicalReplicationCdc {
    additionalProperties?: string;
    initialWaitingSeconds: number;
    lsnCommitBehaviour: string;
    method: string;
    plugin: string;
    publication: string;
    queueSize: number;
    replicationSlot: string;
}

export interface GetSourcePostgresConfigurationReplicationMethodSourcePostgresReplicationMethodStandard {
    method: string;
}

export interface GetSourcePostgresConfigurationReplicationMethodSourcePostgresReplicationMethodStandardXmin {
    method: string;
}

export interface GetSourcePostgresConfigurationReplicationMethodSourcePostgresUpdateReplicationMethodLogicalReplicationCdc {
    additionalProperties?: string;
    initialWaitingSeconds: number;
    lsnCommitBehaviour: string;
    method: string;
    plugin: string;
    publication: string;
    queueSize: number;
    replicationSlot: string;
}

export interface GetSourcePostgresConfigurationReplicationMethodSourcePostgresUpdateReplicationMethodStandard {
    method: string;
}

export interface GetSourcePostgresConfigurationReplicationMethodSourcePostgresUpdateReplicationMethodStandardXmin {
    method: string;
}

export interface GetSourcePostgresConfigurationSslMode {
    sourcePostgresSslModesAllow: outputs.GetSourcePostgresConfigurationSslModeSourcePostgresSslModesAllow;
    sourcePostgresSslModesDisable: outputs.GetSourcePostgresConfigurationSslModeSourcePostgresSslModesDisable;
    sourcePostgresSslModesPrefer: outputs.GetSourcePostgresConfigurationSslModeSourcePostgresSslModesPrefer;
    sourcePostgresSslModesRequire: outputs.GetSourcePostgresConfigurationSslModeSourcePostgresSslModesRequire;
    sourcePostgresSslModesVerifyCa: outputs.GetSourcePostgresConfigurationSslModeSourcePostgresSslModesVerifyCa;
    sourcePostgresSslModesVerifyFull: outputs.GetSourcePostgresConfigurationSslModeSourcePostgresSslModesVerifyFull;
    sourcePostgresUpdateSslModesAllow: outputs.GetSourcePostgresConfigurationSslModeSourcePostgresUpdateSslModesAllow;
    sourcePostgresUpdateSslModesDisable: outputs.GetSourcePostgresConfigurationSslModeSourcePostgresUpdateSslModesDisable;
    sourcePostgresUpdateSslModesPrefer: outputs.GetSourcePostgresConfigurationSslModeSourcePostgresUpdateSslModesPrefer;
    sourcePostgresUpdateSslModesRequire: outputs.GetSourcePostgresConfigurationSslModeSourcePostgresUpdateSslModesRequire;
    sourcePostgresUpdateSslModesVerifyCa: outputs.GetSourcePostgresConfigurationSslModeSourcePostgresUpdateSslModesVerifyCa;
    sourcePostgresUpdateSslModesVerifyFull: outputs.GetSourcePostgresConfigurationSslModeSourcePostgresUpdateSslModesVerifyFull;
}

export interface GetSourcePostgresConfigurationSslModeSourcePostgresSslModesAllow {
    additionalProperties?: string;
    mode: string;
}

export interface GetSourcePostgresConfigurationSslModeSourcePostgresSslModesDisable {
    additionalProperties?: string;
    mode: string;
}

export interface GetSourcePostgresConfigurationSslModeSourcePostgresSslModesPrefer {
    additionalProperties?: string;
    mode: string;
}

export interface GetSourcePostgresConfigurationSslModeSourcePostgresSslModesRequire {
    additionalProperties?: string;
    mode: string;
}

export interface GetSourcePostgresConfigurationSslModeSourcePostgresSslModesVerifyCa {
    additionalProperties?: string;
    caCertificate: string;
    clientCertificate: string;
    clientKey: string;
    clientKeyPassword: string;
    mode: string;
}

export interface GetSourcePostgresConfigurationSslModeSourcePostgresSslModesVerifyFull {
    additionalProperties?: string;
    caCertificate: string;
    clientCertificate: string;
    clientKey: string;
    clientKeyPassword: string;
    mode: string;
}

export interface GetSourcePostgresConfigurationSslModeSourcePostgresUpdateSslModesAllow {
    additionalProperties?: string;
    mode: string;
}

export interface GetSourcePostgresConfigurationSslModeSourcePostgresUpdateSslModesDisable {
    additionalProperties?: string;
    mode: string;
}

export interface GetSourcePostgresConfigurationSslModeSourcePostgresUpdateSslModesPrefer {
    additionalProperties?: string;
    mode: string;
}

export interface GetSourcePostgresConfigurationSslModeSourcePostgresUpdateSslModesRequire {
    additionalProperties?: string;
    mode: string;
}

export interface GetSourcePostgresConfigurationSslModeSourcePostgresUpdateSslModesVerifyCa {
    additionalProperties?: string;
    caCertificate: string;
    clientCertificate: string;
    clientKey: string;
    clientKeyPassword: string;
    mode: string;
}

export interface GetSourcePostgresConfigurationSslModeSourcePostgresUpdateSslModesVerifyFull {
    additionalProperties?: string;
    caCertificate: string;
    clientCertificate: string;
    clientKey: string;
    clientKeyPassword: string;
    mode: string;
}

export interface GetSourcePostgresConfigurationTunnelMethod {
    sourcePostgresSshTunnelMethodNoTunnel: outputs.GetSourcePostgresConfigurationTunnelMethodSourcePostgresSshTunnelMethodNoTunnel;
    sourcePostgresSshTunnelMethodPasswordAuthentication: outputs.GetSourcePostgresConfigurationTunnelMethodSourcePostgresSshTunnelMethodPasswordAuthentication;
    sourcePostgresSshTunnelMethodSshKeyAuthentication: outputs.GetSourcePostgresConfigurationTunnelMethodSourcePostgresSshTunnelMethodSshKeyAuthentication;
    sourcePostgresUpdateSshTunnelMethodNoTunnel: outputs.GetSourcePostgresConfigurationTunnelMethodSourcePostgresUpdateSshTunnelMethodNoTunnel;
    sourcePostgresUpdateSshTunnelMethodPasswordAuthentication: outputs.GetSourcePostgresConfigurationTunnelMethodSourcePostgresUpdateSshTunnelMethodPasswordAuthentication;
    sourcePostgresUpdateSshTunnelMethodSshKeyAuthentication: outputs.GetSourcePostgresConfigurationTunnelMethodSourcePostgresUpdateSshTunnelMethodSshKeyAuthentication;
}

export interface GetSourcePostgresConfigurationTunnelMethodSourcePostgresSshTunnelMethodNoTunnel {
    tunnelMethod: string;
}

export interface GetSourcePostgresConfigurationTunnelMethodSourcePostgresSshTunnelMethodPasswordAuthentication {
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
    tunnelUserPassword: string;
}

export interface GetSourcePostgresConfigurationTunnelMethodSourcePostgresSshTunnelMethodSshKeyAuthentication {
    sshKey: string;
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
}

export interface GetSourcePostgresConfigurationTunnelMethodSourcePostgresUpdateSshTunnelMethodNoTunnel {
    tunnelMethod: string;
}

export interface GetSourcePostgresConfigurationTunnelMethodSourcePostgresUpdateSshTunnelMethodPasswordAuthentication {
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
    tunnelUserPassword: string;
}

export interface GetSourcePostgresConfigurationTunnelMethodSourcePostgresUpdateSshTunnelMethodSshKeyAuthentication {
    sshKey: string;
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
}

export interface GetSourcePosthogConfiguration {
    /**
     * API Key. See the \n\ndocs\n\n for information on how to generate this key.
     */
    apiKey: string;
    /**
     * Base PostHog url. Defaults to PostHog Cloud (https://app.posthog.com).
     */
    baseUrl: string;
    /**
     * must be one of ["posthog"]
     */
    sourceType: string;
    /**
     * The date from which you'd like to replicate the data. Any data before this date will not be replicated.
     */
    startDate: string;
}

export interface GetSourcePostmarkappConfiguration {
    /**
     * must be one of ["postmarkapp"]
     */
    sourceType: string;
    /**
     * API Key for account
     */
    xPostmarkAccountToken: string;
    /**
     * API Key for server
     */
    xPostmarkServerToken: string;
}

export interface GetSourcePrestashopConfiguration {
    /**
     * Your PrestaShop access key. See \n\n the docs \n\n for info on how to obtain this.
     */
    accessKey: string;
    /**
     * must be one of ["prestashop"]
     */
    sourceType: string;
    /**
     * The Start date in the format YYYY-MM-DD.
     */
    startDate: string;
    /**
     * Shop URL without trailing slash.
     */
    url: string;
}

export interface GetSourcePublicApisConfiguration {
    /**
     * must be one of ["public-apis"]
     */
    sourceType: string;
}

export interface GetSourcePunkApiConfiguration {
    /**
     * To extract specific data with Unique ID
     */
    brewedAfter: string;
    /**
     * To extract specific data with Unique ID
     */
    brewedBefore: string;
    /**
     * To extract specific data with Unique ID
     */
    id: string;
    /**
     * must be one of ["punk-api"]
     */
    sourceType: string;
}

export interface GetSourcePypiConfiguration {
    /**
     * Name of the project/package. Can only be in lowercase with hyphen. This is the name used using pip command for installing the package.
     */
    projectName: string;
    /**
     * must be one of ["pypi"]
     */
    sourceType: string;
    /**
     * Version of the project/package.  Use it to find a particular release instead of all releases.
     */
    version: string;
}

export interface GetSourceQualarooConfiguration {
    /**
     * A Qualaroo token. See the \n\ndocs\n\n for instructions on how to generate it.
     */
    key: string;
    /**
     * must be one of ["qualaroo"]
     */
    sourceType: string;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
     */
    startDate: string;
    /**
     * IDs of the surveys from which you'd like to replicate data. If left empty, data from all surveys to which you have access will be replicated.
     */
    surveyIds: string[];
    /**
     * A Qualaroo token. See the \n\ndocs\n\n for instructions on how to generate it.
     */
    token: string;
}

export interface GetSourceQuickbooksConfiguration {
    credentials: outputs.GetSourceQuickbooksConfigurationCredentials;
    /**
     * Determines whether to use the sandbox or production environment.
     */
    sandbox: boolean;
    /**
     * must be one of ["quickbooks"]
     */
    sourceType: string;
    /**
     * The default value to use if no bookmark exists for an endpoint (rfc3339 date string). E.g, 2021-03-20T00:00:00Z. Any data before this date will not be replicated.
     */
    startDate: string;
}

export interface GetSourceQuickbooksConfigurationCredentials {
    sourceQuickbooksAuthorizationMethodOAuth20: outputs.GetSourceQuickbooksConfigurationCredentialsSourceQuickbooksAuthorizationMethodOAuth20;
    sourceQuickbooksUpdateAuthorizationMethodOAuth20: outputs.GetSourceQuickbooksConfigurationCredentialsSourceQuickbooksUpdateAuthorizationMethodOAuth20;
}

export interface GetSourceQuickbooksConfigurationCredentialsSourceQuickbooksAuthorizationMethodOAuth20 {
    accessToken: string;
    authType: string;
    clientId: string;
    clientSecret: string;
    realmId: string;
    refreshToken: string;
    tokenExpiryDate: string;
}

export interface GetSourceQuickbooksConfigurationCredentialsSourceQuickbooksUpdateAuthorizationMethodOAuth20 {
    accessToken: string;
    authType: string;
    clientId: string;
    clientSecret: string;
    realmId: string;
    refreshToken: string;
    tokenExpiryDate: string;
}

export interface GetSourceRailzConfiguration {
    /**
     * Client ID (client_id)
     */
    clientId: string;
    /**
     * Secret key (secret_key)
     */
    secretKey: string;
    /**
     * must be one of ["railz"]
     */
    sourceType: string;
    /**
     * Start date
     */
    startDate: string;
}

export interface GetSourceRechargeConfiguration {
    /**
     * The value of the Access Token generated. See the \n\ndocs\n\n for more information.
     */
    accessToken: string;
    /**
     * must be one of ["recharge"]
     */
    sourceType: string;
    /**
     * The date from which you'd like to replicate data for Recharge API, in the format YYYY-MM-DDT00:00:00Z. Any data before this date will not be replicated.
     */
    startDate: string;
}

export interface GetSourceRecreationConfiguration {
    /**
     * API Key
     */
    apikey: string;
    queryCampsites: string;
    /**
     * must be one of ["recreation"]
     */
    sourceType: string;
}

export interface GetSourceRecruiteeConfiguration {
    /**
     * Recruitee API Key. See \n\nhere\n\n.
     */
    apiKey: string;
    /**
     * Recruitee Company ID. You can also find this ID on the \n\nRecruitee API tokens page\n\n.
     */
    companyId: number;
    /**
     * must be one of ["recruitee"]
     */
    sourceType: string;
}

export interface GetSourceRecurlyConfiguration {
    /**
     * Recurly API Key. See the  \n\ndocs\n\n for more information on how to generate this key.
     */
    apiKey: string;
    /**
     * ISO8601 timestamp from which the replication from Recurly API will start from.
     */
    beginTime: string;
    /**
     * ISO8601 timestamp to which the replication from Recurly API will stop. Records after that date won't be imported.
     */
    endTime: string;
    /**
     * must be one of ["recurly"]
     */
    sourceType: string;
}

export interface GetSourceRedshiftConfiguration {
    /**
     * Name of the database.
     */
    database: string;
    /**
     * Host Endpoint of the Redshift Cluster (must include the cluster-id, region and end with .redshift.amazonaws.com).
     */
    host: string;
    /**
     * Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
     */
    jdbcUrlParams: string;
    /**
     * Password associated with the username.
     */
    password: string;
    /**
     * Port of the database.
     */
    port: number;
    /**
     * The list of schemas to sync from. Specify one or more explicitly or keep empty to process all schemas. Schema names are case sensitive.
     */
    schemas: string[];
    /**
     * must be one of ["redshift"]
     */
    sourceType: string;
    /**
     * Username to use to access the database.
     */
    username: string;
}

export interface GetSourceRetentlyConfiguration {
    /**
     * Choose how to authenticate to Retently
     */
    credentials: outputs.GetSourceRetentlyConfigurationCredentials;
    /**
     * must be one of ["retently"]
     */
    sourceType: string;
}

export interface GetSourceRetentlyConfigurationCredentials {
    sourceRetentlyAuthenticationMechanismAuthenticateViaRetentlyOAuth: outputs.GetSourceRetentlyConfigurationCredentialsSourceRetentlyAuthenticationMechanismAuthenticateViaRetentlyOAuth;
    sourceRetentlyAuthenticationMechanismAuthenticateWithApiToken: outputs.GetSourceRetentlyConfigurationCredentialsSourceRetentlyAuthenticationMechanismAuthenticateWithApiToken;
    sourceRetentlyUpdateAuthenticationMechanismAuthenticateViaRetentlyOAuth: outputs.GetSourceRetentlyConfigurationCredentialsSourceRetentlyUpdateAuthenticationMechanismAuthenticateViaRetentlyOAuth;
    sourceRetentlyUpdateAuthenticationMechanismAuthenticateWithApiToken: outputs.GetSourceRetentlyConfigurationCredentialsSourceRetentlyUpdateAuthenticationMechanismAuthenticateWithApiToken;
}

export interface GetSourceRetentlyConfigurationCredentialsSourceRetentlyAuthenticationMechanismAuthenticateViaRetentlyOAuth {
    additionalProperties?: string;
    authType: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
}

export interface GetSourceRetentlyConfigurationCredentialsSourceRetentlyAuthenticationMechanismAuthenticateWithApiToken {
    additionalProperties?: string;
    apiKey: string;
    authType: string;
}

export interface GetSourceRetentlyConfigurationCredentialsSourceRetentlyUpdateAuthenticationMechanismAuthenticateViaRetentlyOAuth {
    additionalProperties?: string;
    authType: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
}

export interface GetSourceRetentlyConfigurationCredentialsSourceRetentlyUpdateAuthenticationMechanismAuthenticateWithApiToken {
    additionalProperties?: string;
    apiKey: string;
    authType: string;
}

export interface GetSourceRkiCovidConfiguration {
    /**
     * must be one of ["rki-covid"]
     */
    sourceType: string;
    /**
     * UTC date in the format 2017-01-25. Any data before this date will not be replicated.
     */
    startDate: string;
}

export interface GetSourceRssConfiguration {
    /**
     * must be one of ["rss"]
     */
    sourceType: string;
    /**
     * RSS Feed URL
     */
    url: string;
}

export interface GetSourceS3Configuration {
    /**
     * The name of the stream you would like this source to output. Can contain letters, numbers, or underscores.
     */
    dataset: string;
    /**
     * The format of the files you'd like to replicate
     */
    format: outputs.GetSourceS3ConfigurationFormat;
    /**
     * A regular expression which tells the connector which files to replicate. All files which match this pattern will be replicated. Use | to separate multiple patterns. See \n\nthis page\n\n to understand pattern syntax (GLOBSTAR and SPLIT flags are enabled). Use pattern \n\n**\n\n to pick up all files.
     */
    pathPattern: string;
    /**
     * Use this to load files from S3 or S3-compatible services
     */
    provider: outputs.GetSourceS3ConfigurationProvider;
    /**
     * Optionally provide a schema to enforce, as a valid JSON string. Ensure this is a mapping of \n\n{ "column" : "type" }\n\n, where types are valid \n\nJSON Schema datatypes\n\n. Leave as {} to auto-infer the schema.
     */
    schema: string;
    /**
     * must be one of ["s3"]
     */
    sourceType: string;
}

export interface GetSourceS3ConfigurationFormat {
    sourceS3FileFormatAvro: outputs.GetSourceS3ConfigurationFormatSourceS3FileFormatAvro;
    sourceS3FileFormatCsv: outputs.GetSourceS3ConfigurationFormatSourceS3FileFormatCsv;
    sourceS3FileFormatJsonl: outputs.GetSourceS3ConfigurationFormatSourceS3FileFormatJsonl;
    sourceS3FileFormatParquet: outputs.GetSourceS3ConfigurationFormatSourceS3FileFormatParquet;
    sourceS3UpdateFileFormatAvro: outputs.GetSourceS3ConfigurationFormatSourceS3UpdateFileFormatAvro;
    sourceS3UpdateFileFormatCsv: outputs.GetSourceS3ConfigurationFormatSourceS3UpdateFileFormatCsv;
    sourceS3UpdateFileFormatJsonl: outputs.GetSourceS3ConfigurationFormatSourceS3UpdateFileFormatJsonl;
    sourceS3UpdateFileFormatParquet: outputs.GetSourceS3ConfigurationFormatSourceS3UpdateFileFormatParquet;
}

export interface GetSourceS3ConfigurationFormatSourceS3FileFormatAvro {
    filetype: string;
}

export interface GetSourceS3ConfigurationFormatSourceS3FileFormatCsv {
    additionalReaderOptions: string;
    advancedOptions: string;
    blockSize: number;
    delimiter: string;
    doubleQuote: boolean;
    encoding: string;
    escapeChar: string;
    filetype: string;
    inferDatatypes: boolean;
    newlinesInValues: boolean;
    quoteChar: string;
}

export interface GetSourceS3ConfigurationFormatSourceS3FileFormatJsonl {
    blockSize: number;
    filetype: string;
    newlinesInValues: boolean;
    unexpectedFieldBehavior: string;
}

export interface GetSourceS3ConfigurationFormatSourceS3FileFormatParquet {
    batchSize: number;
    bufferSize: number;
    columns: string[];
    filetype: string;
}

export interface GetSourceS3ConfigurationFormatSourceS3UpdateFileFormatAvro {
    filetype: string;
}

export interface GetSourceS3ConfigurationFormatSourceS3UpdateFileFormatCsv {
    additionalReaderOptions: string;
    advancedOptions: string;
    blockSize: number;
    delimiter: string;
    doubleQuote: boolean;
    encoding: string;
    escapeChar: string;
    filetype: string;
    inferDatatypes: boolean;
    newlinesInValues: boolean;
    quoteChar: string;
}

export interface GetSourceS3ConfigurationFormatSourceS3UpdateFileFormatJsonl {
    blockSize: number;
    filetype: string;
    newlinesInValues: boolean;
    unexpectedFieldBehavior: string;
}

export interface GetSourceS3ConfigurationFormatSourceS3UpdateFileFormatParquet {
    batchSize: number;
    bufferSize: number;
    columns: string[];
    filetype: string;
}

export interface GetSourceS3ConfigurationProvider {
    awsAccessKeyId: string;
    awsSecretAccessKey: string;
    bucket: string;
    endpoint: string;
    pathPrefix: string;
    startDate: string;
}

export interface GetSourceSalesforceConfiguration {
    /**
     * must be one of ["Client"]
     */
    authType: string;
    /**
     * Enter your Salesforce developer application's \n\nClient ID\n\n
     */
    clientId: string;
    /**
     * Enter your Salesforce developer application's \n\nClient secret\n\n
     */
    clientSecret: string;
    /**
     * Toggle to use Bulk API (this might cause empty fields for some streams)
     */
    forceUseBulkApi: boolean;
    /**
     * Toggle if you're using a \n\nSalesforce Sandbox\n\n
     */
    isSandbox: boolean;
    /**
     * Enter your application's \n\nSalesforce Refresh Token\n\n used for Airbyte to access your Salesforce account.
     */
    refreshToken: string;
    /**
     * must be one of ["salesforce"]
     */
    sourceType: string;
    /**
     * Enter the date (or date-time) in the YYYY-MM-DD or YYYY-MM-DDTHH:mm:ssZ format. Airbyte will replicate the data updated on and after this date. If this field is blank, Airbyte will replicate the data for last two years.
     */
    startDate: string;
    /**
     * Add filters to select only required stream based on `SObject` name. Use this field to filter which tables are displayed by this connector. This is useful if your Salesforce account has a large number of tables (>1000), in which case you may find it easier to navigate the UI and speed up the connector's performance if you restrict the tables displayed by this connector.
     */
    streamsCriterias: outputs.GetSourceSalesforceConfigurationStreamsCriteria[];
}

export interface GetSourceSalesforceConfigurationStreamsCriteria {
    criteria: string;
    value: string;
}

export interface GetSourceSalesloftConfiguration {
    credentials: outputs.GetSourceSalesloftConfigurationCredentials;
    /**
     * must be one of ["salesloft"]
     */
    sourceType: string;
    /**
     * The date from which you'd like to replicate data for Salesloft API, in the format YYYY-MM-DDT00:00:00Z. All data generated after this date will be replicated.
     */
    startDate: string;
}

export interface GetSourceSalesloftConfigurationCredentials {
    sourceSalesloftCredentialsAuthenticateViaApiKey: outputs.GetSourceSalesloftConfigurationCredentialsSourceSalesloftCredentialsAuthenticateViaApiKey;
    sourceSalesloftCredentialsAuthenticateViaOAuth: outputs.GetSourceSalesloftConfigurationCredentialsSourceSalesloftCredentialsAuthenticateViaOAuth;
    sourceSalesloftUpdateCredentialsAuthenticateViaApiKey: outputs.GetSourceSalesloftConfigurationCredentialsSourceSalesloftUpdateCredentialsAuthenticateViaApiKey;
    sourceSalesloftUpdateCredentialsAuthenticateViaOAuth: outputs.GetSourceSalesloftConfigurationCredentialsSourceSalesloftUpdateCredentialsAuthenticateViaOAuth;
}

export interface GetSourceSalesloftConfigurationCredentialsSourceSalesloftCredentialsAuthenticateViaApiKey {
    apiKey: string;
    authType: string;
}

export interface GetSourceSalesloftConfigurationCredentialsSourceSalesloftCredentialsAuthenticateViaOAuth {
    accessToken: string;
    authType: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
    tokenExpiryDate: string;
}

export interface GetSourceSalesloftConfigurationCredentialsSourceSalesloftUpdateCredentialsAuthenticateViaApiKey {
    apiKey: string;
    authType: string;
}

export interface GetSourceSalesloftConfigurationCredentialsSourceSalesloftUpdateCredentialsAuthenticateViaOAuth {
    accessToken: string;
    authType: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
    tokenExpiryDate: string;
}

export interface GetSourceSapFieldglassConfiguration {
    /**
     * API Key
     */
    apiKey: string;
    /**
     * must be one of ["sap-fieldglass"]
     */
    sourceType: string;
}

export interface GetSourceSecodaConfiguration {
    /**
     * Your API Access Key. See \n\nhere\n\n. The key is case sensitive.
     */
    apiKey: string;
    /**
     * must be one of ["secoda"]
     */
    sourceType: string;
}

export interface GetSourceSendgridConfiguration {
    /**
     * API Key, use \n\nadmin\n\n to generate this key.
     */
    apikey: string;
    /**
     * must be one of ["sendgrid"]
     */
    sourceType: string;
    /**
     * Start time in ISO8601 format. Any data before this time point will not be replicated.
     */
    startTime: string;
}

export interface GetSourceSendinblueConfiguration {
    /**
     * Your API Key. See \n\nhere\n\n.
     */
    apiKey: string;
    /**
     * must be one of ["sendinblue"]
     */
    sourceType: string;
}

export interface GetSourceSenseforceConfiguration {
    /**
     * Your API access token. See \n\nhere\n\n. The toke is case sensitive.
     */
    accessToken: string;
    /**
     * Your Senseforce API backend URL. This is the URL shown during the Login screen. See \n\nhere\n\n for more details. (Note: Most Senseforce backend APIs have the term 'galaxy' in their ULR)
     */
    backendUrl: string;
    /**
     * The ID of the dataset you want to synchronize. The ID can be found in the URL when opening the dataset. See \n\nhere\n\n for more details. (Note: As the Senseforce API only allows to synchronize a specific dataset, each dataset you  want to synchronize needs to be implemented as a separate airbyte source).
     */
    datasetId: string;
    /**
     * The time increment used by the connector when requesting data from the Senseforce API. The bigger the value is, the less requests will be made and faster the sync will be. On the other hand, the more seldom the state is persisted and the more likely one could run into rate limites.  Furthermore, consider that large chunks of time might take a long time for the Senseforce query to return data - meaning it could take in effect longer than with more smaller time slices. If there are a lot of data per day, set this setting to 1. If there is only very little data per day, you might change the setting to 10 or more.
     */
    sliceRange: number;
    /**
     * must be one of ["senseforce"]
     */
    sourceType: string;
    /**
     * UTC date and time in the format 2017-01-25. Only data with "Timestamp" after this date will be replicated. Important note: This start date must be set to the first day of where your dataset provides data.  If your dataset has data from 2020-10-10 10:21:10, set the startDate to 2020-10-10 or later
     */
    startDate: string;
}

export interface GetSourceSentryConfiguration {
    /**
     * Log into Sentry and then \n\ncreate authentication tokens\n\n.For self-hosted, you can find or create authentication tokens by visiting "{instance*url*prefix}/settings/account/api/auth-tokens/"
     */
    authToken: string;
    /**
     * Fields to retrieve when fetching discover events
     */
    discoverFields: string[];
    /**
     * Host name of Sentry API server.For self-hosted, specify your host name here. Otherwise, leave it empty.
     */
    hostname: string;
    /**
     * The slug of the organization the groups belong to.
     */
    organization: string;
    /**
     * The name (slug) of the Project you want to sync.
     */
    project: string;
    /**
     * must be one of ["sentry"]
     */
    sourceType: string;
}

export interface GetSourceSftpBulkConfiguration {
    /**
     * Sync only the most recent file for the configured folder path and file pattern
     */
    fileMostRecent: boolean;
    /**
     * The regular expression to specify files for sync in a chosen Folder Path
     */
    filePattern: string;
    /**
     * must be one of ["csv", "json"]
     * The file type you want to sync. Currently only 'csv' and 'json' files are supported.
     */
    fileType: string;
    /**
     * The directory to search files for sync
     */
    folderPath: string;
    /**
     * The server host address
     */
    host: string;
    /**
     * OS-level password for logging into the jump server host
     */
    password: string;
    /**
     * The server port
     */
    port: number;
    /**
     * The private key
     */
    privateKey: string;
    /**
     * The separator used in the CSV files. Define None if you want to use the Sniffer functionality
     */
    separator: string;
    /**
     * must be one of ["sftp-bulk"]
     */
    sourceType: string;
    /**
     * The date from which you'd like to replicate data for all incremental streams, in the format YYYY-MM-DDT00:00:00Z. All data generated after this date will be replicated.
     */
    startDate: string;
    /**
     * The name of the stream or table you want to create
     */
    streamName: string;
    /**
     * The server user
     */
    username: string;
}

export interface GetSourceSftpConfiguration {
    /**
     * The server authentication method
     */
    credentials: outputs.GetSourceSftpConfigurationCredentials;
    /**
     * The regular expression to specify files for sync in a chosen Folder Path
     */
    filePattern: string;
    /**
     * Coma separated file types. Currently only 'csv' and 'json' types are supported.
     */
    fileTypes: string;
    /**
     * The directory to search files for sync
     */
    folderPath: string;
    /**
     * The server host address
     */
    host: string;
    /**
     * The server port
     */
    port: number;
    /**
     * must be one of ["sftp"]
     */
    sourceType: string;
    /**
     * The server user
     */
    user: string;
}

export interface GetSourceSftpConfigurationCredentials {
    sourceSftpAuthenticationWildcardPasswordAuthentication: outputs.GetSourceSftpConfigurationCredentialsSourceSftpAuthenticationWildcardPasswordAuthentication;
    sourceSftpAuthenticationWildcardSshKeyAuthentication: outputs.GetSourceSftpConfigurationCredentialsSourceSftpAuthenticationWildcardSshKeyAuthentication;
    sourceSftpUpdateAuthenticationWildcardPasswordAuthentication: outputs.GetSourceSftpConfigurationCredentialsSourceSftpUpdateAuthenticationWildcardPasswordAuthentication;
    sourceSftpUpdateAuthenticationWildcardSshKeyAuthentication: outputs.GetSourceSftpConfigurationCredentialsSourceSftpUpdateAuthenticationWildcardSshKeyAuthentication;
}

export interface GetSourceSftpConfigurationCredentialsSourceSftpAuthenticationWildcardPasswordAuthentication {
    authMethod: string;
    authUserPassword: string;
}

export interface GetSourceSftpConfigurationCredentialsSourceSftpAuthenticationWildcardSshKeyAuthentication {
    authMethod: string;
    authSshKey: string;
}

export interface GetSourceSftpConfigurationCredentialsSourceSftpUpdateAuthenticationWildcardPasswordAuthentication {
    authMethod: string;
    authUserPassword: string;
}

export interface GetSourceSftpConfigurationCredentialsSourceSftpUpdateAuthenticationWildcardSshKeyAuthentication {
    authMethod: string;
    authSshKey: string;
}

export interface GetSourceShopifyConfiguration {
    /**
     * The authorization method to use to retrieve data from Shopify
     */
    credentials: outputs.GetSourceShopifyConfigurationCredentials;
    /**
     * The name of your Shopify store found in the URL. For example, if your URL was https://NAME.myshopify.com, then the name would be 'NAME' or 'NAME.myshopify.com'.
     */
    shop: string;
    /**
     * must be one of ["shopify"]
     */
    sourceType: string;
    /**
     * The date you would like to replicate data from. Format: YYYY-MM-DD. Any data before this date will not be replicated.
     */
    startDate: string;
}

export interface GetSourceShopifyConfigurationCredentials {
    sourceShopifyShopifyAuthorizationMethodApiPassword: outputs.GetSourceShopifyConfigurationCredentialsSourceShopifyShopifyAuthorizationMethodApiPassword;
    sourceShopifyShopifyAuthorizationMethodOAuth20: outputs.GetSourceShopifyConfigurationCredentialsSourceShopifyShopifyAuthorizationMethodOAuth20;
    sourceShopifyUpdateShopifyAuthorizationMethodApiPassword: outputs.GetSourceShopifyConfigurationCredentialsSourceShopifyUpdateShopifyAuthorizationMethodApiPassword;
    sourceShopifyUpdateShopifyAuthorizationMethodOAuth20: outputs.GetSourceShopifyConfigurationCredentialsSourceShopifyUpdateShopifyAuthorizationMethodOAuth20;
}

export interface GetSourceShopifyConfigurationCredentialsSourceShopifyShopifyAuthorizationMethodApiPassword {
    apiPassword: string;
    authMethod: string;
}

export interface GetSourceShopifyConfigurationCredentialsSourceShopifyShopifyAuthorizationMethodOAuth20 {
    accessToken: string;
    authMethod: string;
    clientId: string;
    clientSecret: string;
}

export interface GetSourceShopifyConfigurationCredentialsSourceShopifyUpdateShopifyAuthorizationMethodApiPassword {
    apiPassword: string;
    authMethod: string;
}

export interface GetSourceShopifyConfigurationCredentialsSourceShopifyUpdateShopifyAuthorizationMethodOAuth20 {
    accessToken: string;
    authMethod: string;
    clientId: string;
    clientSecret: string;
}

export interface GetSourceShortioConfiguration {
    domainId: string;
    /**
     * Short.io Secret Key
     */
    secretKey: string;
    /**
     * must be one of ["shortio"]
     */
    sourceType: string;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
     */
    startDate: string;
}

export interface GetSourceSlackConfiguration {
    /**
     * A channel name list (without leading '#' char) which limit the channels from which you'd like to sync. Empty list means no filter.
     */
    channelFilters: string[];
    /**
     * Choose how to authenticate into Slack
     */
    credentials: outputs.GetSourceSlackConfigurationCredentials;
    /**
     * Whether to join all channels or to sync data only from channels the bot is already in.  If false, you'll need to manually add the bot to all the channels from which you'd like to sync messages.
     */
    joinChannels: boolean;
    /**
     * How far into the past to look for messages in threads, default is 0 days
     */
    lookbackWindow: number;
    /**
     * must be one of ["slack"]
     */
    sourceType: string;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
     */
    startDate: string;
}

export interface GetSourceSlackConfigurationCredentials {
    sourceSlackAuthenticationMechanismApiToken: outputs.GetSourceSlackConfigurationCredentialsSourceSlackAuthenticationMechanismApiToken;
    sourceSlackAuthenticationMechanismSignInViaSlackOAuth: outputs.GetSourceSlackConfigurationCredentialsSourceSlackAuthenticationMechanismSignInViaSlackOAuth;
    sourceSlackUpdateAuthenticationMechanismApiToken: outputs.GetSourceSlackConfigurationCredentialsSourceSlackUpdateAuthenticationMechanismApiToken;
    sourceSlackUpdateAuthenticationMechanismSignInViaSlackOAuth: outputs.GetSourceSlackConfigurationCredentialsSourceSlackUpdateAuthenticationMechanismSignInViaSlackOAuth;
}

export interface GetSourceSlackConfigurationCredentialsSourceSlackAuthenticationMechanismApiToken {
    apiToken: string;
    optionTitle: string;
}

export interface GetSourceSlackConfigurationCredentialsSourceSlackAuthenticationMechanismSignInViaSlackOAuth {
    accessToken: string;
    clientId: string;
    clientSecret: string;
    optionTitle: string;
}

export interface GetSourceSlackConfigurationCredentialsSourceSlackUpdateAuthenticationMechanismApiToken {
    apiToken: string;
    optionTitle: string;
}

export interface GetSourceSlackConfigurationCredentialsSourceSlackUpdateAuthenticationMechanismSignInViaSlackOAuth {
    accessToken: string;
    clientId: string;
    clientSecret: string;
    optionTitle: string;
}

export interface GetSourceSmailyConfiguration {
    /**
     * API user password. See https://smaily.com/help/api/general/create-api-user/
     */
    apiPassword: string;
    /**
     * API Subdomain. See https://smaily.com/help/api/general/create-api-user/
     */
    apiSubdomain: string;
    /**
     * API user username. See https://smaily.com/help/api/general/create-api-user/
     */
    apiUsername: string;
    /**
     * must be one of ["smaily"]
     */
    sourceType: string;
}

export interface GetSourceSmartengageConfiguration {
    /**
     * API Key
     */
    apiKey: string;
    /**
     * must be one of ["smartengage"]
     */
    sourceType: string;
}

export interface GetSourceSmartsheetsConfiguration {
    credentials: outputs.GetSourceSmartsheetsConfigurationCredentials;
    /**
     * A List of available columns which metadata can be pulled from.
     */
    metadataFields: string[];
    /**
     * must be one of ["smartsheets"]
     */
    sourceType: string;
    /**
     * The spreadsheet ID. Find it by opening the spreadsheet then navigating to File > Properties
     */
    spreadsheetId: string;
    /**
     * Only rows modified after this date/time will be replicated. This should be an ISO 8601 string, for instance: `2000-01-01T13:00:00`
     */
    startDatetime: string;
}

export interface GetSourceSmartsheetsConfigurationCredentials {
    sourceSmartsheetsAuthorizationMethodApiAccessToken: outputs.GetSourceSmartsheetsConfigurationCredentialsSourceSmartsheetsAuthorizationMethodApiAccessToken;
    sourceSmartsheetsAuthorizationMethodOAuth20: outputs.GetSourceSmartsheetsConfigurationCredentialsSourceSmartsheetsAuthorizationMethodOAuth20;
    sourceSmartsheetsUpdateAuthorizationMethodApiAccessToken: outputs.GetSourceSmartsheetsConfigurationCredentialsSourceSmartsheetsUpdateAuthorizationMethodApiAccessToken;
    sourceSmartsheetsUpdateAuthorizationMethodOAuth20: outputs.GetSourceSmartsheetsConfigurationCredentialsSourceSmartsheetsUpdateAuthorizationMethodOAuth20;
}

export interface GetSourceSmartsheetsConfigurationCredentialsSourceSmartsheetsAuthorizationMethodApiAccessToken {
    accessToken: string;
    authType: string;
}

export interface GetSourceSmartsheetsConfigurationCredentialsSourceSmartsheetsAuthorizationMethodOAuth20 {
    accessToken: string;
    authType: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
    tokenExpiryDate: string;
}

export interface GetSourceSmartsheetsConfigurationCredentialsSourceSmartsheetsUpdateAuthorizationMethodApiAccessToken {
    accessToken: string;
    authType: string;
}

export interface GetSourceSmartsheetsConfigurationCredentialsSourceSmartsheetsUpdateAuthorizationMethodOAuth20 {
    accessToken: string;
    authType: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
    tokenExpiryDate: string;
}

export interface GetSourceSnapchatMarketingConfiguration {
    /**
     * The Client ID of your Snapchat developer application.
     */
    clientId: string;
    /**
     * The Client Secret of your Snapchat developer application.
     */
    clientSecret: string;
    /**
     * Date in the format 2017-01-25. Any data after this date will not be replicated.
     */
    endDate: string;
    /**
     * Refresh Token to renew the expired Access Token.
     */
    refreshToken: string;
    /**
     * must be one of ["snapchat-marketing"]
     */
    sourceType: string;
    /**
     * Date in the format 2022-01-01. Any data before this date will not be replicated.
     */
    startDate: string;
}

export interface GetSourceSnowflakeConfiguration {
    credentials: outputs.GetSourceSnowflakeConfigurationCredentials;
    /**
     * The database you created for Airbyte to access data.
     */
    database: string;
    /**
     * The host domain of the snowflake instance (must include the account, region, cloud environment, and end with snowflakecomputing.com).
     */
    host: string;
    /**
     * Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
     */
    jdbcUrlParams: string;
    /**
     * The role you created for Airbyte to access Snowflake.
     */
    role: string;
    /**
     * The source Snowflake schema tables. Leave empty to access tables from multiple schemas.
     */
    schema: string;
    /**
     * must be one of ["snowflake"]
     */
    sourceType: string;
    /**
     * The warehouse you created for Airbyte to access data.
     */
    warehouse: string;
}

export interface GetSourceSnowflakeConfigurationCredentials {
    sourceSnowflakeAuthorizationMethodOAuth20: outputs.GetSourceSnowflakeConfigurationCredentialsSourceSnowflakeAuthorizationMethodOAuth20;
    sourceSnowflakeAuthorizationMethodUsernameAndPassword: outputs.GetSourceSnowflakeConfigurationCredentialsSourceSnowflakeAuthorizationMethodUsernameAndPassword;
    sourceSnowflakeUpdateAuthorizationMethodOAuth20: outputs.GetSourceSnowflakeConfigurationCredentialsSourceSnowflakeUpdateAuthorizationMethodOAuth20;
    sourceSnowflakeUpdateAuthorizationMethodUsernameAndPassword: outputs.GetSourceSnowflakeConfigurationCredentialsSourceSnowflakeUpdateAuthorizationMethodUsernameAndPassword;
}

export interface GetSourceSnowflakeConfigurationCredentialsSourceSnowflakeAuthorizationMethodOAuth20 {
    accessToken: string;
    authType: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
}

export interface GetSourceSnowflakeConfigurationCredentialsSourceSnowflakeAuthorizationMethodUsernameAndPassword {
    authType: string;
    password: string;
    username: string;
}

export interface GetSourceSnowflakeConfigurationCredentialsSourceSnowflakeUpdateAuthorizationMethodOAuth20 {
    accessToken: string;
    authType: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
}

export interface GetSourceSnowflakeConfigurationCredentialsSourceSnowflakeUpdateAuthorizationMethodUsernameAndPassword {
    authType: string;
    password: string;
    username: string;
}

export interface GetSourceSonarCloudConfiguration {
    /**
     * Comma-separated list of component keys.
     */
    componentKeys: string[];
    /**
     * To retrieve issues created before the given date (inclusive).
     */
    endDate: string;
    /**
     * Organization key. See \n\nhere\n\n.
     */
    organization: string;
    /**
     * must be one of ["sonar-cloud"]
     */
    sourceType: string;
    /**
     * To retrieve issues created after the given date (inclusive).
     */
    startDate: string;
    /**
     * Your User Token. See \n\nhere\n\n. The token is case sensitive.
     */
    userToken: string;
}

export interface GetSourceSpaceXApiConfiguration {
    id: string;
    options: string;
    /**
     * must be one of ["spacex-api"]
     */
    sourceType: string;
}

export interface GetSourceSquareConfiguration {
    /**
     * Choose how to authenticate to Square.
     */
    credentials: outputs.GetSourceSquareConfigurationCredentials;
    /**
     * In some streams there is an option to include deleted objects (Items, Categories, Discounts, Taxes)
     */
    includeDeletedObjects: boolean;
    /**
     * Determines whether to use the sandbox or production environment.
     */
    isSandbox: boolean;
    /**
     * must be one of ["square"]
     */
    sourceType: string;
    /**
     * UTC date in the format YYYY-MM-DD. Any data before this date will not be replicated. If not set, all data will be replicated.
     */
    startDate: string;
}

export interface GetSourceSquareConfigurationCredentials {
    sourceSquareAuthenticationApiKey: outputs.GetSourceSquareConfigurationCredentialsSourceSquareAuthenticationApiKey;
    sourceSquareAuthenticationOauthAuthentication: outputs.GetSourceSquareConfigurationCredentialsSourceSquareAuthenticationOauthAuthentication;
    sourceSquareUpdateAuthenticationApiKey: outputs.GetSourceSquareConfigurationCredentialsSourceSquareUpdateAuthenticationApiKey;
    sourceSquareUpdateAuthenticationOauthAuthentication: outputs.GetSourceSquareConfigurationCredentialsSourceSquareUpdateAuthenticationOauthAuthentication;
}

export interface GetSourceSquareConfigurationCredentialsSourceSquareAuthenticationApiKey {
    apiKey: string;
    authType: string;
}

export interface GetSourceSquareConfigurationCredentialsSourceSquareAuthenticationOauthAuthentication {
    authType: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
}

export interface GetSourceSquareConfigurationCredentialsSourceSquareUpdateAuthenticationApiKey {
    apiKey: string;
    authType: string;
}

export interface GetSourceSquareConfigurationCredentialsSourceSquareUpdateAuthenticationOauthAuthentication {
    authType: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
}

export interface GetSourceStravaConfiguration {
    /**
     * The Athlete ID of your Strava developer application.
     */
    athleteId: number;
    /**
     * must be one of ["Client"]
     */
    authType: string;
    /**
     * The Client ID of your Strava developer application.
     */
    clientId: string;
    /**
     * The Client Secret of your Strava developer application.
     */
    clientSecret: string;
    /**
     * The Refresh Token with the activity: readAll permissions.
     */
    refreshToken: string;
    /**
     * must be one of ["strava"]
     */
    sourceType: string;
    /**
     * UTC date and time. Any data before this date will not be replicated.
     */
    startDate: string;
}

export interface GetSourceStripeConfiguration {
    /**
     * Your Stripe account ID (starts with 'acct_', find yours \n\nhere\n\n).
     */
    accountId: string;
    /**
     * Stripe API key (usually starts with 'sk*live*'; find yours \n\nhere\n\n).
     */
    clientSecret: string;
    /**
     * When set, the connector will always re-export data from the past N days, where N is the value set here. This is useful if your data is frequently updated after creation. More info \n\nhere\n\n
     */
    lookbackWindowDays: number;
    /**
     * The time increment used by the connector when requesting data from the Stripe API. The bigger the value is, the less requests will be made and faster the sync will be. On the other hand, the more seldom the state is persisted.
     */
    sliceRange: number;
    /**
     * must be one of ["stripe"]
     */
    sourceType: string;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Only data generated after this date will be replicated.
     */
    startDate: string;
}

export interface GetSourceSurveySparrowConfiguration {
    /**
     * Your access token. See \n\nhere\n\n. The key is case sensitive.
     */
    accessToken: string;
    /**
     * Is your account location is EU based? If yes, the base url to retrieve data will be different.
     */
    region: outputs.GetSourceSurveySparrowConfigurationRegion;
    /**
     * must be one of ["survey-sparrow"]
     */
    sourceType: string;
    /**
     * A List of your survey ids for survey-specific stream
     */
    surveyIds: string[];
}

export interface GetSourceSurveySparrowConfigurationRegion {
    sourceSurveySparrowBaseUrlEuBasedAccount: outputs.GetSourceSurveySparrowConfigurationRegionSourceSurveySparrowBaseUrlEuBasedAccount;
    sourceSurveySparrowBaseUrlGlobalAccount: outputs.GetSourceSurveySparrowConfigurationRegionSourceSurveySparrowBaseUrlGlobalAccount;
    sourceSurveySparrowUpdateBaseUrlEuBasedAccount: outputs.GetSourceSurveySparrowConfigurationRegionSourceSurveySparrowUpdateBaseUrlEuBasedAccount;
    sourceSurveySparrowUpdateBaseUrlGlobalAccount: outputs.GetSourceSurveySparrowConfigurationRegionSourceSurveySparrowUpdateBaseUrlGlobalAccount;
}

export interface GetSourceSurveySparrowConfigurationRegionSourceSurveySparrowBaseUrlEuBasedAccount {
    urlBase: string;
}

export interface GetSourceSurveySparrowConfigurationRegionSourceSurveySparrowBaseUrlGlobalAccount {
    urlBase: string;
}

export interface GetSourceSurveySparrowConfigurationRegionSourceSurveySparrowUpdateBaseUrlEuBasedAccount {
    urlBase: string;
}

export interface GetSourceSurveySparrowConfigurationRegionSourceSurveySparrowUpdateBaseUrlGlobalAccount {
    urlBase: string;
}

export interface GetSourceSurveymonkeyConfiguration {
    /**
     * The authorization method to use to retrieve data from SurveyMonkey
     */
    credentials: outputs.GetSourceSurveymonkeyConfigurationCredentials;
    /**
     * must be one of ["USA", "Europe", "Canada"]
     * Depending on the originating datacenter of the SurveyMonkey account, the API access URL may be different.
     */
    origin: string;
    /**
     * must be one of ["surveymonkey"]
     */
    sourceType: string;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
     */
    startDate: string;
    /**
     * IDs of the surveys from which you'd like to replicate data. If left empty, data from all boards to which you have access will be replicated.
     */
    surveyIds: string[];
}

export interface GetSourceSurveymonkeyConfigurationCredentials {
    accessToken: string;
    authMethod: string;
    clientId: string;
    clientSecret: string;
}

export interface GetSourceTempoConfiguration {
    /**
     * Tempo API Token. Go to Tempo>Settings, scroll down to Data Access and select API integration.
     */
    apiToken: string;
    /**
     * must be one of ["tempo"]
     */
    sourceType: string;
}

export interface GetSourceTheGuardianApiConfiguration {
    /**
     * Your API Key. See \n\nhere\n\n. The key is case sensitive.
     */
    apiKey: string;
    /**
     * (Optional) Use this to set the maximum date (YYYY-MM-DD) of the results. Results newer than the endDate will not be shown. Default is set to the current date (today) for incremental syncs.
     */
    endDate: string;
    /**
     * (Optional) The query (q) parameter filters the results to only those that include that search term. The q parameter supports AND, OR and NOT operators.
     */
    query: string;
    /**
     * (Optional) Use this to filter the results by a particular section. See \n\nhere\n\n for a list of all sections, and \n\nhere\n\n for the sections endpoint documentation.
     */
    section: string;
    /**
     * must be one of ["the-guardian-api"]
     */
    sourceType: string;
    /**
     * Use this to set the minimum date (YYYY-MM-DD) of the results. Results older than the startDate will not be shown.
     */
    startDate: string;
    /**
     * (Optional) A tag is a piece of data that is used by The Guardian to categorise content. Use this parameter to filter results by showing only the ones matching the entered tag. See \n\nhere\n\n for a list of all tags, and \n\nhere\n\n for the tags endpoint documentation.
     */
    tag: string;
}

export interface GetSourceTiktokMarketingConfiguration {
    /**
     * The attribution window in days.
     */
    attributionWindow: number;
    /**
     * Authentication method
     */
    credentials: outputs.GetSourceTiktokMarketingConfigurationCredentials;
    /**
     * The date until which you'd like to replicate data for all incremental streams, in the format YYYY-MM-DD. All data generated between startDate and this date will be replicated. Not setting this option will result in always syncing the data till the current date.
     */
    endDate: string;
    /**
     * Set to active if you want to include deleted data in reports.
     */
    includeDeleted: boolean;
    /**
     * must be one of ["tiktok-marketing"]
     */
    sourceType: string;
    /**
     * The Start Date in format: YYYY-MM-DD. Any data before this date will not be replicated. If this parameter is not set, all data will be replicated.
     */
    startDate: string;
}

export interface GetSourceTiktokMarketingConfigurationCredentials {
    sourceTiktokMarketingAuthenticationMethodOAuth20: outputs.GetSourceTiktokMarketingConfigurationCredentialsSourceTiktokMarketingAuthenticationMethodOAuth20;
    sourceTiktokMarketingAuthenticationMethodSandboxAccessToken: outputs.GetSourceTiktokMarketingConfigurationCredentialsSourceTiktokMarketingAuthenticationMethodSandboxAccessToken;
    sourceTiktokMarketingUpdateAuthenticationMethodOAuth20: outputs.GetSourceTiktokMarketingConfigurationCredentialsSourceTiktokMarketingUpdateAuthenticationMethodOAuth20;
    sourceTiktokMarketingUpdateAuthenticationMethodSandboxAccessToken: outputs.GetSourceTiktokMarketingConfigurationCredentialsSourceTiktokMarketingUpdateAuthenticationMethodSandboxAccessToken;
}

export interface GetSourceTiktokMarketingConfigurationCredentialsSourceTiktokMarketingAuthenticationMethodOAuth20 {
    accessToken: string;
    advertiserId: string;
    appId: string;
    authType: string;
    secret: string;
}

export interface GetSourceTiktokMarketingConfigurationCredentialsSourceTiktokMarketingAuthenticationMethodSandboxAccessToken {
    accessToken: string;
    advertiserId: string;
    authType: string;
}

export interface GetSourceTiktokMarketingConfigurationCredentialsSourceTiktokMarketingUpdateAuthenticationMethodOAuth20 {
    accessToken: string;
    advertiserId: string;
    appId: string;
    authType: string;
    secret: string;
}

export interface GetSourceTiktokMarketingConfigurationCredentialsSourceTiktokMarketingUpdateAuthenticationMethodSandboxAccessToken {
    accessToken: string;
    advertiserId: string;
    authType: string;
}

export interface GetSourceTodoistConfiguration {
    /**
     * must be one of ["todoist"]
     */
    sourceType: string;
    /**
     * Your API Token. See \n\nhere\n\n. The token is case sensitive.
     */
    token: string;
}

export interface GetSourceTrelloConfiguration {
    /**
     * IDs of the boards to replicate data from. If left empty, data from all boards to which you have access will be replicated.
     */
    boardIds: string[];
    /**
     * Trello API key. See the \n\ndocs\n\n for instructions on how to generate it.
     */
    key: string;
    /**
     * must be one of ["trello"]
     */
    sourceType: string;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
     */
    startDate: string;
    /**
     * Trello API token. See the \n\ndocs\n\n for instructions on how to generate it.
     */
    token: string;
}

export interface GetSourceTrustpilotConfiguration {
    /**
     * The names of business units which shall be synchronized. Some streams e.g. configured*business*units or privateReviews use this configuration.
     */
    businessUnits: string[];
    credentials: outputs.GetSourceTrustpilotConfigurationCredentials;
    /**
     * must be one of ["trustpilot"]
     */
    sourceType: string;
    /**
     * For streams with sync. method incremental the start date time to be used
     */
    startDate: string;
}

export interface GetSourceTrustpilotConfigurationCredentials {
    sourceTrustpilotAuthorizationMethodApiKey: outputs.GetSourceTrustpilotConfigurationCredentialsSourceTrustpilotAuthorizationMethodApiKey;
    sourceTrustpilotAuthorizationMethodOAuth20: outputs.GetSourceTrustpilotConfigurationCredentialsSourceTrustpilotAuthorizationMethodOAuth20;
    sourceTrustpilotUpdateAuthorizationMethodApiKey: outputs.GetSourceTrustpilotConfigurationCredentialsSourceTrustpilotUpdateAuthorizationMethodApiKey;
    sourceTrustpilotUpdateAuthorizationMethodOAuth20: outputs.GetSourceTrustpilotConfigurationCredentialsSourceTrustpilotUpdateAuthorizationMethodOAuth20;
}

export interface GetSourceTrustpilotConfigurationCredentialsSourceTrustpilotAuthorizationMethodApiKey {
    authType: string;
    clientId: string;
}

export interface GetSourceTrustpilotConfigurationCredentialsSourceTrustpilotAuthorizationMethodOAuth20 {
    accessToken: string;
    authType: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
    tokenExpiryDate: string;
}

export interface GetSourceTrustpilotConfigurationCredentialsSourceTrustpilotUpdateAuthorizationMethodApiKey {
    authType: string;
    clientId: string;
}

export interface GetSourceTrustpilotConfigurationCredentialsSourceTrustpilotUpdateAuthorizationMethodOAuth20 {
    accessToken: string;
    authType: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
    tokenExpiryDate: string;
}

export interface GetSourceTvmazeScheduleConfiguration {
    /**
     * Country code for domestic TV schedule retrieval.
     */
    domesticScheduleCountryCode: string;
    /**
     * End date for TV schedule retrieval. May be in the future. Optional.
     */
    endDate: string;
    /**
     * must be one of ["tvmaze-schedule"]
     */
    sourceType: string;
    /**
     * Start date for TV schedule retrieval. May be in the future.
     */
    startDate: string;
    /**
     * ISO 3166-1 country code for web TV schedule retrieval. Leave blank for
     * all countries plus global web channels (e.g. Netflix). Alternatively,
     * set to 'global' for just global web channels.
     */
    webScheduleCountryCode: string;
}

export interface GetSourceTwilioConfiguration {
    /**
     * Twilio account SID
     */
    accountSid: string;
    /**
     * Twilio Auth Token.
     */
    authToken: string;
    /**
     * How far into the past to look for records. (in minutes)
     */
    lookbackWindow: number;
    /**
     * must be one of ["twilio"]
     */
    sourceType: string;
    /**
     * UTC date and time in the format 2020-10-01T00:00:00Z. Any data before this date will not be replicated.
     */
    startDate: string;
}

export interface GetSourceTwilioTaskrouterConfiguration {
    /**
     * Twilio Account ID
     */
    accountSid: string;
    /**
     * Twilio Auth Token
     */
    authToken: string;
    /**
     * must be one of ["twilio-taskrouter"]
     */
    sourceType: string;
}

export interface GetSourceTwitterConfiguration {
    /**
     * App only Bearer Token. See the \n\ndocs\n\n for more information on how to obtain this token.
     */
    apiKey: string;
    /**
     * The end date for retrieving tweets must be a minimum of 10 seconds prior to the request time.
     */
    endDate: string;
    /**
     * Query for matching Tweets. You can learn how to build this query by reading \n\n build a query guide \n\n.
     */
    query: string;
    /**
     * must be one of ["twitter"]
     */
    sourceType: string;
    /**
     * The start date for retrieving tweets cannot be more than 7 days in the past.
     */
    startDate: string;
}

export interface GetSourceTypeformConfiguration {
    credentials: outputs.GetSourceTypeformConfigurationCredentials;
    /**
     * When this parameter is set, the connector will replicate data only from the input forms. Otherwise, all forms in your Typeform account will be replicated. You can find form IDs in your form URLs. For example, in the URL "https://mysite.typeform.com/to/u6nXL7" the formId is u6nXL7. You can find form URLs on Share panel
     */
    formIds: string[];
    /**
     * must be one of ["typeform"]
     */
    sourceType: string;
    /**
     * The date from which you'd like to replicate data for Typeform API, in the format YYYY-MM-DDT00:00:00Z. All data generated after this date will be replicated.
     */
    startDate: string;
}

export interface GetSourceTypeformConfigurationCredentials {
    sourceTypeformAuthorizationMethodOAuth20: outputs.GetSourceTypeformConfigurationCredentialsSourceTypeformAuthorizationMethodOAuth20;
    sourceTypeformAuthorizationMethodPrivateToken: outputs.GetSourceTypeformConfigurationCredentialsSourceTypeformAuthorizationMethodPrivateToken;
    sourceTypeformUpdateAuthorizationMethodOAuth20: outputs.GetSourceTypeformConfigurationCredentialsSourceTypeformUpdateAuthorizationMethodOAuth20;
    sourceTypeformUpdateAuthorizationMethodPrivateToken: outputs.GetSourceTypeformConfigurationCredentialsSourceTypeformUpdateAuthorizationMethodPrivateToken;
}

export interface GetSourceTypeformConfigurationCredentialsSourceTypeformAuthorizationMethodOAuth20 {
    accessToken: string;
    authType: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
    tokenExpiryDate: string;
}

export interface GetSourceTypeformConfigurationCredentialsSourceTypeformAuthorizationMethodPrivateToken {
    accessToken: string;
    authType: string;
}

export interface GetSourceTypeformConfigurationCredentialsSourceTypeformUpdateAuthorizationMethodOAuth20 {
    accessToken: string;
    authType: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
    tokenExpiryDate: string;
}

export interface GetSourceTypeformConfigurationCredentialsSourceTypeformUpdateAuthorizationMethodPrivateToken {
    accessToken: string;
    authType: string;
}

export interface GetSourceUsCensusConfiguration {
    /**
     * Your API Key. Get your key \n\nhere\n\n.
     */
    apiKey: string;
    /**
     * The query parameters portion of the GET request, without the api key
     */
    queryParams: string;
    /**
     * The path portion of the GET request
     */
    queryPath: string;
    /**
     * must be one of ["us-census"]
     */
    sourceType: string;
}

export interface GetSourceVantageConfiguration {
    /**
     * Your API Access token. See \n\nhere\n\n.
     */
    accessToken: string;
    /**
     * must be one of ["vantage"]
     */
    sourceType: string;
}

export interface GetSourceWebflowConfiguration {
    /**
     * The API token for authenticating to Webflow. See https://university.webflow.com/lesson/intro-to-the-webflow-api
     */
    apiKey: string;
    /**
     * The id of the Webflow site you are requesting data from. See https://developers.webflow.com/#sites
     */
    siteId: string;
    /**
     * must be one of ["webflow"]
     */
    sourceType: string;
}

export interface GetSourceWhiskyHunterConfiguration {
    /**
     * must be one of ["whisky-hunter"]
     */
    sourceType: string;
}

export interface GetSourceWikipediaPageviewsConfiguration {
    /**
     * If you want to filter by access method, use one of desktop, mobile-app or mobile-web. If you are interested in pageviews regardless of access method, use all-access.
     */
    access: string;
    /**
     * If you want to filter by agent type, use one of user, automated or spider. If you are interested in pageviews regardless of agent type, use all-agents.
     */
    agent: string;
    /**
     * The title of any article in the specified project. Any spaces should be replaced with underscores. It also should be URI-encoded, so that non-URI-safe characters like %, / or ? are accepted.
     */
    article: string;
    /**
     * The ISO 3166-1 alpha-2 code of a country for which to retrieve top articles.
     */
    country: string;
    /**
     * The date of the last day to include, in YYYYMMDD or YYYYMMDDHH format.
     */
    end: string;
    /**
     * If you want to filter by project, use the domain of any Wikimedia project.
     */
    project: string;
    /**
     * must be one of ["wikipedia-pageviews"]
     */
    sourceType: string;
    /**
     * The date of the first day to include, in YYYYMMDD or YYYYMMDDHH format.
     */
    start: string;
}

export interface GetSourceWoocommerceConfiguration {
    /**
     * Customer Key for API in WooCommerce shop
     */
    apiKey: string;
    /**
     * Customer Secret for API in WooCommerce shop
     */
    apiSecret: string;
    /**
     * The name of the store. For https://EXAMPLE.com, the shop name is 'EXAMPLE.com'.
     */
    shop: string;
    /**
     * must be one of ["woocommerce"]
     */
    sourceType: string;
    /**
     * The date you would like to replicate data from. Format: YYYY-MM-DD
     */
    startDate: string;
}

export interface GetSourceXeroConfiguration {
    authentication: outputs.GetSourceXeroConfigurationAuthentication;
    /**
     * must be one of ["xero"]
     */
    sourceType: string;
    /**
     * UTC date and time in the format YYYY-MM-DDTHH:mm:ssZ. Any data with createdAt before this data will not be synced.
     */
    startDate: string;
    /**
     * Enter your Xero organization's Tenant ID
     */
    tenantId: string;
}

export interface GetSourceXeroConfigurationAuthentication {
    accessToken: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
    tokenExpiryDate: string;
}

export interface GetSourceXkcdConfiguration {
    /**
     * must be one of ["xkcd"]
     */
    sourceType: string;
}

export interface GetSourceYandexMetricaConfiguration {
    /**
     * Your Yandex Metrica API access token
     */
    authToken: string;
    /**
     * Counter ID
     */
    counterId: string;
    /**
     * Starting point for your data replication, in format of "YYYY-MM-DD". If not provided will sync till most recent date.
     */
    endDate: string;
    /**
     * must be one of ["yandex-metrica"]
     */
    sourceType: string;
    /**
     * Starting point for your data replication, in format of "YYYY-MM-DD".
     */
    startDate: string;
}

export interface GetSourceYotpoConfiguration {
    /**
     * Access token recieved as a result of API call to https://api.yotpo.com/oauth/token (Ref- https://apidocs.yotpo.com/reference/yotpo-authentication)
     */
    accessToken: string;
    /**
     * App key found at settings (Ref- https://settings.yotpo.com/#/general_settings)
     */
    appKey: string;
    /**
     * Email address registered with yotpo.
     */
    email: string;
    /**
     * must be one of ["yotpo"]
     */
    sourceType: string;
    /**
     * Date time filter for incremental filter, Specify which date to extract from.
     */
    startDate: string;
}

export interface GetSourceYouniumConfiguration {
    /**
     * Legal Entity that data should be pulled from
     */
    legalEntity: string;
    /**
     * Account password for younium account API key
     */
    password: string;
    /**
     * Property defining if connector is used against playground or production environment
     */
    playground: boolean;
    /**
     * must be one of ["younium"]
     */
    sourceType: string;
    /**
     * Username for Younium account
     */
    username: string;
}

export interface GetSourceYoutubeAnalyticsConfiguration {
    credentials: outputs.GetSourceYoutubeAnalyticsConfigurationCredentials;
    /**
     * must be one of ["youtube-analytics"]
     */
    sourceType: string;
}

export interface GetSourceYoutubeAnalyticsConfigurationCredentials {
    additionalProperties?: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
}

export interface GetSourceZendeskChatConfiguration {
    credentials: outputs.GetSourceZendeskChatConfigurationCredentials;
    /**
     * must be one of ["zendesk-chat"]
     */
    sourceType: string;
    /**
     * The date from which you'd like to replicate data for Zendesk Chat API, in the format YYYY-MM-DDT00:00:00Z.
     */
    startDate: string;
    /**
     * Required if you access Zendesk Chat from a Zendesk Support subdomain.
     */
    subdomain: string;
}

export interface GetSourceZendeskChatConfigurationCredentials {
    sourceZendeskChatAuthorizationMethodAccessToken: outputs.GetSourceZendeskChatConfigurationCredentialsSourceZendeskChatAuthorizationMethodAccessToken;
    sourceZendeskChatAuthorizationMethodOAuth20: outputs.GetSourceZendeskChatConfigurationCredentialsSourceZendeskChatAuthorizationMethodOAuth20;
    sourceZendeskChatUpdateAuthorizationMethodAccessToken: outputs.GetSourceZendeskChatConfigurationCredentialsSourceZendeskChatUpdateAuthorizationMethodAccessToken;
    sourceZendeskChatUpdateAuthorizationMethodOAuth20: outputs.GetSourceZendeskChatConfigurationCredentialsSourceZendeskChatUpdateAuthorizationMethodOAuth20;
}

export interface GetSourceZendeskChatConfigurationCredentialsSourceZendeskChatAuthorizationMethodAccessToken {
    accessToken: string;
    credentials: string;
}

export interface GetSourceZendeskChatConfigurationCredentialsSourceZendeskChatAuthorizationMethodOAuth20 {
    accessToken: string;
    clientId: string;
    clientSecret: string;
    credentials: string;
    refreshToken: string;
}

export interface GetSourceZendeskChatConfigurationCredentialsSourceZendeskChatUpdateAuthorizationMethodAccessToken {
    accessToken: string;
    credentials: string;
}

export interface GetSourceZendeskChatConfigurationCredentialsSourceZendeskChatUpdateAuthorizationMethodOAuth20 {
    accessToken: string;
    clientId: string;
    clientSecret: string;
    credentials: string;
    refreshToken: string;
}

export interface GetSourceZendeskSunshineConfiguration {
    credentials: outputs.GetSourceZendeskSunshineConfigurationCredentials;
    /**
     * must be one of ["zendesk-sunshine"]
     */
    sourceType: string;
    /**
     * The date from which you'd like to replicate data for Zendesk Sunshine API, in the format YYYY-MM-DDT00:00:00Z.
     */
    startDate: string;
    /**
     * The subdomain for your Zendesk Account.
     */
    subdomain: string;
}

export interface GetSourceZendeskSunshineConfigurationCredentials {
    sourceZendeskSunshineAuthorizationMethodApiToken: outputs.GetSourceZendeskSunshineConfigurationCredentialsSourceZendeskSunshineAuthorizationMethodApiToken;
    sourceZendeskSunshineAuthorizationMethodOAuth20: outputs.GetSourceZendeskSunshineConfigurationCredentialsSourceZendeskSunshineAuthorizationMethodOAuth20;
    sourceZendeskSunshineUpdateAuthorizationMethodApiToken: outputs.GetSourceZendeskSunshineConfigurationCredentialsSourceZendeskSunshineUpdateAuthorizationMethodApiToken;
    sourceZendeskSunshineUpdateAuthorizationMethodOAuth20: outputs.GetSourceZendeskSunshineConfigurationCredentialsSourceZendeskSunshineUpdateAuthorizationMethodOAuth20;
}

export interface GetSourceZendeskSunshineConfigurationCredentialsSourceZendeskSunshineAuthorizationMethodApiToken {
    additionalProperties?: string;
    apiToken: string;
    authMethod: string;
    email: string;
}

export interface GetSourceZendeskSunshineConfigurationCredentialsSourceZendeskSunshineAuthorizationMethodOAuth20 {
    accessToken: string;
    additionalProperties?: string;
    authMethod: string;
    clientId: string;
    clientSecret: string;
}

export interface GetSourceZendeskSunshineConfigurationCredentialsSourceZendeskSunshineUpdateAuthorizationMethodApiToken {
    additionalProperties?: string;
    apiToken: string;
    authMethod: string;
    email: string;
}

export interface GetSourceZendeskSunshineConfigurationCredentialsSourceZendeskSunshineUpdateAuthorizationMethodOAuth20 {
    accessToken: string;
    additionalProperties?: string;
    authMethod: string;
    clientId: string;
    clientSecret: string;
}

export interface GetSourceZendeskSupportConfiguration {
    /**
     * Zendesk allows two authentication methods. We recommend using `OAuth2.0` for Airbyte Cloud users and `API token` for Airbyte Open Source users.
     */
    credentials: outputs.GetSourceZendeskSupportConfigurationCredentials;
    /**
     * Makes each stream read a single page of data.
     */
    ignorePagination: boolean;
    /**
     * must be one of ["zendesk-support"]
     */
    sourceType: string;
    /**
     * The UTC date and time from which you'd like to replicate data, in the format YYYY-MM-DDT00:00:00Z. All data generated after this date will be replicated.
     */
    startDate: string;
    /**
     * This is your unique Zendesk subdomain that can be found in your account URL. For example, in https://MY*SUBDOMAIN.zendesk.com/, MY*SUBDOMAIN is the value of your subdomain.
     */
    subdomain: string;
}

export interface GetSourceZendeskSupportConfigurationCredentials {
    sourceZendeskSupportAuthenticationApiToken: outputs.GetSourceZendeskSupportConfigurationCredentialsSourceZendeskSupportAuthenticationApiToken;
    sourceZendeskSupportAuthenticationOAuth20: outputs.GetSourceZendeskSupportConfigurationCredentialsSourceZendeskSupportAuthenticationOAuth20;
    sourceZendeskSupportUpdateAuthenticationApiToken: outputs.GetSourceZendeskSupportConfigurationCredentialsSourceZendeskSupportUpdateAuthenticationApiToken;
    sourceZendeskSupportUpdateAuthenticationOAuth20: outputs.GetSourceZendeskSupportConfigurationCredentialsSourceZendeskSupportUpdateAuthenticationOAuth20;
}

export interface GetSourceZendeskSupportConfigurationCredentialsSourceZendeskSupportAuthenticationApiToken {
    additionalProperties?: string;
    apiToken: string;
    credentials: string;
    email: string;
}

export interface GetSourceZendeskSupportConfigurationCredentialsSourceZendeskSupportAuthenticationOAuth20 {
    accessToken: string;
    additionalProperties?: string;
    clientId: string;
    clientSecret: string;
    credentials: string;
}

export interface GetSourceZendeskSupportConfigurationCredentialsSourceZendeskSupportUpdateAuthenticationApiToken {
    additionalProperties?: string;
    apiToken: string;
    credentials: string;
    email: string;
}

export interface GetSourceZendeskSupportConfigurationCredentialsSourceZendeskSupportUpdateAuthenticationOAuth20 {
    accessToken: string;
    additionalProperties?: string;
    clientId: string;
    clientSecret: string;
    credentials: string;
}

export interface GetSourceZendeskTalkConfiguration {
    /**
     * Zendesk service provides two authentication methods. Choose between: `OAuth2.0` or `API token`.
     */
    credentials: outputs.GetSourceZendeskTalkConfigurationCredentials;
    /**
     * must be one of ["zendesk-talk"]
     */
    sourceType: string;
    /**
     * The date from which you'd like to replicate data for Zendesk Talk API, in the format YYYY-MM-DDT00:00:00Z. All data generated after this date will be replicated.
     */
    startDate: string;
    /**
     * This is your Zendesk subdomain that can be found in your account URL. For example, in https://{MY*SUBDOMAIN}.zendesk.com/, where MY*SUBDOMAIN is the value of your subdomain.
     */
    subdomain: string;
}

export interface GetSourceZendeskTalkConfigurationCredentials {
    sourceZendeskTalkAuthenticationApiToken: outputs.GetSourceZendeskTalkConfigurationCredentialsSourceZendeskTalkAuthenticationApiToken;
    sourceZendeskTalkAuthenticationOAuth20: outputs.GetSourceZendeskTalkConfigurationCredentialsSourceZendeskTalkAuthenticationOAuth20;
    sourceZendeskTalkUpdateAuthenticationApiToken: outputs.GetSourceZendeskTalkConfigurationCredentialsSourceZendeskTalkUpdateAuthenticationApiToken;
    sourceZendeskTalkUpdateAuthenticationOAuth20: outputs.GetSourceZendeskTalkConfigurationCredentialsSourceZendeskTalkUpdateAuthenticationOAuth20;
}

export interface GetSourceZendeskTalkConfigurationCredentialsSourceZendeskTalkAuthenticationApiToken {
    additionalProperties?: string;
    apiToken: string;
    authType: string;
    email: string;
}

export interface GetSourceZendeskTalkConfigurationCredentialsSourceZendeskTalkAuthenticationOAuth20 {
    accessToken: string;
    additionalProperties?: string;
    authType: string;
    clientId: string;
    clientSecret: string;
}

export interface GetSourceZendeskTalkConfigurationCredentialsSourceZendeskTalkUpdateAuthenticationApiToken {
    additionalProperties?: string;
    apiToken: string;
    authType: string;
    email: string;
}

export interface GetSourceZendeskTalkConfigurationCredentialsSourceZendeskTalkUpdateAuthenticationOAuth20 {
    accessToken: string;
    additionalProperties?: string;
    authType: string;
    clientId: string;
    clientSecret: string;
}

export interface GetSourceZenloopConfiguration {
    /**
     * Zenloop API Token. You can get the API token in settings page \n\nhere\n\n
     */
    apiToken: string;
    /**
     * Zenloop date_from. Format: 2021-10-24T03:30:30Z or 2021-10-24. Leave empty if only data from current data should be synced
     */
    dateFrom: string;
    /**
     * must be one of ["zenloop"]
     */
    sourceType: string;
    /**
     * Zenloop Survey Group ID. Can be found by pulling All Survey Groups via SurveyGroups stream. Leave empty to pull answers from all survey groups
     */
    surveyGroupId: string;
    /**
     * Zenloop Survey ID. Can be found \n\nhere\n\n. Leave empty to pull answers from all surveys
     */
    surveyId: string;
}

export interface GetSourceZohoCrmConfiguration {
    /**
     * OAuth2.0 Client ID
     */
    clientId: string;
    /**
     * OAuth2.0 Client Secret
     */
    clientSecret: string;
    /**
     * must be one of ["US", "AU", "EU", "IN", "CN", "JP"]
     * Please choose the region of your Data Center location. More info by this \n\nLink\n\n
     */
    dcRegion: string;
    /**
     * must be one of ["Free", "Standard", "Professional", "Enterprise", "Ultimate"]
     * Choose your Edition of Zoho CRM to determine API Concurrency Limits
     */
    edition: string;
    /**
     * must be one of ["Production", "Developer", "Sandbox"]
     * Please choose the environment
     */
    environment: string;
    /**
     * OAuth2.0 Refresh Token
     */
    refreshToken: string;
    /**
     * must be one of ["zoho-crm"]
     */
    sourceType: string;
    /**
     * ISO 8601, for instance: `YYYY-MM-DD`, `YYYY-MM-DD HH:MM:SS+HH:MM`
     */
    startDatetime: string;
}

export interface GetSourceZoomConfiguration {
    /**
     * JWT Token
     */
    jwtToken: string;
    /**
     * must be one of ["zoom"]
     */
    sourceType: string;
}

export interface GetSourceZuoraConfiguration {
    /**
     * Your OAuth user Client ID
     */
    clientId: string;
    /**
     * Your OAuth user Client Secret
     */
    clientSecret: string;
    /**
     * must be one of ["Live", "Unlimited"]
     * Choose between `Live`, or `Unlimited` - the optimized, replicated database at 12 hours freshness for high volume extraction \n\nLink\n\n
     */
    dataQuery: string;
    /**
     * must be one of ["zuora"]
     */
    sourceType: string;
    /**
     * Start Date in format: YYYY-MM-DD
     */
    startDate: string;
    /**
     * must be one of ["US Production", "US Cloud Production", "US API Sandbox", "US Cloud API Sandbox", "US Central Sandbox", "US Performance Test", "EU Production", "EU API Sandbox", "EU Central Sandbox"]
     * Please choose the right endpoint where your Tenant is located. More info by this \n\nLink\n\n
     */
    tenantEndpoint: string;
    /**
     * The amount of days for each data-chunk begining from start_date. Bigger the value - faster the fetch. (0.1 - as for couple of hours, 1 - as for a Day; 364 - as for a Year).
     */
    windowInDays: string;
}

export interface SourceAhaConfiguration {
    /**
     * API Key
     */
    apiKey: string;
    /**
     * must be one of ["aha"]
     */
    sourceType: string;
    /**
     * URL
     */
    url: string;
}

export interface SourceAircallConfiguration {
    /**
     * App ID found at settings https://dashboard.aircall.io/integrations/api-keys
     */
    apiId: string;
    /**
     * App token found at settings (Ref- https://dashboard.aircall.io/integrations/api-keys)
     */
    apiToken: string;
    /**
     * must be one of ["aircall"]
     */
    sourceType: string;
    /**
     * Date time filter for incremental filter, Specify which date to extract from.
     */
    startDate: string;
}

export interface SourceAirtableConfiguration {
    credentials?: outputs.SourceAirtableConfigurationCredentials;
    /**
     * must be one of ["airtable"]
     */
    sourceType?: string;
}

export interface SourceAirtableConfigurationCredentials {
    sourceAirtableAuthenticationOAuth20?: outputs.SourceAirtableConfigurationCredentialsSourceAirtableAuthenticationOAuth20;
    sourceAirtableAuthenticationPersonalAccessToken?: outputs.SourceAirtableConfigurationCredentialsSourceAirtableAuthenticationPersonalAccessToken;
    sourceAirtableUpdateAuthenticationOAuth20?: outputs.SourceAirtableConfigurationCredentialsSourceAirtableUpdateAuthenticationOAuth20;
    sourceAirtableUpdateAuthenticationPersonalAccessToken?: outputs.SourceAirtableConfigurationCredentialsSourceAirtableUpdateAuthenticationPersonalAccessToken;
}

export interface SourceAirtableConfigurationCredentialsSourceAirtableAuthenticationOAuth20 {
    accessToken?: string;
    authMethod?: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
    tokenExpiryDate?: string;
}

export interface SourceAirtableConfigurationCredentialsSourceAirtableAuthenticationPersonalAccessToken {
    apiKey: string;
    authMethod?: string;
}

export interface SourceAirtableConfigurationCredentialsSourceAirtableUpdateAuthenticationOAuth20 {
    accessToken?: string;
    authMethod?: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
    tokenExpiryDate?: string;
}

export interface SourceAirtableConfigurationCredentialsSourceAirtableUpdateAuthenticationPersonalAccessToken {
    apiKey: string;
    authMethod?: string;
}

export interface SourceAlloydbConfiguration {
    /**
     * Name of the database.
     */
    database: string;
    /**
     * Hostname of the database.
     */
    host: string;
    /**
     * Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (Eg. key1=value1&key2=value2&key3=value3). For more information read about \n\nJDBC URL parameters\n\n.
     */
    jdbcUrlParams?: string;
    /**
     * Password associated with the username.
     */
    password?: string;
    /**
     * Port of the database.
     */
    port: number;
    /**
     * Replication method for extracting data from the database.
     */
    replicationMethod?: outputs.SourceAlloydbConfigurationReplicationMethod;
    /**
     * The list of schemas (case sensitive) to sync from. Defaults to public.
     */
    schemas?: string[];
    /**
     * must be one of ["alloydb"]
     */
    sourceType: string;
    /**
     * SSL connection modes.
     * Read more \n\n in the docs\n\n.
     */
    sslMode?: outputs.SourceAlloydbConfigurationSslMode;
    /**
     * Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
     */
    tunnelMethod?: outputs.SourceAlloydbConfigurationTunnelMethod;
    /**
     * Username to access the database.
     */
    username: string;
}

export interface SourceAlloydbConfigurationReplicationMethod {
    sourceAlloydbReplicationMethodLogicalReplicationCdc?: outputs.SourceAlloydbConfigurationReplicationMethodSourceAlloydbReplicationMethodLogicalReplicationCdc;
    sourceAlloydbReplicationMethodStandard?: outputs.SourceAlloydbConfigurationReplicationMethodSourceAlloydbReplicationMethodStandard;
    sourceAlloydbReplicationMethodStandardXmin?: outputs.SourceAlloydbConfigurationReplicationMethodSourceAlloydbReplicationMethodStandardXmin;
    sourceAlloydbUpdateReplicationMethodLogicalReplicationCdc?: outputs.SourceAlloydbConfigurationReplicationMethodSourceAlloydbUpdateReplicationMethodLogicalReplicationCdc;
    sourceAlloydbUpdateReplicationMethodStandard?: outputs.SourceAlloydbConfigurationReplicationMethodSourceAlloydbUpdateReplicationMethodStandard;
    sourceAlloydbUpdateReplicationMethodStandardXmin?: outputs.SourceAlloydbConfigurationReplicationMethodSourceAlloydbUpdateReplicationMethodStandardXmin;
}

export interface SourceAlloydbConfigurationReplicationMethodSourceAlloydbReplicationMethodLogicalReplicationCdc {
    additionalProperties?: string;
    initialWaitingSeconds?: number;
    lsnCommitBehaviour?: string;
    method: string;
    plugin?: string;
    publication: string;
    queueSize?: number;
    replicationSlot: string;
}

export interface SourceAlloydbConfigurationReplicationMethodSourceAlloydbReplicationMethodStandard {
    method: string;
}

export interface SourceAlloydbConfigurationReplicationMethodSourceAlloydbReplicationMethodStandardXmin {
    method: string;
}

export interface SourceAlloydbConfigurationReplicationMethodSourceAlloydbUpdateReplicationMethodLogicalReplicationCdc {
    additionalProperties?: string;
    initialWaitingSeconds?: number;
    lsnCommitBehaviour?: string;
    method: string;
    plugin?: string;
    publication: string;
    queueSize?: number;
    replicationSlot: string;
}

export interface SourceAlloydbConfigurationReplicationMethodSourceAlloydbUpdateReplicationMethodStandard {
    method: string;
}

export interface SourceAlloydbConfigurationReplicationMethodSourceAlloydbUpdateReplicationMethodStandardXmin {
    method: string;
}

export interface SourceAlloydbConfigurationSslMode {
    sourceAlloydbSslModesAllow?: outputs.SourceAlloydbConfigurationSslModeSourceAlloydbSslModesAllow;
    sourceAlloydbSslModesDisable?: outputs.SourceAlloydbConfigurationSslModeSourceAlloydbSslModesDisable;
    sourceAlloydbSslModesPrefer?: outputs.SourceAlloydbConfigurationSslModeSourceAlloydbSslModesPrefer;
    sourceAlloydbSslModesRequire?: outputs.SourceAlloydbConfigurationSslModeSourceAlloydbSslModesRequire;
    sourceAlloydbSslModesVerifyCa?: outputs.SourceAlloydbConfigurationSslModeSourceAlloydbSslModesVerifyCa;
    sourceAlloydbSslModesVerifyFull?: outputs.SourceAlloydbConfigurationSslModeSourceAlloydbSslModesVerifyFull;
    sourceAlloydbUpdateSslModesAllow?: outputs.SourceAlloydbConfigurationSslModeSourceAlloydbUpdateSslModesAllow;
    sourceAlloydbUpdateSslModesDisable?: outputs.SourceAlloydbConfigurationSslModeSourceAlloydbUpdateSslModesDisable;
    sourceAlloydbUpdateSslModesPrefer?: outputs.SourceAlloydbConfigurationSslModeSourceAlloydbUpdateSslModesPrefer;
    sourceAlloydbUpdateSslModesRequire?: outputs.SourceAlloydbConfigurationSslModeSourceAlloydbUpdateSslModesRequire;
    sourceAlloydbUpdateSslModesVerifyCa?: outputs.SourceAlloydbConfigurationSslModeSourceAlloydbUpdateSslModesVerifyCa;
    sourceAlloydbUpdateSslModesVerifyFull?: outputs.SourceAlloydbConfigurationSslModeSourceAlloydbUpdateSslModesVerifyFull;
}

export interface SourceAlloydbConfigurationSslModeSourceAlloydbSslModesAllow {
    additionalProperties?: string;
    mode: string;
}

export interface SourceAlloydbConfigurationSslModeSourceAlloydbSslModesDisable {
    additionalProperties?: string;
    mode: string;
}

export interface SourceAlloydbConfigurationSslModeSourceAlloydbSslModesPrefer {
    additionalProperties?: string;
    mode: string;
}

export interface SourceAlloydbConfigurationSslModeSourceAlloydbSslModesRequire {
    additionalProperties?: string;
    mode: string;
}

export interface SourceAlloydbConfigurationSslModeSourceAlloydbSslModesVerifyCa {
    additionalProperties?: string;
    caCertificate: string;
    clientCertificate?: string;
    clientKey?: string;
    clientKeyPassword?: string;
    mode: string;
}

export interface SourceAlloydbConfigurationSslModeSourceAlloydbSslModesVerifyFull {
    additionalProperties?: string;
    caCertificate: string;
    clientCertificate?: string;
    clientKey?: string;
    clientKeyPassword?: string;
    mode: string;
}

export interface SourceAlloydbConfigurationSslModeSourceAlloydbUpdateSslModesAllow {
    additionalProperties?: string;
    mode: string;
}

export interface SourceAlloydbConfigurationSslModeSourceAlloydbUpdateSslModesDisable {
    additionalProperties?: string;
    mode: string;
}

export interface SourceAlloydbConfigurationSslModeSourceAlloydbUpdateSslModesPrefer {
    additionalProperties?: string;
    mode: string;
}

export interface SourceAlloydbConfigurationSslModeSourceAlloydbUpdateSslModesRequire {
    additionalProperties?: string;
    mode: string;
}

export interface SourceAlloydbConfigurationSslModeSourceAlloydbUpdateSslModesVerifyCa {
    additionalProperties?: string;
    caCertificate: string;
    clientCertificate?: string;
    clientKey?: string;
    clientKeyPassword?: string;
    mode: string;
}

export interface SourceAlloydbConfigurationSslModeSourceAlloydbUpdateSslModesVerifyFull {
    additionalProperties?: string;
    caCertificate: string;
    clientCertificate?: string;
    clientKey?: string;
    clientKeyPassword?: string;
    mode: string;
}

export interface SourceAlloydbConfigurationTunnelMethod {
    sourceAlloydbSshTunnelMethodNoTunnel?: outputs.SourceAlloydbConfigurationTunnelMethodSourceAlloydbSshTunnelMethodNoTunnel;
    sourceAlloydbSshTunnelMethodPasswordAuthentication?: outputs.SourceAlloydbConfigurationTunnelMethodSourceAlloydbSshTunnelMethodPasswordAuthentication;
    sourceAlloydbSshTunnelMethodSshKeyAuthentication?: outputs.SourceAlloydbConfigurationTunnelMethodSourceAlloydbSshTunnelMethodSshKeyAuthentication;
    sourceAlloydbUpdateSshTunnelMethodNoTunnel?: outputs.SourceAlloydbConfigurationTunnelMethodSourceAlloydbUpdateSshTunnelMethodNoTunnel;
    sourceAlloydbUpdateSshTunnelMethodPasswordAuthentication?: outputs.SourceAlloydbConfigurationTunnelMethodSourceAlloydbUpdateSshTunnelMethodPasswordAuthentication;
    sourceAlloydbUpdateSshTunnelMethodSshKeyAuthentication?: outputs.SourceAlloydbConfigurationTunnelMethodSourceAlloydbUpdateSshTunnelMethodSshKeyAuthentication;
}

export interface SourceAlloydbConfigurationTunnelMethodSourceAlloydbSshTunnelMethodNoTunnel {
    tunnelMethod: string;
}

export interface SourceAlloydbConfigurationTunnelMethodSourceAlloydbSshTunnelMethodPasswordAuthentication {
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
    tunnelUserPassword: string;
}

export interface SourceAlloydbConfigurationTunnelMethodSourceAlloydbSshTunnelMethodSshKeyAuthentication {
    sshKey: string;
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
}

export interface SourceAlloydbConfigurationTunnelMethodSourceAlloydbUpdateSshTunnelMethodNoTunnel {
    tunnelMethod: string;
}

export interface SourceAlloydbConfigurationTunnelMethodSourceAlloydbUpdateSshTunnelMethodPasswordAuthentication {
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
    tunnelUserPassword: string;
}

export interface SourceAlloydbConfigurationTunnelMethodSourceAlloydbUpdateSshTunnelMethodSshKeyAuthentication {
    sshKey: string;
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
}

export interface SourceAmazonAdsConfiguration {
    /**
     * must be one of ["oauth2.0"]
     */
    authType?: string;
    /**
     * The client ID of your Amazon Ads developer application. See the \n\ndocs\n\n for more information.
     */
    clientId: string;
    /**
     * The client secret of your Amazon Ads developer application. See the \n\ndocs\n\n for more information.
     */
    clientSecret: string;
    /**
     * The amount of days to go back in time to get the updated data from Amazon Ads
     */
    lookBackWindow?: number;
    /**
     * Profile IDs you want to fetch data for. See \n\ndocs\n\n for more details.
     */
    profiles?: number[];
    /**
     * Amazon Ads refresh token. See the \n\ndocs\n\n for more information on how to obtain this token.
     */
    refreshToken: string;
    /**
     * must be one of ["NA", "EU", "FE"]
     * Region to pull data from (EU/NA/FE). See \n\ndocs\n\n for more details.
     */
    region?: string;
    /**
     * Optional configuration which accepts an array of string of record types. Leave blank for default behaviour to pull all report types. Use this config option only if you want to pull specific report type(s). See \n\ndocs\n\n for more details
     */
    reportRecordTypes?: string[];
    /**
     * must be one of ["amazon-ads"]
     */
    sourceType: string;
    /**
     * The Start date for collecting reports, should not be more than 60 days in the past. In YYYY-MM-DD format
     */
    startDate?: string;
    /**
     * Reflects the state of the Display, Product, and Brand Campaign streams as enabled, paused, or archived. If you do not populate this field, it will be ignored completely.
     */
    stateFilters?: string[];
}

export interface SourceAmazonSellerPartnerConfiguration {
    /**
     * Additional information to configure report options. This varies by report type, not every report implement this kind of feature. Must be a valid json string.
     */
    advancedStreamOptions?: string;
    /**
     * must be one of ["oauth2.0"]
     */
    authType?: string;
    /**
     * Specifies the AWS access key used as part of the credentials to authenticate the user.
     */
    awsAccessKey?: string;
    /**
     * must be one of ["PRODUCTION", "SANDBOX"]
     * Select the AWS Environment.
     */
    awsEnvironment: string;
    /**
     * Specifies the AWS secret key used as part of the credentials to authenticate the user.
     */
    awsSecretKey?: string;
    /**
     * Your Login with Amazon Client ID.
     */
    lwaAppId: string;
    /**
     * Your Login with Amazon Client Secret.
     */
    lwaClientSecret: string;
    /**
     * Sometimes report can take up to 30 minutes to generate. This will set the limit for how long to wait for a successful report.
     */
    maxWaitSeconds?: number;
    /**
     * Will be used for stream slicing for initial fullRefresh sync when no updated state is present for reports that support sliced incremental sync.
     */
    periodInDays?: number;
    /**
     * The Refresh Token obtained via OAuth flow authorization.
     */
    refreshToken: string;
    /**
     * must be one of ["AE", "AU", "BE", "BR", "CA", "DE", "EG", "ES", "FR", "GB", "IN", "IT", "JP", "MX", "NL", "PL", "SA", "SE", "SG", "TR", "UK", "US"]
     * Select the AWS Region.
     */
    region: string;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Any data after this date will not be replicated.
     */
    replicationEndDate?: string;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
     */
    replicationStartDate: string;
    /**
     * Additional information passed to reports. This varies by report type. Must be a valid json string.
     */
    reportOptions?: string;
    /**
     * Specifies the Amazon Resource Name (ARN) of an IAM role that you want to use to perform operations requested using this profile. (Needs permission to 'Assume Role' STS).
     */
    roleArn?: string;
    /**
     * must be one of ["amazon-seller-partner"]
     */
    sourceType: string;
}

export interface SourceAmazonSqsConfiguration {
    /**
     * The Access Key ID of the AWS IAM Role to use for pulling messages
     */
    accessKey?: string;
    /**
     * Comma separated list of Mesage Attribute names to return
     */
    attributesToReturn?: string;
    /**
     * If Enabled, messages will be deleted from the SQS Queue after being read. If Disabled, messages are left in the queue and can be read more than once. WARNING: Enabling this option can result in data loss in cases of failure, use with caution, see documentation for more detail.
     */
    deleteMessages: boolean;
    /**
     * Max amount of messages to get in one batch (10 max)
     */
    maxBatchSize?: number;
    /**
     * Max amount of time in seconds to wait for messages in a single poll (20 max)
     */
    maxWaitTime?: number;
    /**
     * URL of the SQS Queue
     */
    queueUrl: string;
    /**
     * must be one of ["us-east-1", "us-east-2", "us-west-1", "us-west-2", "af-south-1", "ap-east-1", "ap-south-1", "ap-northeast-1", "ap-northeast-2", "ap-northeast-3", "ap-southeast-1", "ap-southeast-2", "ca-central-1", "cn-north-1", "cn-northwest-1", "eu-central-1", "eu-north-1", "eu-south-1", "eu-west-1", "eu-west-2", "eu-west-3", "sa-east-1", "me-south-1", "us-gov-east-1", "us-gov-west-1"]
     * AWS Region of the SQS Queue
     */
    region: string;
    /**
     * The Secret Key of the AWS IAM Role to use for pulling messages
     */
    secretKey?: string;
    /**
     * must be one of ["amazon-sqs"]
     */
    sourceType: string;
    /**
     * Modify the Visibility Timeout of the individual message from the Queue's default (seconds).
     */
    visibilityTimeout?: number;
}

export interface SourceAmplitudeConfiguration {
    /**
     * Amplitude API Key. See the \n\nsetup guide\n\n for more information on how to obtain this key.
     */
    apiKey: string;
    /**
     * must be one of ["Standard Server", "EU Residency Server"]
     * Amplitude data region server
     */
    dataRegion?: string;
    /**
     * According to \n\nConsiderations\n\n too big time range in request can cause a timeout error. In this case, set shorter time interval in hours.
     */
    requestTimeRange?: number;
    /**
     * Amplitude Secret Key. See the \n\nsetup guide\n\n for more information on how to obtain this key.
     */
    secretKey: string;
    /**
     * must be one of ["amplitude"]
     */
    sourceType: string;
    /**
     * UTC date and time in the format 2021-01-25T00:00:00Z. Any data before this date will not be replicated.
     */
    startDate: string;
}

export interface SourceApifyDatasetConfiguration {
    /**
     * If set to true, only clean items will be downloaded from the dataset. See description of what clean means in \n\nApify API docs\n\n. If not sure, set clean to false.
     */
    clean?: boolean;
    /**
     * ID of the dataset you would like to load to Airbyte.
     */
    datasetId: string;
    /**
     * must be one of ["apify-dataset"]
     */
    sourceType: string;
}

export interface SourceAppfollowConfiguration {
    /**
     * API Key provided by Appfollow
     */
    apiSecret?: string;
    /**
     * must be one of ["appfollow"]
     */
    sourceType: string;
}

export interface SourceAsanaConfiguration {
    /**
     * Choose how to authenticate to Github
     */
    credentials?: outputs.SourceAsanaConfigurationCredentials;
    /**
     * must be one of ["asana"]
     */
    sourceType?: string;
}

export interface SourceAsanaConfigurationCredentials {
    sourceAsanaAuthenticationMechanismAuthenticateViaAsanaOauth?: outputs.SourceAsanaConfigurationCredentialsSourceAsanaAuthenticationMechanismAuthenticateViaAsanaOauth;
    sourceAsanaAuthenticationMechanismAuthenticateWithPersonalAccessToken?: outputs.SourceAsanaConfigurationCredentialsSourceAsanaAuthenticationMechanismAuthenticateWithPersonalAccessToken;
    sourceAsanaUpdateAuthenticationMechanismAuthenticateViaAsanaOauth?: outputs.SourceAsanaConfigurationCredentialsSourceAsanaUpdateAuthenticationMechanismAuthenticateViaAsanaOauth;
    sourceAsanaUpdateAuthenticationMechanismAuthenticateWithPersonalAccessToken?: outputs.SourceAsanaConfigurationCredentialsSourceAsanaUpdateAuthenticationMechanismAuthenticateWithPersonalAccessToken;
}

export interface SourceAsanaConfigurationCredentialsSourceAsanaAuthenticationMechanismAuthenticateViaAsanaOauth {
    clientId: string;
    clientSecret: string;
    optionTitle?: string;
    refreshToken: string;
}

export interface SourceAsanaConfigurationCredentialsSourceAsanaAuthenticationMechanismAuthenticateWithPersonalAccessToken {
    optionTitle?: string;
    personalAccessToken: string;
}

export interface SourceAsanaConfigurationCredentialsSourceAsanaUpdateAuthenticationMechanismAuthenticateViaAsanaOauth {
    clientId: string;
    clientSecret: string;
    optionTitle?: string;
    refreshToken: string;
}

export interface SourceAsanaConfigurationCredentialsSourceAsanaUpdateAuthenticationMechanismAuthenticateWithPersonalAccessToken {
    optionTitle?: string;
    personalAccessToken: string;
}

export interface SourceAuth0Configuration {
    /**
     * The Authentication API is served over HTTPS. All URLs referenced in the documentation have the following base `https://YOUR_DOMAIN`
     */
    baseUrl: string;
    credentials: outputs.SourceAuth0ConfigurationCredentials;
    /**
     * must be one of ["auth0"]
     */
    sourceType: string;
}

export interface SourceAuth0ConfigurationCredentials {
    sourceAuth0AuthenticationMethodOAuth2AccessToken?: outputs.SourceAuth0ConfigurationCredentialsSourceAuth0AuthenticationMethodOAuth2AccessToken;
    sourceAuth0AuthenticationMethodOAuth2ConfidentialApplication?: outputs.SourceAuth0ConfigurationCredentialsSourceAuth0AuthenticationMethodOAuth2ConfidentialApplication;
    sourceAuth0UpdateAuthenticationMethodOAuth2AccessToken?: outputs.SourceAuth0ConfigurationCredentialsSourceAuth0UpdateAuthenticationMethodOAuth2AccessToken;
    sourceAuth0UpdateAuthenticationMethodOAuth2ConfidentialApplication?: outputs.SourceAuth0ConfigurationCredentialsSourceAuth0UpdateAuthenticationMethodOAuth2ConfidentialApplication;
}

export interface SourceAuth0ConfigurationCredentialsSourceAuth0AuthenticationMethodOAuth2AccessToken {
    accessToken: string;
    authType: string;
}

export interface SourceAuth0ConfigurationCredentialsSourceAuth0AuthenticationMethodOAuth2ConfidentialApplication {
    audience: string;
    authType: string;
    clientId: string;
    clientSecret: string;
}

export interface SourceAuth0ConfigurationCredentialsSourceAuth0UpdateAuthenticationMethodOAuth2AccessToken {
    accessToken: string;
    authType: string;
}

export interface SourceAuth0ConfigurationCredentialsSourceAuth0UpdateAuthenticationMethodOAuth2ConfidentialApplication {
    audience: string;
    authType: string;
    clientId: string;
    clientSecret: string;
}

export interface SourceAwsCloudtrailConfiguration {
    /**
     * AWS CloudTrail Access Key ID. See the \n\ndocs\n\n for more information on how to obtain this key.
     */
    awsKeyId: string;
    /**
     * The default AWS Region to use, for example, us-west-1 or us-west-2. When specifying a Region inline during client initialization, this property is named region_name.
     */
    awsRegionName: string;
    /**
     * AWS CloudTrail Access Key ID. See the \n\ndocs\n\n for more information on how to obtain this key.
     */
    awsSecretKey: string;
    /**
     * must be one of ["aws-cloudtrail"]
     */
    sourceType: string;
    /**
     * The date you would like to replicate data. Data in AWS CloudTrail is available for last 90 days only. Format: YYYY-MM-DD.
     */
    startDate: string;
}

export interface SourceAzureBlobStorageConfiguration {
    /**
     * The Azure blob storage account key.
     */
    azureBlobStorageAccountKey: string;
    /**
     * The account's name of the Azure Blob Storage.
     */
    azureBlobStorageAccountName: string;
    /**
     * The Azure blob storage prefix to be applied
     */
    azureBlobStorageBlobsPrefix?: string;
    /**
     * The name of the Azure blob storage container.
     */
    azureBlobStorageContainerName: string;
    /**
     * This is Azure Blob Storage endpoint domain name. Leave default value (or leave it empty if run container from command line) to use Microsoft native from example.
     */
    azureBlobStorageEndpoint?: string;
    /**
     * The Azure blob storage blobs to scan for inferring the schema, useful on large amounts of data with consistent structure
     */
    azureBlobStorageSchemaInferenceLimit?: number;
    /**
     * Input data format
     */
    format: outputs.SourceAzureBlobStorageConfigurationFormat;
    /**
     * must be one of ["azure-blob-storage"]
     */
    sourceType: string;
}

export interface SourceAzureBlobStorageConfigurationFormat {
    sourceAzureBlobStorageInputFormatJsonLinesNewlineDelimitedJson?: outputs.SourceAzureBlobStorageConfigurationFormatSourceAzureBlobStorageInputFormatJsonLinesNewlineDelimitedJson;
    sourceAzureBlobStorageUpdateInputFormatJsonLinesNewlineDelimitedJson?: outputs.SourceAzureBlobStorageConfigurationFormatSourceAzureBlobStorageUpdateInputFormatJsonLinesNewlineDelimitedJson;
}

export interface SourceAzureBlobStorageConfigurationFormatSourceAzureBlobStorageInputFormatJsonLinesNewlineDelimitedJson {
    formatType: string;
}

export interface SourceAzureBlobStorageConfigurationFormatSourceAzureBlobStorageUpdateInputFormatJsonLinesNewlineDelimitedJson {
    formatType: string;
}

export interface SourceAzureTableConfiguration {
    /**
     * must be one of ["azure-table"]
     */
    sourceType: string;
    /**
     * Azure Table Storage Access Key. See the \n\ndocs\n\n for more information on how to obtain this key.
     */
    storageAccessKey: string;
    /**
     * The name of your storage account.
     */
    storageAccountName: string;
    /**
     * Azure Table Storage service account URL suffix. See the \n\ndocs\n\n for more information on how to obtain endpoint suffix
     */
    storageEndpointSuffix?: string;
}

export interface SourceBambooHrConfiguration {
    /**
     * Api key of bamboo hr
     */
    apiKey: string;
    /**
     * Comma-separated list of fields to include in custom reports.
     */
    customReportsFields?: string;
    /**
     * If true, the custom reports endpoint will include the default fields defined here: https://documentation.bamboohr.com/docs/list-of-field-names.
     */
    customReportsIncludeDefaultFields?: boolean;
    /**
     * must be one of ["bamboo-hr"]
     */
    sourceType: string;
    /**
     * Sub Domain of bamboo hr
     */
    subdomain: string;
}

export interface SourceBigcommerceConfiguration {
    /**
     * Access Token for making authenticated requests.
     */
    accessToken: string;
    /**
     * must be one of ["bigcommerce"]
     */
    sourceType: string;
    /**
     * The date you would like to replicate data. Format: YYYY-MM-DD.
     */
    startDate: string;
    /**
     * The hash code of the store. For https://api.bigcommerce.com/stores/HASH*CODE/v3/, The store's hash code is 'HASH*CODE'.
     */
    storeHash: string;
}

export interface SourceBigqueryConfiguration {
    /**
     * The contents of your Service Account Key JSON file. See the \n\ndocs\n\n for more information on how to obtain this key.
     */
    credentialsJson: string;
    /**
     * The dataset ID to search for tables and views. If you are only loading data from one dataset, setting this option could result in much faster schema discovery.
     */
    datasetId?: string;
    /**
     * The GCP project ID for the project containing the target BigQuery dataset.
     */
    projectId: string;
    /**
     * must be one of ["bigquery"]
     */
    sourceType: string;
}

export interface SourceBingAdsConfiguration {
    /**
     * must be one of ["oauth2.0"]
     */
    authMethod?: string;
    /**
     * The Client ID of your Microsoft Advertising developer application.
     */
    clientId: string;
    /**
     * The Client Secret of your Microsoft Advertising developer application.
     */
    clientSecret?: string;
    /**
     * Developer token associated with user. See more info \n\n in the docs\n\n.
     */
    developerToken: string;
    /**
     * Also known as attribution or conversion window. How far into the past to look for records (in days). If your conversion window has an hours/minutes granularity, round it up to the number of days exceeding. Used only for performance report streams in incremental mode.
     */
    lookbackWindow?: number;
    /**
     * Refresh Token to renew the expired Access Token.
     */
    refreshToken: string;
    /**
     * The start date from which to begin replicating report data. Any data generated before this date will not be replicated in reports. This is a UTC date in YYYY-MM-DD format.
     */
    reportsStartDate: string;
    /**
     * must be one of ["bing-ads"]
     */
    sourceType: string;
    /**
     * The Tenant ID of your Microsoft Advertising developer application. Set this to "common" unless you know you need a different value.
     */
    tenantId?: string;
}

export interface SourceBraintreeConfiguration {
    /**
     * must be one of ["Development", "Sandbox", "Qa", "Production"]
     * Environment specifies where the data will come from.
     */
    environment: string;
    /**
     * The unique identifier for your entire gateway account. See the \n\ndocs\n\n for more information on how to obtain this ID.
     */
    merchantId: string;
    /**
     * Braintree Private Key. See the \n\ndocs\n\n for more information on how to obtain this key.
     */
    privateKey: string;
    /**
     * Braintree Public Key. See the \n\ndocs\n\n for more information on how to obtain this key.
     */
    publicKey: string;
    /**
     * must be one of ["braintree"]
     */
    sourceType: string;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
     */
    startDate?: string;
}

export interface SourceBrazeConfiguration {
    /**
     * Braze REST API key
     */
    apiKey: string;
    /**
     * must be one of ["braze"]
     */
    sourceType: string;
    /**
     * Rows after this date will be synced
     */
    startDate: string;
    /**
     * Braze REST API endpoint
     */
    url: string;
}

export interface SourceChargebeeConfiguration {
    /**
     * must be one of ["1.0", "2.0"]
     * Product Catalog version of your Chargebee site. Instructions on how to find your version you may find \n\nhere\n\n under `API Version` section.
     */
    productCatalog: string;
    /**
     * The site prefix for your Chargebee instance.
     */
    site: string;
    /**
     * Chargebee API Key. See the \n\ndocs\n\n for more information on how to obtain this key.
     */
    siteApiKey: string;
    /**
     * must be one of ["chargebee"]
     */
    sourceType: string;
    /**
     * UTC date and time in the format 2021-01-25T00:00:00Z. Any data before this date will not be replicated.
     */
    startDate: string;
}

export interface SourceChartmogulConfiguration {
    /**
     * Your Chartmogul API key. See \n\n the docs \n\n for info on how to obtain this.
     */
    apiKey: string;
    /**
     * must be one of ["day", "week", "month", "quarter"]
     * Some APIs such as \n\nMetrics\n\n require intervals to cluster data.
     */
    interval: string;
    /**
     * must be one of ["chartmogul"]
     */
    sourceType: string;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. When feasible, any data before this date will not be replicated.
     */
    startDate: string;
}

export interface SourceClickhouseConfiguration {
    /**
     * The name of the database.
     */
    database: string;
    /**
     * The host endpoint of the Clickhouse cluster.
     */
    host: string;
    /**
     * The password associated with this username.
     */
    password?: string;
    /**
     * The port of the database.
     */
    port: number;
    /**
     * must be one of ["clickhouse"]
     */
    sourceType: string;
    /**
     * Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
     */
    tunnelMethod?: outputs.SourceClickhouseConfigurationTunnelMethod;
    /**
     * The username which is used to access the database.
     */
    username: string;
}

export interface SourceClickhouseConfigurationTunnelMethod {
    sourceClickhouseSshTunnelMethodNoTunnel?: outputs.SourceClickhouseConfigurationTunnelMethodSourceClickhouseSshTunnelMethodNoTunnel;
    sourceClickhouseSshTunnelMethodPasswordAuthentication?: outputs.SourceClickhouseConfigurationTunnelMethodSourceClickhouseSshTunnelMethodPasswordAuthentication;
    sourceClickhouseSshTunnelMethodSshKeyAuthentication?: outputs.SourceClickhouseConfigurationTunnelMethodSourceClickhouseSshTunnelMethodSshKeyAuthentication;
    sourceClickhouseUpdateSshTunnelMethodNoTunnel?: outputs.SourceClickhouseConfigurationTunnelMethodSourceClickhouseUpdateSshTunnelMethodNoTunnel;
    sourceClickhouseUpdateSshTunnelMethodPasswordAuthentication?: outputs.SourceClickhouseConfigurationTunnelMethodSourceClickhouseUpdateSshTunnelMethodPasswordAuthentication;
    sourceClickhouseUpdateSshTunnelMethodSshKeyAuthentication?: outputs.SourceClickhouseConfigurationTunnelMethodSourceClickhouseUpdateSshTunnelMethodSshKeyAuthentication;
}

export interface SourceClickhouseConfigurationTunnelMethodSourceClickhouseSshTunnelMethodNoTunnel {
    tunnelMethod: string;
}

export interface SourceClickhouseConfigurationTunnelMethodSourceClickhouseSshTunnelMethodPasswordAuthentication {
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
    tunnelUserPassword: string;
}

export interface SourceClickhouseConfigurationTunnelMethodSourceClickhouseSshTunnelMethodSshKeyAuthentication {
    sshKey: string;
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
}

export interface SourceClickhouseConfigurationTunnelMethodSourceClickhouseUpdateSshTunnelMethodNoTunnel {
    tunnelMethod: string;
}

export interface SourceClickhouseConfigurationTunnelMethodSourceClickhouseUpdateSshTunnelMethodPasswordAuthentication {
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
    tunnelUserPassword: string;
}

export interface SourceClickhouseConfigurationTunnelMethodSourceClickhouseUpdateSshTunnelMethodSshKeyAuthentication {
    sshKey: string;
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
}

export interface SourceClickupApiConfiguration {
    /**
     * Every ClickUp API call required authentication. This field is your personal API token. See \n\nhere\n\n.
     */
    apiToken: string;
    /**
     * The ID of your folder in your space. Retrieve it from the `/space/{space_id}/folder` of the ClickUp API. See \n\nhere\n\n.
     */
    folderId?: string;
    /**
     * Include or exclude closed tasks. By default, they are excluded. See \n\nhere\n\n.
     */
    includeClosedTasks?: boolean;
    /**
     * The ID of your list in your folder. Retrieve it from the `/folder/{folder_id}/list` of the ClickUp API. See \n\nhere\n\n.
     */
    listId?: string;
    /**
     * must be one of ["clickup-api"]
     */
    sourceType: string;
    /**
     * The ID of your space in your workspace. Retrieve it from the `/team/{team_id}/space` of the ClickUp API. See \n\nhere\n\n.
     */
    spaceId?: string;
    /**
     * The ID of your team in ClickUp. Retrieve it from the `/team` of the ClickUp API. See \n\nhere\n\n.
     */
    teamId?: string;
}

export interface SourceClockifyConfiguration {
    /**
     * You can get your api accessKey \n\nhere\n\n This API is Case Sensitive.
     */
    apiKey: string;
    /**
     * The URL for the Clockify API. This should only need to be modified if connecting to an enterprise version of Clockify.
     */
    apiUrl?: string;
    /**
     * must be one of ["clockify"]
     */
    sourceType: string;
    /**
     * WorkSpace Id
     */
    workspaceId: string;
}

export interface SourceCloseComConfiguration {
    /**
     * Close.com API key (usually starts with 'api_'; find yours \n\nhere\n\n).
     */
    apiKey: string;
    /**
     * must be one of ["close-com"]
     */
    sourceType: string;
    /**
     * The start date to sync data; all data after this date will be replicated. Leave blank to retrieve all the data available in the account. Format: YYYY-MM-DD.
     */
    startDate?: string;
}

export interface SourceCodaConfiguration {
    /**
     * Bearer token
     */
    authToken: string;
    /**
     * must be one of ["coda"]
     */
    sourceType: string;
}

export interface SourceCoinApiConfiguration {
    /**
     * API Key
     */
    apiKey: string;
    /**
     * The end date in ISO 8601 format. If not supplied, data will be returned
     * from the start date to the current time, or when the count of result
     * elements reaches its limit.
     */
    endDate?: string;
    /**
     * must be one of ["sandbox", "production"]
     * The environment to use. Either sandbox or production.
     */
    environment: string;
    /**
     * The maximum number of elements to return. If not supplied, the default
     * is 100. For numbers larger than 100, each 100 items is counted as one
     * request for pricing purposes. Maximum value is 100000.
     */
    limit?: number;
    /**
     * The period to use. See the documentation for a list. https://docs.coinapi.io/#list-all-periods-get
     */
    period: string;
    /**
     * must be one of ["coin-api"]
     */
    sourceType: string;
    /**
     * The start date in ISO 8601 format.
     */
    startDate: string;
    /**
     * The symbol ID to use. See the documentation for a list.
     * https://docs.coinapi.io/#list-all-symbols-get
     */
    symbolId: string;
}

export interface SourceCoinmarketcapConfiguration {
    /**
     * Your API Key. See \n\nhere\n\n. The token is case sensitive.
     */
    apiKey: string;
    /**
     * must be one of ["latest", "historical"]
     * /latest: Latest market ticker quotes and averages for cryptocurrencies and exchanges. /historical: Intervals of historic market data like OHLCV data or data for use in charting libraries. See \n\nhere\n\n.
     */
    dataType: string;
    /**
     * must be one of ["coinmarketcap"]
     */
    sourceType: string;
    /**
     * Cryptocurrency symbols. (only used for quotes stream)
     */
    symbols?: string[];
}

export interface SourceConfigcatConfiguration {
    /**
     * Basic auth password. See \n\nhere\n\n.
     */
    password: string;
    /**
     * must be one of ["configcat"]
     */
    sourceType: string;
    /**
     * Basic auth user name. See \n\nhere\n\n.
     */
    username: string;
}

export interface SourceConfluenceConfiguration {
    /**
     * Please follow the Jira confluence for generating an API token: \n\ngenerating an API token\n\n.
     */
    apiToken: string;
    /**
     * Your Confluence domain name
     */
    domainName: string;
    /**
     * Your Confluence login email
     */
    email: string;
    /**
     * must be one of ["confluence"]
     */
    sourceType: string;
}

export interface SourceConvexConfiguration {
    /**
     * API access key used to retrieve data from Convex.
     */
    accessKey: string;
    deploymentUrl: string;
    /**
     * must be one of ["convex"]
     */
    sourceType: string;
}

export interface SourceDatadogConfiguration {
    /**
     * Datadog API key
     */
    apiKey: string;
    /**
     * Datadog application key
     */
    applicationKey: string;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Data after this date will  not be replicated. An empty value will represent the current datetime for each  execution. This just applies to Incremental syncs.
     */
    endDate?: string;
    /**
     * Maximum number of records to collect per request.
     */
    maxRecordsPerRequest?: number;
    /**
     * List of queries to be run and used as inputs.
     */
    queries?: outputs.SourceDatadogConfigurationQuery[];
    /**
     * The search query. This just applies to Incremental syncs. If empty, it'll collect all logs.
     */
    query?: string;
    /**
     * must be one of ["datadoghq.com", "us3.datadoghq.com", "us5.datadoghq.com", "datadoghq.eu", "ddog-gov.com"]
     * The site where Datadog data resides in.
     */
    site?: string;
    /**
     * must be one of ["datadog"]
     */
    sourceType: string;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated. This just applies to Incremental syncs.
     */
    startDate?: string;
}

export interface SourceDatadogConfigurationQuery {
    dataSource: string;
    name: string;
    query: string;
}

export interface SourceDatascopeConfiguration {
    /**
     * API Key
     */
    apiKey: string;
    /**
     * must be one of ["datascope"]
     */
    sourceType: string;
    /**
     * Start date for the data to be replicated
     */
    startDate: string;
}

export interface SourceDelightedConfiguration {
    /**
     * A Delighted API key.
     */
    apiKey: string;
    /**
     * The date from which you'd like to replicate the data
     */
    since: string;
    /**
     * must be one of ["delighted"]
     */
    sourceType: string;
}

export interface SourceDixaConfiguration {
    /**
     * Dixa API token
     */
    apiToken: string;
    /**
     * Number of days to batch into one request. Max 31.
     */
    batchSize?: number;
    /**
     * must be one of ["dixa"]
     */
    sourceType: string;
    /**
     * The connector pulls records updated from this date onwards.
     */
    startDate: string;
}

export interface SourceDockerhubConfiguration {
    /**
     * Username of DockerHub person or organization (for https://hub.docker.com/v2/repositories/USERNAME/ API call)
     */
    dockerUsername: string;
    /**
     * must be one of ["dockerhub"]
     */
    sourceType: string;
}

export interface SourceDremioConfiguration {
    /**
     * API Key that is generated when you authenticate to Dremio API
     */
    apiKey: string;
    /**
     * URL of your Dremio instance
     */
    baseUrl: string;
    /**
     * must be one of ["dremio"]
     */
    sourceType: string;
}

export interface SourceDynamodbConfiguration {
    /**
     * The access key id to access Dynamodb. Airbyte requires read permissions to the database
     */
    accessKeyId: string;
    /**
     * the URL of the Dynamodb database
     */
    endpoint?: string;
    /**
     * must be one of ["", "us-east-1", "us-east-2", "us-west-1", "us-west-2", "af-south-1", "ap-east-1", "ap-south-1", "ap-northeast-1", "ap-northeast-2", "ap-northeast-3", "ap-southeast-1", "ap-southeast-2", "ca-central-1", "cn-north-1", "cn-northwest-1", "eu-central-1", "eu-north-1", "eu-south-1", "eu-west-1", "eu-west-2", "eu-west-3", "sa-east-1", "me-south-1", "us-gov-east-1", "us-gov-west-1"]
     * The region of the Dynamodb database
     */
    region?: string;
    /**
     * Comma separated reserved attribute names present in your tables
     */
    reservedAttributeNames?: string;
    /**
     * The corresponding secret to the access key id.
     */
    secretAccessKey: string;
    /**
     * must be one of ["dynamodb"]
     */
    sourceType: string;
}

export interface SourceE2eTestCloudConfiguration {
    /**
     * Number of records to emit per stream. Min 1. Max 100 billion.
     */
    maxMessages: number;
    /**
     * Interval between messages in ms. Min 0 ms. Max 60000 ms (1 minute).
     */
    messageIntervalMs?: number;
    mockCatalog: outputs.SourceE2eTestCloudConfigurationMockCatalog;
    /**
     * When the seed is unspecified, the current time millis will be used as the seed. Range: [0, 1000000].
     */
    seed?: number;
    /**
     * must be one of ["e2e-test-cloud"]
     */
    sourceType: string;
    /**
     * must be one of ["CONTINUOUS_FEED"]
     */
    type?: string;
}

export interface SourceE2eTestCloudConfigurationMockCatalog {
    sourceE2eTestCloudMockCatalogMultiSchema?: outputs.SourceE2eTestCloudConfigurationMockCatalogSourceE2eTestCloudMockCatalogMultiSchema;
    sourceE2eTestCloudMockCatalogSingleSchema?: outputs.SourceE2eTestCloudConfigurationMockCatalogSourceE2eTestCloudMockCatalogSingleSchema;
    sourceE2eTestCloudUpdateMockCatalogMultiSchema?: outputs.SourceE2eTestCloudConfigurationMockCatalogSourceE2eTestCloudUpdateMockCatalogMultiSchema;
    sourceE2eTestCloudUpdateMockCatalogSingleSchema?: outputs.SourceE2eTestCloudConfigurationMockCatalogSourceE2eTestCloudUpdateMockCatalogSingleSchema;
}

export interface SourceE2eTestCloudConfigurationMockCatalogSourceE2eTestCloudMockCatalogMultiSchema {
    streamSchemas: string;
    type: string;
}

export interface SourceE2eTestCloudConfigurationMockCatalogSourceE2eTestCloudMockCatalogSingleSchema {
    streamDuplication?: number;
    streamName: string;
    streamSchema: string;
    type: string;
}

export interface SourceE2eTestCloudConfigurationMockCatalogSourceE2eTestCloudUpdateMockCatalogMultiSchema {
    streamSchemas: string;
    type: string;
}

export interface SourceE2eTestCloudConfigurationMockCatalogSourceE2eTestCloudUpdateMockCatalogSingleSchema {
    streamDuplication?: number;
    streamName: string;
    streamSchema: string;
    type: string;
}

export interface SourceEmailoctopusConfiguration {
    /**
     * EmailOctopus API Key. See the \n\ndocs\n\n for information on how to generate this key.
     */
    apiKey: string;
    /**
     * must be one of ["emailoctopus"]
     */
    sourceType: string;
}

export interface SourceExchangeRatesConfiguration {
    /**
     * Your API Key. See \n\nhere\n\n. The key is case sensitive.
     */
    accessKey: string;
    /**
     * ISO reference currency. See \n\nhere\n\n. Free plan doesn't support Source Currency Switching, default base currency is EUR
     */
    base?: string;
    /**
     * Ignore weekends? (Exchanges don't run on weekends)
     */
    ignoreWeekends?: boolean;
    /**
     * must be one of ["exchange-rates"]
     */
    sourceType: string;
    /**
     * Start getting data from that date.
     */
    startDate: string;
}

export interface SourceFacebookMarketingConfiguration {
    /**
     * The value of the generated access token. From your Appâ€™s Dashboard, click on "Marketing API" then "Tools". Select permissions \n\nads*management, ads*read, read*insights, business*management\n\n. Then click on "Get token". See the \n\ndocs\n\n for more information.
     */
    accessToken: string;
    /**
     * The Facebook Ad account ID to use when pulling data from the Facebook Marketing API. Open your Meta Ads Manager. The Ad account ID number is in the account dropdown menu or in your browser's address bar. See the \n\ndocs\n\n for more information.
     */
    accountId: string;
    /**
     * Allows actionBreakdowns to be an empty list
     */
    actionBreakdownsAllowEmpty?: boolean;
    /**
     * The Client Id for your OAuth app
     */
    clientId?: string;
    /**
     * The Client Secret for your OAuth app
     */
    clientSecret?: string;
    /**
     * A list which contains ad statistics entries, each entry must have a name and can contains fields, breakdowns or action*breakdowns. Click on "add" to fill this field.
     */
    customInsights?: outputs.SourceFacebookMarketingConfigurationCustomInsight[];
    /**
     * The date until which you'd like to replicate data for all incremental streams, in the format YYYY-MM-DDT00:00:00Z. All data generated between the start date and this end date will be replicated. Not setting this option will result in always syncing the latest data.
     */
    endDate?: string;
    /**
     * Set to active if you want to fetch the thumbnail*url and store the result in thumbnail*data_url for each Ad Creative.
     */
    fetchThumbnailImages?: boolean;
    /**
     * Set to active if you want to include data from deleted Campaigns, Ads, and AdSets.
     */
    includeDeleted?: boolean;
    /**
     * The attribution window. Facebook freezes insight data 28 days after it was generated, which means that all data from the past 28 days may have changed since we last emitted it, so you can retrieve refreshed insights from the past by setting this parameter. If you set a custom lookback window value in Facebook account, please provide the same value here.
     */
    insightsLookbackWindow?: number;
    /**
     * Maximum batch size used when sending batch requests to Facebook API. Most users do not need to set this field unless they specifically need to tune the connector to address specific issues or use cases.
     */
    maxBatchSize?: number;
    /**
     * Page size used when sending requests to Facebook API to specify number of records per page when response has pagination. Most users do not need to set this field unless they specifically need to tune the connector to address specific issues or use cases.
     */
    pageSize?: number;
    /**
     * must be one of ["facebook-marketing"]
     */
    sourceType: string;
    /**
     * The date from which you'd like to replicate data for all incremental streams, in the format YYYY-MM-DDT00:00:00Z. All data generated after this date will be replicated.
     */
    startDate: string;
}

export interface SourceFacebookMarketingConfigurationCustomInsight {
    actionBreakdowns?: string[];
    actionReportTime?: string;
    breakdowns?: string[];
    endDate?: string;
    fields?: string[];
    insightsLookbackWindow?: number;
    level?: string;
    name: string;
    startDate?: string;
    timeIncrement?: number;
}

export interface SourceFacebookPagesConfiguration {
    /**
     * Facebook Page Access Token
     */
    accessToken: string;
    /**
     * Page ID
     */
    pageId: string;
    /**
     * must be one of ["facebook-pages"]
     */
    sourceType: string;
}

export interface SourceFakerConfiguration {
    /**
     * Should the updatedAt values for every record be new each sync?  Setting this to false will case the source to stop emitting records after COUNT records have been emitted.
     */
    alwaysUpdated?: boolean;
    /**
     * How many users should be generated in total.  This setting does not apply to the purchases or products stream.
     */
    count: number;
    /**
     * How many parallel workers should we use to generate fake data?  Choose a value equal to the number of CPUs you will allocate to this source.
     */
    parallelism?: number;
    /**
     * How many fake records will be in each page (stream slice), before a state message is emitted?
     */
    recordsPerSlice?: number;
    /**
     * Manually control the faker random seed to return the same values on subsequent runs (leave -1 for random)
     */
    seed?: number;
    /**
     * must be one of ["faker"]
     */
    sourceType: string;
}

export interface SourceFaunaConfiguration {
    /**
     * Settings for the Fauna Collection.
     */
    collection?: outputs.SourceFaunaConfigurationCollection;
    /**
     * Domain of Fauna to query. Defaults db.fauna.com. See \n\nthe docs\n\n.
     */
    domain: string;
    /**
     * Endpoint port.
     */
    port: number;
    /**
     * URL scheme.
     */
    scheme: string;
    /**
     * Fauna secret, used when authenticating with the database.
     */
    secret: string;
    /**
     * must be one of ["fauna"]
     */
    sourceType: string;
}

export interface SourceFaunaConfigurationCollection {
    deletions: outputs.SourceFaunaConfigurationCollectionDeletions;
    pageSize: number;
}

export interface SourceFaunaConfigurationCollectionDeletions {
    sourceFaunaCollectionDeletionModeDisabled?: outputs.SourceFaunaConfigurationCollectionDeletionsSourceFaunaCollectionDeletionModeDisabled;
    sourceFaunaCollectionDeletionModeEnabled?: outputs.SourceFaunaConfigurationCollectionDeletionsSourceFaunaCollectionDeletionModeEnabled;
    sourceFaunaUpdateCollectionDeletionModeDisabled?: outputs.SourceFaunaConfigurationCollectionDeletionsSourceFaunaUpdateCollectionDeletionModeDisabled;
    sourceFaunaUpdateCollectionDeletionModeEnabled?: outputs.SourceFaunaConfigurationCollectionDeletionsSourceFaunaUpdateCollectionDeletionModeEnabled;
}

export interface SourceFaunaConfigurationCollectionDeletionsSourceFaunaCollectionDeletionModeDisabled {
    deletionMode: string;
}

export interface SourceFaunaConfigurationCollectionDeletionsSourceFaunaCollectionDeletionModeEnabled {
    column: string;
    deletionMode: string;
}

export interface SourceFaunaConfigurationCollectionDeletionsSourceFaunaUpdateCollectionDeletionModeDisabled {
    deletionMode: string;
}

export interface SourceFaunaConfigurationCollectionDeletionsSourceFaunaUpdateCollectionDeletionModeEnabled {
    column: string;
    deletionMode: string;
}

export interface SourceFileSecureConfiguration {
    /**
     * The Name of the final table to replicate this file into (should include letters, numbers dash and underscores only).
     */
    datasetName: string;
    /**
     * must be one of ["csv", "json", "jsonl", "excel", "excelBinary", "feather", "parquet", "yaml"]
     * The Format of the file which should be replicated (Warning: some formats may be experimental, please refer to the docs).
     */
    format: string;
    /**
     * The storage Provider or Location of the file(s) which should be replicated.
     */
    provider: outputs.SourceFileSecureConfigurationProvider;
    /**
     * This should be a string in JSON format. It depends on the chosen file format to provide additional options and tune its behavior.
     */
    readerOptions?: string;
    /**
     * must be one of ["file-secure"]
     */
    sourceType: string;
    /**
     * The URL path to access the file which should be replicated.
     */
    url: string;
}

export interface SourceFileSecureConfigurationProvider {
    sourceFileSecureStorageProviderAzBlobAzureBlobStorage?: outputs.SourceFileSecureConfigurationProviderSourceFileSecureStorageProviderAzBlobAzureBlobStorage;
    sourceFileSecureStorageProviderGcsGoogleCloudStorage?: outputs.SourceFileSecureConfigurationProviderSourceFileSecureStorageProviderGcsGoogleCloudStorage;
    sourceFileSecureStorageProviderHttpsPublicWeb?: outputs.SourceFileSecureConfigurationProviderSourceFileSecureStorageProviderHttpsPublicWeb;
    sourceFileSecureStorageProviderS3AmazonWebServices?: outputs.SourceFileSecureConfigurationProviderSourceFileSecureStorageProviderS3AmazonWebServices;
    sourceFileSecureStorageProviderScpSecureCopyProtocol?: outputs.SourceFileSecureConfigurationProviderSourceFileSecureStorageProviderScpSecureCopyProtocol;
    sourceFileSecureStorageProviderSftpSecureFileTransferProtocol?: outputs.SourceFileSecureConfigurationProviderSourceFileSecureStorageProviderSftpSecureFileTransferProtocol;
    sourceFileSecureStorageProviderSshSecureShell?: outputs.SourceFileSecureConfigurationProviderSourceFileSecureStorageProviderSshSecureShell;
    sourceFileSecureUpdateStorageProviderAzBlobAzureBlobStorage?: outputs.SourceFileSecureConfigurationProviderSourceFileSecureUpdateStorageProviderAzBlobAzureBlobStorage;
    sourceFileSecureUpdateStorageProviderGcsGoogleCloudStorage?: outputs.SourceFileSecureConfigurationProviderSourceFileSecureUpdateStorageProviderGcsGoogleCloudStorage;
    sourceFileSecureUpdateStorageProviderHttpsPublicWeb?: outputs.SourceFileSecureConfigurationProviderSourceFileSecureUpdateStorageProviderHttpsPublicWeb;
    sourceFileSecureUpdateStorageProviderS3AmazonWebServices?: outputs.SourceFileSecureConfigurationProviderSourceFileSecureUpdateStorageProviderS3AmazonWebServices;
    sourceFileSecureUpdateStorageProviderScpSecureCopyProtocol?: outputs.SourceFileSecureConfigurationProviderSourceFileSecureUpdateStorageProviderScpSecureCopyProtocol;
    sourceFileSecureUpdateStorageProviderSftpSecureFileTransferProtocol?: outputs.SourceFileSecureConfigurationProviderSourceFileSecureUpdateStorageProviderSftpSecureFileTransferProtocol;
    sourceFileSecureUpdateStorageProviderSshSecureShell?: outputs.SourceFileSecureConfigurationProviderSourceFileSecureUpdateStorageProviderSshSecureShell;
}

export interface SourceFileSecureConfigurationProviderSourceFileSecureStorageProviderAzBlobAzureBlobStorage {
    sasToken?: string;
    sharedKey?: string;
    storage: string;
    storageAccount: string;
}

export interface SourceFileSecureConfigurationProviderSourceFileSecureStorageProviderGcsGoogleCloudStorage {
    serviceAccountJson?: string;
    storage: string;
}

export interface SourceFileSecureConfigurationProviderSourceFileSecureStorageProviderHttpsPublicWeb {
    storage: string;
    userAgent?: boolean;
}

export interface SourceFileSecureConfigurationProviderSourceFileSecureStorageProviderS3AmazonWebServices {
    awsAccessKeyId?: string;
    awsSecretAccessKey?: string;
    storage: string;
}

export interface SourceFileSecureConfigurationProviderSourceFileSecureStorageProviderScpSecureCopyProtocol {
    host: string;
    password?: string;
    port?: string;
    storage: string;
    user: string;
}

export interface SourceFileSecureConfigurationProviderSourceFileSecureStorageProviderSftpSecureFileTransferProtocol {
    host: string;
    password?: string;
    port?: string;
    storage: string;
    user: string;
}

export interface SourceFileSecureConfigurationProviderSourceFileSecureStorageProviderSshSecureShell {
    host: string;
    password?: string;
    port?: string;
    storage: string;
    user: string;
}

export interface SourceFileSecureConfigurationProviderSourceFileSecureUpdateStorageProviderAzBlobAzureBlobStorage {
    sasToken?: string;
    sharedKey?: string;
    storage: string;
    storageAccount: string;
}

export interface SourceFileSecureConfigurationProviderSourceFileSecureUpdateStorageProviderGcsGoogleCloudStorage {
    serviceAccountJson?: string;
    storage: string;
}

export interface SourceFileSecureConfigurationProviderSourceFileSecureUpdateStorageProviderHttpsPublicWeb {
    storage: string;
    userAgent?: boolean;
}

export interface SourceFileSecureConfigurationProviderSourceFileSecureUpdateStorageProviderS3AmazonWebServices {
    awsAccessKeyId?: string;
    awsSecretAccessKey?: string;
    storage: string;
}

export interface SourceFileSecureConfigurationProviderSourceFileSecureUpdateStorageProviderScpSecureCopyProtocol {
    host: string;
    password?: string;
    port?: string;
    storage: string;
    user: string;
}

export interface SourceFileSecureConfigurationProviderSourceFileSecureUpdateStorageProviderSftpSecureFileTransferProtocol {
    host: string;
    password?: string;
    port?: string;
    storage: string;
    user: string;
}

export interface SourceFileSecureConfigurationProviderSourceFileSecureUpdateStorageProviderSshSecureShell {
    host: string;
    password?: string;
    port?: string;
    storage: string;
    user: string;
}

export interface SourceFireboltConfiguration {
    /**
     * Firebolt account to login.
     */
    account?: string;
    /**
     * The database to connect to.
     */
    database: string;
    /**
     * Engine name or url to connect to.
     */
    engine?: string;
    /**
     * The host name of your Firebolt database.
     */
    host?: string;
    /**
     * Firebolt password.
     */
    password: string;
    /**
     * must be one of ["firebolt"]
     */
    sourceType: string;
    /**
     * Firebolt email address you use to login.
     */
    username: string;
}

export interface SourceFreshcallerConfiguration {
    /**
     * Freshcaller API Key. See the \n\ndocs\n\n for more information on how to obtain this key.
     */
    apiKey: string;
    /**
     * Used to construct Base URL for the Freshcaller APIs
     */
    domain: string;
    /**
     * The number of requests per minute that this source allowed to use. There is a rate limit of 50 requests per minute per app per account.
     */
    requestsPerMinute?: number;
    /**
     * must be one of ["freshcaller"]
     */
    sourceType: string;
    /**
     * UTC date and time. Any data created after this date will be replicated.
     */
    startDate: string;
    /**
     * Lag in minutes for each sync, i.e., at time T, data for the time range [prev*sync*time, T-30] will be fetched
     */
    syncLagMinutes?: number;
}

export interface SourceFreshdeskConfiguration {
    /**
     * Freshdesk API Key. See the \n\ndocs\n\n for more information on how to obtain this key.
     */
    apiKey: string;
    /**
     * Freshdesk domain
     */
    domain: string;
    /**
     * The number of requests per minute that this source allowed to use. There is a rate limit of 50 requests per minute per app per account.
     */
    requestsPerMinute?: number;
    /**
     * must be one of ["freshdesk"]
     */
    sourceType: string;
    /**
     * UTC date and time. Any data created after this date will be replicated. If this parameter is not set, all data will be replicated.
     */
    startDate?: string;
}

export interface SourceFreshsalesConfiguration {
    /**
     * Freshsales API Key. See \n\nhere\n\n. The key is case sensitive.
     */
    apiKey: string;
    /**
     * The Name of your Freshsales domain
     */
    domainName: string;
    /**
     * must be one of ["freshsales"]
     */
    sourceType: string;
}

export interface SourceGainsightPxConfiguration {
    /**
     * The Aptrinsic API Key which is recieved from the dashboard settings (ref - https://app.aptrinsic.com/settings/api-keys)
     */
    apiKey: string;
    /**
     * must be one of ["gainsight-px"]
     */
    sourceType: string;
}

export interface SourceGcsConfiguration {
    /**
     * GCS bucket name
     */
    gcsBucket: string;
    /**
     * GCS path to data
     */
    gcsPath: string;
    /**
     * Enter your Google Cloud \n\nservice account key\n\n in JSON format
     */
    serviceAccount: string;
    /**
     * must be one of ["gcs"]
     */
    sourceType: string;
}

export interface SourceGetlagoConfiguration {
    /**
     * Your API Key. See \n\nhere\n\n.
     */
    apiKey: string;
    /**
     * must be one of ["getlago"]
     */
    sourceType: string;
}

export interface SourceGithubConfiguration {
    /**
     * Space-delimited list of GitHub repository branches to pull commits for, e.g. `airbytehq/airbyte/master`. If no branches are specified for a repository, the default branch will be pulled.
     */
    branch?: string;
    /**
     * Choose how to authenticate to GitHub
     */
    credentials?: outputs.SourceGithubConfigurationCredentials;
    /**
     * Space-delimited list of GitHub organizations/repositories, e.g. `airbytehq/airbyte` for single repository, `airbytehq/*` for get all repositories from organization and `airbytehq/airbyte airbytehq/another-repo` for multiple repositories.
     */
    repository: string;
    /**
     * The GitHub API allows for a maximum of 5000 requests per hour (15000 for Github Enterprise). You can specify a lower value to limit your use of the API quota.
     */
    requestsPerHour?: number;
    /**
     * must be one of ["github"]
     */
    sourceType: string;
    /**
     * The date from which you'd like to replicate data from GitHub in the format YYYY-MM-DDT00:00:00Z. For the streams which support this configuration, only data generated on or after the start date will be replicated. This field doesn't apply to all streams, see the \n\ndocs\n\n for more info
     */
    startDate: string;
}

export interface SourceGithubConfigurationCredentials {
    sourceGithubAuthenticationOAuth?: outputs.SourceGithubConfigurationCredentialsSourceGithubAuthenticationOAuth;
    sourceGithubAuthenticationPersonalAccessToken?: outputs.SourceGithubConfigurationCredentialsSourceGithubAuthenticationPersonalAccessToken;
    sourceGithubUpdateAuthenticationOAuth?: outputs.SourceGithubConfigurationCredentialsSourceGithubUpdateAuthenticationOAuth;
    sourceGithubUpdateAuthenticationPersonalAccessToken?: outputs.SourceGithubConfigurationCredentialsSourceGithubUpdateAuthenticationPersonalAccessToken;
}

export interface SourceGithubConfigurationCredentialsSourceGithubAuthenticationOAuth {
    accessToken: string;
    clientId?: string;
    clientSecret?: string;
    optionTitle?: string;
}

export interface SourceGithubConfigurationCredentialsSourceGithubAuthenticationPersonalAccessToken {
    optionTitle?: string;
    personalAccessToken: string;
}

export interface SourceGithubConfigurationCredentialsSourceGithubUpdateAuthenticationOAuth {
    accessToken: string;
    clientId?: string;
    clientSecret?: string;
    optionTitle?: string;
}

export interface SourceGithubConfigurationCredentialsSourceGithubUpdateAuthenticationPersonalAccessToken {
    optionTitle?: string;
    personalAccessToken: string;
}

export interface SourceGitlabConfiguration {
    /**
     * Please enter your basic URL from GitLab instance.
     */
    apiUrl?: string;
    credentials: outputs.SourceGitlabConfigurationCredentials;
    /**
     * Space-delimited list of groups. e.g. airbyte.io.
     */
    groups?: string;
    /**
     * Space-delimited list of projects. e.g. airbyte.io/documentation meltano/tap-gitlab.
     */
    projects?: string;
    /**
     * must be one of ["gitlab"]
     */
    sourceType: string;
    /**
     * The date from which you'd like to replicate data for GitLab API, in the format YYYY-MM-DDT00:00:00Z. All data generated after this date will be replicated.
     */
    startDate: string;
}

export interface SourceGitlabConfigurationCredentials {
    sourceGitlabAuthorizationMethodOAuth20?: outputs.SourceGitlabConfigurationCredentialsSourceGitlabAuthorizationMethodOAuth20;
    sourceGitlabAuthorizationMethodPrivateToken?: outputs.SourceGitlabConfigurationCredentialsSourceGitlabAuthorizationMethodPrivateToken;
    sourceGitlabUpdateAuthorizationMethodOAuth20?: outputs.SourceGitlabConfigurationCredentialsSourceGitlabUpdateAuthorizationMethodOAuth20;
    sourceGitlabUpdateAuthorizationMethodPrivateToken?: outputs.SourceGitlabConfigurationCredentialsSourceGitlabUpdateAuthorizationMethodPrivateToken;
}

export interface SourceGitlabConfigurationCredentialsSourceGitlabAuthorizationMethodOAuth20 {
    accessToken: string;
    authType?: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
    tokenExpiryDate: string;
}

export interface SourceGitlabConfigurationCredentialsSourceGitlabAuthorizationMethodPrivateToken {
    accessToken: string;
    authType?: string;
}

export interface SourceGitlabConfigurationCredentialsSourceGitlabUpdateAuthorizationMethodOAuth20 {
    accessToken: string;
    authType?: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
    tokenExpiryDate: string;
}

export interface SourceGitlabConfigurationCredentialsSourceGitlabUpdateAuthorizationMethodPrivateToken {
    accessToken: string;
    authType?: string;
}

export interface SourceGlassfrogConfiguration {
    /**
     * API key provided by Glassfrog
     */
    apiKey: string;
    /**
     * must be one of ["glassfrog"]
     */
    sourceType: string;
}

export interface SourceGnewsConfiguration {
    apiKey: string;
    country?: string;
    endDate?: string;
    ins?: string[];
    language?: string;
    nullables?: string[];
    query: string;
    sortby?: string;
    sourceType: string;
    startDate?: string;
    topHeadlinesQuery?: string;
    topHeadlinesTopic?: string;
}

export interface SourceGoogleAdsConfiguration {
    /**
     * A conversion window is the number of days after an ad interaction (such as an ad click or video view) during which a conversion, such as a purchase, is recorded in Google Ads. For more information, see \n\nGoogle's documentation\n\n.
     */
    conversionWindowDays?: number;
    credentials: outputs.SourceGoogleAdsConfigurationCredentials;
    customQueries?: outputs.SourceGoogleAdsConfigurationCustomQuery[];
    /**
     * Comma-separated list of (client) customer IDs. Each customer ID must be specified as a 10-digit number without dashes. For detailed instructions on finding this value, refer to our \n\ndocumentation\n\n.
     */
    customerId: string;
    /**
     * UTC date in the format YYYY-MM-DD. Any data after this date will not be replicated.
     */
    endDate?: string;
    /**
     * If your access to the customer account is through a manager account, this field is required, and must be set to the 10-digit customer ID of the manager account. For more information about this field, refer to \n\nGoogle's documentation\n\n.
     */
    loginCustomerId?: string;
    /**
     * must be one of ["google-ads"]
     */
    sourceType: string;
    /**
     * UTC date in the format YYYY-MM-DD. Any data before this date will not be replicated.
     */
    startDate: string;
}

export interface SourceGoogleAdsConfigurationCredentials {
    accessToken?: string;
    clientId: string;
    clientSecret: string;
    developerToken: string;
    refreshToken: string;
}

export interface SourceGoogleAdsConfigurationCustomQuery {
    query: string;
    tableName: string;
}

export interface SourceGoogleAnalyticsDataApiConfiguration {
    /**
     * Credentials for the service
     */
    credentials?: outputs.SourceGoogleAnalyticsDataApiConfigurationCredentials;
    /**
     * A JSON array describing the custom reports you want to sync from Google Analytics. See \n\nthe documentation\n\n for more information about the exact format you can use to fill out this field.
     */
    customReports?: string;
    /**
     * The start date from which to replicate report data in the format YYYY-MM-DD. Data generated before this date will not be included in the report. Not applied to custom Cohort reports.
     */
    dateRangesStartDate: string;
    /**
     * The Property ID is a unique number assigned to each property in Google Analytics, found in your GA4 property URL. This ID allows the connector to track the specific events associated with your property. Refer to the \n\nGoogle Analytics documentation\n\n to locate your property ID.
     */
    propertyId: string;
    /**
     * must be one of ["google-analytics-data-api"]
     */
    sourceType: string;
    /**
     * The interval in days for each data request made to the Google Analytics API. A larger value speeds up data sync, but increases the chance of data sampling, which may result in inaccuracies. We recommend a value of 1 to minimize sampling, unless speed is an absolute priority over accuracy. Acceptable values range from 1 to 364. Does not apply to custom Cohort reports. More information is available in \n\nthe documentation\n\n.
     */
    windowInDays?: number;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCredentials {
    sourceGoogleAnalyticsDataApiCredentialsAuthenticateViaGoogleOauth?: outputs.SourceGoogleAnalyticsDataApiConfigurationCredentialsSourceGoogleAnalyticsDataApiCredentialsAuthenticateViaGoogleOauth;
    sourceGoogleAnalyticsDataApiCredentialsServiceAccountKeyAuthentication?: outputs.SourceGoogleAnalyticsDataApiConfigurationCredentialsSourceGoogleAnalyticsDataApiCredentialsServiceAccountKeyAuthentication;
    sourceGoogleAnalyticsDataApiUpdateCredentialsAuthenticateViaGoogleOauth?: outputs.SourceGoogleAnalyticsDataApiConfigurationCredentialsSourceGoogleAnalyticsDataApiUpdateCredentialsAuthenticateViaGoogleOauth;
    sourceGoogleAnalyticsDataApiUpdateCredentialsServiceAccountKeyAuthentication?: outputs.SourceGoogleAnalyticsDataApiConfigurationCredentialsSourceGoogleAnalyticsDataApiUpdateCredentialsServiceAccountKeyAuthentication;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCredentialsSourceGoogleAnalyticsDataApiCredentialsAuthenticateViaGoogleOauth {
    accessToken?: string;
    authType?: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCredentialsSourceGoogleAnalyticsDataApiCredentialsServiceAccountKeyAuthentication {
    authType?: string;
    credentialsJson: string;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCredentialsSourceGoogleAnalyticsDataApiUpdateCredentialsAuthenticateViaGoogleOauth {
    accessToken?: string;
    authType?: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCredentialsSourceGoogleAnalyticsDataApiUpdateCredentialsServiceAccountKeyAuthentication {
    authType?: string;
    credentialsJson: string;
}

export interface SourceGoogleAnalyticsV4Configuration {
    /**
     * Credentials for the service
     */
    credentials?: outputs.SourceGoogleAnalyticsV4ConfigurationCredentials;
    /**
     * A JSON array describing the custom reports you want to sync from Google Analytics. See \n\nthe docs\n\n for more information about the exact format you can use to fill out this field.
     */
    customReports?: string;
    /**
     * must be one of ["google-analytics-v4"]
     */
    sourceType: string;
    /**
     * The date in the format YYYY-MM-DD. Any data before this date will not be replicated.
     */
    startDate: string;
    /**
     * The ID for the Google Analytics View you want to fetch data from. This can be found from the \n\nGoogle Analytics Account Explorer\n\n.
     */
    viewId: string;
    /**
     * The time increment used by the connector when requesting data from the Google Analytics API. More information is available in the \n\nthe docs\n\n. The bigger this value is, the faster the sync will be, but the more likely that sampling will be applied to your data, potentially causing inaccuracies in the returned results. We recommend setting this to 1 unless you have a hard requirement to make the sync faster at the expense of accuracy. The minimum allowed value for this field is 1, and the maximum is 364.
     */
    windowInDays?: number;
}

export interface SourceGoogleAnalyticsV4ConfigurationCredentials {
    sourceGoogleAnalyticsV4CredentialsAuthenticateViaGoogleOauth?: outputs.SourceGoogleAnalyticsV4ConfigurationCredentialsSourceGoogleAnalyticsV4CredentialsAuthenticateViaGoogleOauth;
    sourceGoogleAnalyticsV4CredentialsServiceAccountKeyAuthentication?: outputs.SourceGoogleAnalyticsV4ConfigurationCredentialsSourceGoogleAnalyticsV4CredentialsServiceAccountKeyAuthentication;
    sourceGoogleAnalyticsV4UpdateCredentialsAuthenticateViaGoogleOauth?: outputs.SourceGoogleAnalyticsV4ConfigurationCredentialsSourceGoogleAnalyticsV4UpdateCredentialsAuthenticateViaGoogleOauth;
    sourceGoogleAnalyticsV4UpdateCredentialsServiceAccountKeyAuthentication?: outputs.SourceGoogleAnalyticsV4ConfigurationCredentialsSourceGoogleAnalyticsV4UpdateCredentialsServiceAccountKeyAuthentication;
}

export interface SourceGoogleAnalyticsV4ConfigurationCredentialsSourceGoogleAnalyticsV4CredentialsAuthenticateViaGoogleOauth {
    accessToken?: string;
    authType?: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
}

export interface SourceGoogleAnalyticsV4ConfigurationCredentialsSourceGoogleAnalyticsV4CredentialsServiceAccountKeyAuthentication {
    authType?: string;
    credentialsJson: string;
}

export interface SourceGoogleAnalyticsV4ConfigurationCredentialsSourceGoogleAnalyticsV4UpdateCredentialsAuthenticateViaGoogleOauth {
    accessToken?: string;
    authType?: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
}

export interface SourceGoogleAnalyticsV4ConfigurationCredentialsSourceGoogleAnalyticsV4UpdateCredentialsServiceAccountKeyAuthentication {
    authType?: string;
    credentialsJson: string;
}

export interface SourceGoogleDirectoryConfiguration {
    /**
     * Google APIs use the OAuth 2.0 protocol for authentication and authorization. The Source supports \n\nWeb server application\n\n and \n\nService accounts\n\n scenarios.
     */
    credentials?: outputs.SourceGoogleDirectoryConfigurationCredentials;
    /**
     * must be one of ["google-directory"]
     */
    sourceType: string;
}

export interface SourceGoogleDirectoryConfigurationCredentials {
    sourceGoogleDirectoryGoogleCredentialsServiceAccountKey?: outputs.SourceGoogleDirectoryConfigurationCredentialsSourceGoogleDirectoryGoogleCredentialsServiceAccountKey;
    sourceGoogleDirectoryGoogleCredentialsSignInViaGoogleOAuth?: outputs.SourceGoogleDirectoryConfigurationCredentialsSourceGoogleDirectoryGoogleCredentialsSignInViaGoogleOAuth;
    sourceGoogleDirectoryUpdateGoogleCredentialsServiceAccountKey?: outputs.SourceGoogleDirectoryConfigurationCredentialsSourceGoogleDirectoryUpdateGoogleCredentialsServiceAccountKey;
    sourceGoogleDirectoryUpdateGoogleCredentialsSignInViaGoogleOAuth?: outputs.SourceGoogleDirectoryConfigurationCredentialsSourceGoogleDirectoryUpdateGoogleCredentialsSignInViaGoogleOAuth;
}

export interface SourceGoogleDirectoryConfigurationCredentialsSourceGoogleDirectoryGoogleCredentialsServiceAccountKey {
    credentialsJson: string;
    credentialsTitle?: string;
    email: string;
}

export interface SourceGoogleDirectoryConfigurationCredentialsSourceGoogleDirectoryGoogleCredentialsSignInViaGoogleOAuth {
    clientId: string;
    clientSecret: string;
    credentialsTitle?: string;
    refreshToken: string;
}

export interface SourceGoogleDirectoryConfigurationCredentialsSourceGoogleDirectoryUpdateGoogleCredentialsServiceAccountKey {
    credentialsJson: string;
    credentialsTitle?: string;
    email: string;
}

export interface SourceGoogleDirectoryConfigurationCredentialsSourceGoogleDirectoryUpdateGoogleCredentialsSignInViaGoogleOAuth {
    clientId: string;
    clientSecret: string;
    credentialsTitle?: string;
    refreshToken: string;
}

export interface SourceGooglePagespeedInsightsConfiguration {
    /**
     * Google PageSpeed API Key. See \n\nhere\n\n. The key is optional - however the API is heavily rate limited when using without API Key. Creating and using the API key therefore is recommended. The key is case sensitive.
     */
    apiKey?: string;
    /**
     * Defines which Lighthouse category to run. One or many of: "accessibility", "best-practices", "performance", "pwa", "seo".
     */
    categories: string[];
    /**
     * must be one of ["google-pagespeed-insights"]
     */
    sourceType: string;
    /**
     * The analyses strategy to use. Either "desktop" or "mobile".
     */
    strategies: string[];
    /**
     * The URLs to retrieve pagespeed information from. The connector will attempt to sync PageSpeed reports for all the defined URLs. Format: https://(www.)url.domain
     */
    urls: string[];
}

export interface SourceGoogleSearchConsoleConfiguration {
    authorization: outputs.SourceGoogleSearchConsoleConfigurationAuthorization;
    /**
     * A JSON array describing the custom reports you want to sync from Google Search Console. See \n\nthe docs\n\n for more information about the exact format you can use to fill out this field.
     */
    customReports?: string;
    /**
     * must be one of ["final", "all"]
     * If "final" or if this parameter is omitted, the returned data will include only finalized data. Setting this parameter to "all" should not be used with Incremental Sync mode as it may cause data loss. If "all", data will include fresh data.
     */
    dataState?: string;
    /**
     * UTC date in the format 2017-01-25. Any data after this date will not be replicated. Must be greater or equal to the start date field.
     */
    endDate?: string;
    /**
     * The URLs of the website property attached to your GSC account. Read more \n\nhere\n\n.
     */
    siteUrls: string[];
    /**
     * must be one of ["google-search-console"]
     */
    sourceType: string;
    /**
     * UTC date in the format 2017-01-25. Any data before this date will not be replicated.
     */
    startDate: string;
}

export interface SourceGoogleSearchConsoleConfigurationAuthorization {
    sourceGoogleSearchConsoleAuthenticationTypeOAuth?: outputs.SourceGoogleSearchConsoleConfigurationAuthorizationSourceGoogleSearchConsoleAuthenticationTypeOAuth;
    sourceGoogleSearchConsoleAuthenticationTypeServiceAccountKeyAuthentication?: outputs.SourceGoogleSearchConsoleConfigurationAuthorizationSourceGoogleSearchConsoleAuthenticationTypeServiceAccountKeyAuthentication;
    sourceGoogleSearchConsoleUpdateAuthenticationTypeOAuth?: outputs.SourceGoogleSearchConsoleConfigurationAuthorizationSourceGoogleSearchConsoleUpdateAuthenticationTypeOAuth;
    sourceGoogleSearchConsoleUpdateAuthenticationTypeServiceAccountKeyAuthentication?: outputs.SourceGoogleSearchConsoleConfigurationAuthorizationSourceGoogleSearchConsoleUpdateAuthenticationTypeServiceAccountKeyAuthentication;
}

export interface SourceGoogleSearchConsoleConfigurationAuthorizationSourceGoogleSearchConsoleAuthenticationTypeOAuth {
    accessToken?: string;
    authType: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
}

export interface SourceGoogleSearchConsoleConfigurationAuthorizationSourceGoogleSearchConsoleAuthenticationTypeServiceAccountKeyAuthentication {
    authType: string;
    email: string;
    serviceAccountInfo: string;
}

export interface SourceGoogleSearchConsoleConfigurationAuthorizationSourceGoogleSearchConsoleUpdateAuthenticationTypeOAuth {
    accessToken?: string;
    authType: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
}

export interface SourceGoogleSearchConsoleConfigurationAuthorizationSourceGoogleSearchConsoleUpdateAuthenticationTypeServiceAccountKeyAuthentication {
    authType: string;
    email: string;
    serviceAccountInfo: string;
}

export interface SourceGoogleSheetsConfiguration {
    /**
     * Credentials for connecting to the Google Sheets API
     */
    credentials: outputs.SourceGoogleSheetsConfigurationCredentials;
    /**
     * Enables the conversion of column names to a standardized, SQL-compliant format. For example, 'My Name' > 'my_name'. Enable this option if your destination is SQL-based.
     */
    namesConversion?: boolean;
    /**
     * The number of rows fetched when making a Google Sheet API call. Defaults to 200.
     */
    rowBatchSize?: number;
    /**
     * must be one of ["google-sheets"]
     */
    sourceType: string;
    /**
     * Enter the link to the Google spreadsheet you want to sync. To copy the link, click the 'Share' button in the top-right corner of the spreadsheet, then click 'Copy link'.
     */
    spreadsheetId: string;
}

export interface SourceGoogleSheetsConfigurationCredentials {
    sourceGoogleSheetsAuthenticationAuthenticateViaGoogleOAuth?: outputs.SourceGoogleSheetsConfigurationCredentialsSourceGoogleSheetsAuthenticationAuthenticateViaGoogleOAuth;
    sourceGoogleSheetsAuthenticationServiceAccountKeyAuthentication?: outputs.SourceGoogleSheetsConfigurationCredentialsSourceGoogleSheetsAuthenticationServiceAccountKeyAuthentication;
    sourceGoogleSheetsUpdateAuthenticationAuthenticateViaGoogleOAuth?: outputs.SourceGoogleSheetsConfigurationCredentialsSourceGoogleSheetsUpdateAuthenticationAuthenticateViaGoogleOAuth;
    sourceGoogleSheetsUpdateAuthenticationServiceAccountKeyAuthentication?: outputs.SourceGoogleSheetsConfigurationCredentialsSourceGoogleSheetsUpdateAuthenticationServiceAccountKeyAuthentication;
}

export interface SourceGoogleSheetsConfigurationCredentialsSourceGoogleSheetsAuthenticationAuthenticateViaGoogleOAuth {
    authType: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
}

export interface SourceGoogleSheetsConfigurationCredentialsSourceGoogleSheetsAuthenticationServiceAccountKeyAuthentication {
    authType: string;
    serviceAccountInfo: string;
}

export interface SourceGoogleSheetsConfigurationCredentialsSourceGoogleSheetsUpdateAuthenticationAuthenticateViaGoogleOAuth {
    authType: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
}

export interface SourceGoogleSheetsConfigurationCredentialsSourceGoogleSheetsUpdateAuthenticationServiceAccountKeyAuthentication {
    authType: string;
    serviceAccountInfo: string;
}

export interface SourceGoogleWebfontsConfiguration {
    /**
     * Optional, Available params- json, media, proto
     */
    alt?: string;
    /**
     * API key is required to access google apis, For getting your's goto google console and generate api key for Webfonts
     */
    apiKey: string;
    /**
     * Optional, boolean type
     */
    prettyPrint?: string;
    /**
     * Optional, to find how to sort
     */
    sort?: string;
    /**
     * must be one of ["google-webfonts"]
     */
    sourceType: string;
}

export interface SourceGoogleWorkspaceAdminReportsConfiguration {
    /**
     * The contents of the JSON service account key. See the \n\ndocs\n\n for more information on how to generate this key.
     */
    credentialsJson: string;
    /**
     * The email of the user, which has permissions to access the Google Workspace Admin APIs.
     */
    email: string;
    /**
     * Sets the range of time shown in the report. Reports API allows from up to 180 days ago.
     */
    lookback?: number;
    /**
     * must be one of ["google-workspace-admin-reports"]
     */
    sourceType: string;
}

export interface SourceGreenhouseConfiguration {
    /**
     * Greenhouse API Key. See the \n\ndocs\n\n for more information on how to generate this key.
     */
    apiKey: string;
    /**
     * must be one of ["greenhouse"]
     */
    sourceType: string;
}

export interface SourceGridlyConfiguration {
    apiKey: string;
    /**
     * ID of a grid, or can be ID of a branch
     */
    gridId: string;
    /**
     * must be one of ["gridly"]
     */
    sourceType: string;
}

export interface SourceHarvestConfiguration {
    /**
     * Harvest account ID. Required for all Harvest requests in pair with Personal Access Token
     */
    accountId: string;
    /**
     * Choose how to authenticate to Harvest.
     */
    credentials?: outputs.SourceHarvestConfigurationCredentials;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Any data after this date will not be replicated.
     */
    replicationEndDate?: string;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
     */
    replicationStartDate: string;
    /**
     * must be one of ["harvest"]
     */
    sourceType: string;
}

export interface SourceHarvestConfigurationCredentials {
    sourceHarvestAuthenticationMechanismAuthenticateViaHarvestOAuth?: outputs.SourceHarvestConfigurationCredentialsSourceHarvestAuthenticationMechanismAuthenticateViaHarvestOAuth;
    sourceHarvestAuthenticationMechanismAuthenticateWithPersonalAccessToken?: outputs.SourceHarvestConfigurationCredentialsSourceHarvestAuthenticationMechanismAuthenticateWithPersonalAccessToken;
    sourceHarvestUpdateAuthenticationMechanismAuthenticateViaHarvestOAuth?: outputs.SourceHarvestConfigurationCredentialsSourceHarvestUpdateAuthenticationMechanismAuthenticateViaHarvestOAuth;
    sourceHarvestUpdateAuthenticationMechanismAuthenticateWithPersonalAccessToken?: outputs.SourceHarvestConfigurationCredentialsSourceHarvestUpdateAuthenticationMechanismAuthenticateWithPersonalAccessToken;
}

export interface SourceHarvestConfigurationCredentialsSourceHarvestAuthenticationMechanismAuthenticateViaHarvestOAuth {
    additionalProperties?: string;
    authType?: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
}

export interface SourceHarvestConfigurationCredentialsSourceHarvestAuthenticationMechanismAuthenticateWithPersonalAccessToken {
    additionalProperties?: string;
    apiToken: string;
    authType?: string;
}

export interface SourceHarvestConfigurationCredentialsSourceHarvestUpdateAuthenticationMechanismAuthenticateViaHarvestOAuth {
    additionalProperties?: string;
    authType?: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
}

export interface SourceHarvestConfigurationCredentialsSourceHarvestUpdateAuthenticationMechanismAuthenticateWithPersonalAccessToken {
    additionalProperties?: string;
    apiToken: string;
    authType?: string;
}

export interface SourceHubplannerConfiguration {
    /**
     * Hubplanner API key. See https://github.com/hubplanner/API#authentication for more details.
     */
    apiKey: string;
    /**
     * must be one of ["hubplanner"]
     */
    sourceType: string;
}

export interface SourceHubspotConfiguration {
    /**
     * Choose how to authenticate to HubSpot.
     */
    credentials: outputs.SourceHubspotConfigurationCredentials;
    /**
     * must be one of ["hubspot"]
     */
    sourceType: string;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
     */
    startDate: string;
}

export interface SourceHubspotConfigurationCredentials {
    sourceHubspotAuthenticationOAuth?: outputs.SourceHubspotConfigurationCredentialsSourceHubspotAuthenticationOAuth;
    sourceHubspotAuthenticationPrivateApp?: outputs.SourceHubspotConfigurationCredentialsSourceHubspotAuthenticationPrivateApp;
    sourceHubspotUpdateAuthenticationOAuth?: outputs.SourceHubspotConfigurationCredentialsSourceHubspotUpdateAuthenticationOAuth;
    sourceHubspotUpdateAuthenticationPrivateApp?: outputs.SourceHubspotConfigurationCredentialsSourceHubspotUpdateAuthenticationPrivateApp;
}

export interface SourceHubspotConfigurationCredentialsSourceHubspotAuthenticationOAuth {
    clientId: string;
    clientSecret: string;
    credentialsTitle: string;
    refreshToken: string;
}

export interface SourceHubspotConfigurationCredentialsSourceHubspotAuthenticationPrivateApp {
    accessToken: string;
    credentialsTitle: string;
}

export interface SourceHubspotConfigurationCredentialsSourceHubspotUpdateAuthenticationOAuth {
    clientId: string;
    clientSecret: string;
    credentialsTitle: string;
    refreshToken: string;
}

export interface SourceHubspotConfigurationCredentialsSourceHubspotUpdateAuthenticationPrivateApp {
    accessToken: string;
    credentialsTitle: string;
}

export interface SourceInsightlyConfiguration {
    /**
     * must be one of ["insightly"]
     */
    sourceType: string;
    /**
     * The date from which you'd like to replicate data for Insightly in the format YYYY-MM-DDT00:00:00Z. All data generated after this date will be replicated. Note that it will be used only for incremental streams.
     */
    startDate: string;
    /**
     * Your Insightly API token.
     */
    token: string;
}

export interface SourceInstagramConfiguration {
    /**
     * The value of the access token generated with \n\ninstagram*basic, instagram*manage*insights, pages*show*list, pages*read_engagement, Instagram Public Content Access\n\n permissions. See the \n\ndocs\n\n for more information
     */
    accessToken: string;
    /**
     * The Client ID for your Oauth application
     */
    clientId?: string;
    /**
     * The Client Secret for your Oauth application
     */
    clientSecret?: string;
    /**
     * must be one of ["instagram"]
     */
    sourceType: string;
    /**
     * The date from which you'd like to replicate data for User Insights, in the format YYYY-MM-DDT00:00:00Z. All data generated after this date will be replicated.
     */
    startDate: string;
}

export interface SourceInstatusConfiguration {
    /**
     * Instatus REST API key
     */
    apiKey: string;
    /**
     * must be one of ["instatus"]
     */
    sourceType: string;
}

export interface SourceIntercomConfiguration {
    /**
     * Access token for making authenticated requests. See the \n\nIntercom docs\n\n for more information.
     */
    accessToken: string;
    /**
     * must be one of ["intercom"]
     */
    sourceType: string;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
     */
    startDate: string;
}

export interface SourceIp2whoisConfiguration {
    /**
     * Your API Key. See \n\nhere\n\n.
     */
    apiKey?: string;
    /**
     * Domain name. See \n\nhere\n\n.
     */
    domain?: string;
    /**
     * must be one of ["ip2whois"]
     */
    sourceType?: string;
}

export interface SourceIterableConfiguration {
    /**
     * Iterable API Key. See the \n\ndocs\n\n for more information on how to obtain this key.
     */
    apiKey: string;
    /**
     * must be one of ["iterable"]
     */
    sourceType: string;
    /**
     * The date from which you'd like to replicate data for Iterable, in the format YYYY-MM-DDT00:00:00Z. All data generated after this date will be replicated.
     */
    startDate: string;
}

export interface SourceJiraConfiguration {
    /**
     * Jira API Token. See the \n\ndocs\n\n for more information on how to generate this key. API Token is used for Authorization to your account by BasicAuth.
     */
    apiToken: string;
    /**
     * The Domain for your Jira account, e.g. airbyteio.atlassian.net, airbyteio.jira.com, jira.your-domain.com
     */
    domain: string;
    /**
     * The user email for your Jira account which you used to generate the API token. This field is used for Authorization to your account by BasicAuth.
     */
    email: string;
    /**
     * Allow the use of experimental streams which rely on undocumented Jira API endpoints. See https://docs.airbyte.com/integrations/sources/jira#experimental-tables for more info.
     */
    enableExperimentalStreams?: boolean;
    /**
     * Expand the changelog when replicating issues.
     */
    expandIssueChangelog?: boolean;
    /**
     * List of Jira project keys to replicate data for, or leave it empty if you want to replicate data for all projects.
     */
    projects?: string[];
    /**
     * Render issue fields in HTML format in addition to Jira JSON-like format.
     */
    renderFields?: boolean;
    /**
     * must be one of ["jira"]
     */
    sourceType: string;
    /**
     * The date from which you want to replicate data from Jira, use the format YYYY-MM-DDT00:00:00Z. Note that this field only applies to certain streams, and only data generated on or after the start date will be replicated. Or leave it empty if you want to replicate all data. For more information, refer to the \n\ndocumentation\n\n.
     */
    startDate?: string;
}

export interface SourceK6CloudConfiguration {
    /**
     * Your API Token. See \n\nhere\n\n. The key is case sensitive.
     */
    apiToken: string;
    /**
     * must be one of ["k6-cloud"]
     */
    sourceType: string;
}

export interface SourceKlarnaConfiguration {
    /**
     * A string which is associated with your Merchant ID and is used to authorize use of Klarna's APIs (https://developers.klarna.com/api/#authentication)
     */
    password: string;
    /**
     * Propertie defining if connector is used against playground or production environment
     */
    playground: boolean;
    /**
     * must be one of ["eu", "us", "oc"]
     * Base url region (For playground eu https://docs.klarna.com/klarna-payments/api/payments-api/#tag/API-URLs). Supported 'eu', 'us', 'oc'
     */
    region: string;
    /**
     * must be one of ["klarna"]
     */
    sourceType: string;
    /**
     * Consists of your Merchant ID (eid) - a unique number that identifies your e-store, combined with a random string (https://developers.klarna.com/api/#authentication)
     */
    username: string;
}

export interface SourceKlaviyoConfiguration {
    /**
     * Klaviyo API Key. See our \n\ndocs\n\n if you need help finding this key.
     */
    apiKey: string;
    /**
     * must be one of ["klaviyo"]
     */
    sourceType: string;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
     */
    startDate: string;
}

export interface SourceKustomerSingerConfiguration {
    /**
     * Kustomer API Token. See the \n\ndocs\n\n on how to obtain this
     */
    apiToken: string;
    /**
     * must be one of ["kustomer-singer"]
     */
    sourceType: string;
    /**
     * The date from which you'd like to replicate the data
     */
    startDate: string;
}

export interface SourceKyveConfiguration {
    /**
     * The maximum amount of pages to go trough. Set to 'null' for all pages.
     */
    maxPages?: number;
    /**
     * The pagesize for pagination, smaller numbers are used in integration tests.
     */
    pageSize?: number;
    /**
     * The IDs of the KYVE storage pool you want to archive. (Comma separated)
     */
    poolIds: string;
    /**
     * must be one of ["kyve"]
     */
    sourceType: string;
    /**
     * The start-id defines, from which bundle id the pipeline should start to extract the data (Comma separated)
     */
    startIds: string;
    /**
     * URL to the KYVE Chain API.
     */
    urlBase?: string;
}

export interface SourceLaunchdarklyConfiguration {
    /**
     * Your Access token. See \n\nhere\n\n.
     */
    accessToken: string;
    /**
     * must be one of ["launchdarkly"]
     */
    sourceType: string;
}

export interface SourceLemlistConfiguration {
    /**
     * Lemlist API key.
     */
    apiKey: string;
    /**
     * must be one of ["lemlist"]
     */
    sourceType: string;
}

export interface SourceLeverHiringConfiguration {
    /**
     * Choose how to authenticate to Lever Hiring.
     */
    credentials?: outputs.SourceLeverHiringConfigurationCredentials;
    /**
     * must be one of ["Production", "Sandbox"]
     * The environment in which you'd like to replicate data for Lever. This is used to determine which Lever API endpoint to use.
     */
    environment?: string;
    /**
     * must be one of ["lever-hiring"]
     */
    sourceType: string;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated. Note that it will be used only in the following incremental streams: comments, commits, and issues.
     */
    startDate: string;
}

export interface SourceLeverHiringConfigurationCredentials {
    sourceLeverHiringAuthenticationMechanismAuthenticateViaLeverApiKey?: outputs.SourceLeverHiringConfigurationCredentialsSourceLeverHiringAuthenticationMechanismAuthenticateViaLeverApiKey;
    sourceLeverHiringAuthenticationMechanismAuthenticateViaLeverOAuth?: outputs.SourceLeverHiringConfigurationCredentialsSourceLeverHiringAuthenticationMechanismAuthenticateViaLeverOAuth;
    sourceLeverHiringUpdateAuthenticationMechanismAuthenticateViaLeverApiKey?: outputs.SourceLeverHiringConfigurationCredentialsSourceLeverHiringUpdateAuthenticationMechanismAuthenticateViaLeverApiKey;
    sourceLeverHiringUpdateAuthenticationMechanismAuthenticateViaLeverOAuth?: outputs.SourceLeverHiringConfigurationCredentialsSourceLeverHiringUpdateAuthenticationMechanismAuthenticateViaLeverOAuth;
}

export interface SourceLeverHiringConfigurationCredentialsSourceLeverHiringAuthenticationMechanismAuthenticateViaLeverApiKey {
    apiKey: string;
    authType?: string;
}

export interface SourceLeverHiringConfigurationCredentialsSourceLeverHiringAuthenticationMechanismAuthenticateViaLeverOAuth {
    authType?: string;
    clientId?: string;
    clientSecret?: string;
    refreshToken: string;
}

export interface SourceLeverHiringConfigurationCredentialsSourceLeverHiringUpdateAuthenticationMechanismAuthenticateViaLeverApiKey {
    apiKey: string;
    authType?: string;
}

export interface SourceLeverHiringConfigurationCredentialsSourceLeverHiringUpdateAuthenticationMechanismAuthenticateViaLeverOAuth {
    authType?: string;
    clientId?: string;
    clientSecret?: string;
    refreshToken: string;
}

export interface SourceLinkedinAdsConfiguration {
    /**
     * Specify the account IDs separated by a space, to pull the data from. Leave empty, if you want to pull the data from all associated accounts. See the \n\nLinkedIn Ads docs\n\n for more info.
     */
    accountIds?: number[];
    adAnalyticsReports?: outputs.SourceLinkedinAdsConfigurationAdAnalyticsReport[];
    credentials?: outputs.SourceLinkedinAdsConfigurationCredentials;
    /**
     * must be one of ["linkedin-ads"]
     */
    sourceType: string;
    /**
     * UTC date in the format 2020-09-17. Any data before this date will not be replicated.
     */
    startDate: string;
}

export interface SourceLinkedinAdsConfigurationAdAnalyticsReport {
    name: string;
    pivotBy: string;
    timeGranularity: string;
}

export interface SourceLinkedinAdsConfigurationCredentials {
    sourceLinkedinAdsAuthenticationAccessToken?: outputs.SourceLinkedinAdsConfigurationCredentialsSourceLinkedinAdsAuthenticationAccessToken;
    sourceLinkedinAdsAuthenticationOAuth20?: outputs.SourceLinkedinAdsConfigurationCredentialsSourceLinkedinAdsAuthenticationOAuth20;
    sourceLinkedinAdsUpdateAuthenticationAccessToken?: outputs.SourceLinkedinAdsConfigurationCredentialsSourceLinkedinAdsUpdateAuthenticationAccessToken;
    sourceLinkedinAdsUpdateAuthenticationOAuth20?: outputs.SourceLinkedinAdsConfigurationCredentialsSourceLinkedinAdsUpdateAuthenticationOAuth20;
}

export interface SourceLinkedinAdsConfigurationCredentialsSourceLinkedinAdsAuthenticationAccessToken {
    accessToken: string;
    authMethod?: string;
}

export interface SourceLinkedinAdsConfigurationCredentialsSourceLinkedinAdsAuthenticationOAuth20 {
    authMethod?: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
}

export interface SourceLinkedinAdsConfigurationCredentialsSourceLinkedinAdsUpdateAuthenticationAccessToken {
    accessToken: string;
    authMethod?: string;
}

export interface SourceLinkedinAdsConfigurationCredentialsSourceLinkedinAdsUpdateAuthenticationOAuth20 {
    authMethod?: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
}

export interface SourceLinkedinPagesConfiguration {
    credentials?: outputs.SourceLinkedinPagesConfigurationCredentials;
    /**
     * Specify the Organization ID
     */
    orgId: string;
    /**
     * must be one of ["linkedin-pages"]
     */
    sourceType: string;
}

export interface SourceLinkedinPagesConfigurationCredentials {
    sourceLinkedinPagesAuthenticationAccessToken?: outputs.SourceLinkedinPagesConfigurationCredentialsSourceLinkedinPagesAuthenticationAccessToken;
    sourceLinkedinPagesAuthenticationOAuth20?: outputs.SourceLinkedinPagesConfigurationCredentialsSourceLinkedinPagesAuthenticationOAuth20;
    sourceLinkedinPagesUpdateAuthenticationAccessToken?: outputs.SourceLinkedinPagesConfigurationCredentialsSourceLinkedinPagesUpdateAuthenticationAccessToken;
    sourceLinkedinPagesUpdateAuthenticationOAuth20?: outputs.SourceLinkedinPagesConfigurationCredentialsSourceLinkedinPagesUpdateAuthenticationOAuth20;
}

export interface SourceLinkedinPagesConfigurationCredentialsSourceLinkedinPagesAuthenticationAccessToken {
    accessToken: string;
    authMethod?: string;
}

export interface SourceLinkedinPagesConfigurationCredentialsSourceLinkedinPagesAuthenticationOAuth20 {
    authMethod?: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
}

export interface SourceLinkedinPagesConfigurationCredentialsSourceLinkedinPagesUpdateAuthenticationAccessToken {
    accessToken: string;
    authMethod?: string;
}

export interface SourceLinkedinPagesConfigurationCredentialsSourceLinkedinPagesUpdateAuthenticationOAuth20 {
    authMethod?: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
}

export interface SourceLinnworksConfiguration {
    /**
     * Linnworks Application ID
     */
    applicationId: string;
    /**
     * Linnworks Application Secret
     */
    applicationSecret: string;
    /**
     * must be one of ["linnworks"]
     */
    sourceType: string;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
     */
    startDate: string;
    token: string;
}

export interface SourceLokaliseConfiguration {
    /**
     * Lokalise API Key with read-access. Available at Profile settings > API tokens. See \n\nhere\n\n.
     */
    apiKey: string;
    /**
     * Lokalise project ID. Available at Project Settings > General.
     */
    projectId: string;
    /**
     * must be one of ["lokalise"]
     */
    sourceType: string;
}

export interface SourceMailchimpConfiguration {
    campaignId?: string;
    credentials?: outputs.SourceMailchimpConfigurationCredentials;
    /**
     * must be one of ["mailchimp"]
     */
    sourceType: string;
}

export interface SourceMailchimpConfigurationCredentials {
    sourceMailchimpAuthenticationApiKey?: outputs.SourceMailchimpConfigurationCredentialsSourceMailchimpAuthenticationApiKey;
    sourceMailchimpAuthenticationOAuth20?: outputs.SourceMailchimpConfigurationCredentialsSourceMailchimpAuthenticationOAuth20;
    sourceMailchimpUpdateAuthenticationApiKey?: outputs.SourceMailchimpConfigurationCredentialsSourceMailchimpUpdateAuthenticationApiKey;
    sourceMailchimpUpdateAuthenticationOAuth20?: outputs.SourceMailchimpConfigurationCredentialsSourceMailchimpUpdateAuthenticationOAuth20;
}

export interface SourceMailchimpConfigurationCredentialsSourceMailchimpAuthenticationApiKey {
    apikey: string;
    authType: string;
}

export interface SourceMailchimpConfigurationCredentialsSourceMailchimpAuthenticationOAuth20 {
    accessToken: string;
    authType: string;
    clientId?: string;
    clientSecret?: string;
}

export interface SourceMailchimpConfigurationCredentialsSourceMailchimpUpdateAuthenticationApiKey {
    apikey: string;
    authType: string;
}

export interface SourceMailchimpConfigurationCredentialsSourceMailchimpUpdateAuthenticationOAuth20 {
    accessToken: string;
    authType: string;
    clientId?: string;
    clientSecret?: string;
}

export interface SourceMailgunConfiguration {
    /**
     * Domain region code. 'EU' or 'US' are possible values. The default is 'US'.
     */
    domainRegion?: string;
    /**
     * Primary account API key to access your Mailgun data.
     */
    privateKey: string;
    /**
     * must be one of ["mailgun"]
     */
    sourceType: string;
    /**
     * UTC date and time in the format 2020-10-01 00:00:00. Any data before this date will not be replicated. If omitted, defaults to 3 days ago.
     */
    startDate?: string;
}

export interface SourceMailjetSmsConfiguration {
    /**
     * Retrieve SMS messages created before the specified timestamp. Required format - Unix timestamp.
     */
    endDate?: number;
    /**
     * must be one of ["mailjet-sms"]
     */
    sourceType: string;
    /**
     * Retrieve SMS messages created after the specified timestamp. Required format - Unix timestamp.
     */
    startDate?: number;
    /**
     * Your access token. See \n\nhere\n\n.
     */
    token: string;
}

export interface SourceMarketoConfiguration {
    /**
     * The Client ID of your Marketo developer application. See \n\n the docs \n\n for info on how to obtain this.
     */
    clientId: string;
    /**
     * The Client Secret of your Marketo developer application. See \n\n the docs \n\n for info on how to obtain this.
     */
    clientSecret: string;
    /**
     * Your Marketo Base URL. See \n\n the docs \n\n for info on how to obtain this.
     */
    domainUrl: string;
    /**
     * must be one of ["marketo"]
     */
    sourceType: string;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
     */
    startDate: string;
}

export interface SourceMetabaseConfiguration {
    /**
     * URL to your metabase instance API
     */
    instanceApiUrl: string;
    password?: string;
    /**
     * To generate your session token, you need to run the following command: `curl -X POST \
     * -H "Content-Type: application/json" \
     * -d '{"username": "person@metabase.com", "password": "fakepassword"}' \
     * http://localhost:3000/api/session
     * ` Then copy the value of the `id` field returned by a successful call to that API.
     * Note that by default, sessions are good for 14 days and needs to be regenerated.
     */
    sessionToken?: string;
    /**
     * must be one of ["metabase"]
     */
    sourceType: string;
    username?: string;
}

export interface SourceMicrosoftTeamsConfiguration {
    /**
     * Choose how to authenticate to Microsoft
     */
    credentials?: outputs.SourceMicrosoftTeamsConfigurationCredentials;
    /**
     * Specifies the length of time over which the Team Device Report stream is aggregated. The supported values are: D7, D30, D90, and D180.
     */
    period: string;
    /**
     * must be one of ["microsoft-teams"]
     */
    sourceType: string;
}

export interface SourceMicrosoftTeamsConfigurationCredentials {
    sourceMicrosoftTeamsAuthenticationMechanismAuthenticateViaMicrosoft?: outputs.SourceMicrosoftTeamsConfigurationCredentialsSourceMicrosoftTeamsAuthenticationMechanismAuthenticateViaMicrosoft;
    sourceMicrosoftTeamsAuthenticationMechanismAuthenticateViaMicrosoftOAuth20?: outputs.SourceMicrosoftTeamsConfigurationCredentialsSourceMicrosoftTeamsAuthenticationMechanismAuthenticateViaMicrosoftOAuth20;
    sourceMicrosoftTeamsUpdateAuthenticationMechanismAuthenticateViaMicrosoft?: outputs.SourceMicrosoftTeamsConfigurationCredentialsSourceMicrosoftTeamsUpdateAuthenticationMechanismAuthenticateViaMicrosoft;
    sourceMicrosoftTeamsUpdateAuthenticationMechanismAuthenticateViaMicrosoftOAuth20?: outputs.SourceMicrosoftTeamsConfigurationCredentialsSourceMicrosoftTeamsUpdateAuthenticationMechanismAuthenticateViaMicrosoftOAuth20;
}

export interface SourceMicrosoftTeamsConfigurationCredentialsSourceMicrosoftTeamsAuthenticationMechanismAuthenticateViaMicrosoft {
    authType?: string;
    clientId: string;
    clientSecret: string;
    tenantId: string;
}

export interface SourceMicrosoftTeamsConfigurationCredentialsSourceMicrosoftTeamsAuthenticationMechanismAuthenticateViaMicrosoftOAuth20 {
    authType?: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
    tenantId: string;
}

export interface SourceMicrosoftTeamsConfigurationCredentialsSourceMicrosoftTeamsUpdateAuthenticationMechanismAuthenticateViaMicrosoft {
    authType?: string;
    clientId: string;
    clientSecret: string;
    tenantId: string;
}

export interface SourceMicrosoftTeamsConfigurationCredentialsSourceMicrosoftTeamsUpdateAuthenticationMechanismAuthenticateViaMicrosoftOAuth20 {
    authType?: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
    tenantId: string;
}

export interface SourceMixpanelConfiguration {
    /**
     * A period of time for attributing results to ads and the lookback period after those actions occur during which ad results are counted. Default attribution window is 5 days.
     */
    attributionWindow?: number;
    /**
     * Choose how to authenticate to Mixpanel
     */
    credentials?: outputs.SourceMixpanelConfigurationCredentials;
    /**
     * Defines window size in days, that used to slice through data. You can reduce it, if amount of data in each window is too big for your environment.
     */
    dateWindowSize?: number;
    /**
     * The date in the format YYYY-MM-DD. Any data after this date will not be replicated. Left empty to always sync to most recent date
     */
    endDate?: string;
    /**
     * Your project ID number. See the \n\ndocs\n\n for more information on how to obtain this.
     */
    projectId?: number;
    /**
     * Time zone in which integer date times are stored. The project timezone may be found in the project settings in the \n\nMixpanel console\n\n.
     */
    projectTimezone?: string;
    /**
     * must be one of ["US", "EU"]
     * The region of mixpanel domain instance either US or EU.
     */
    region?: string;
    /**
     * Setting this config parameter to TRUE ensures that new properties on events and engage records are captured. Otherwise new properties will be ignored.
     */
    selectPropertiesByDefault?: boolean;
    /**
     * must be one of ["mixpanel"]
     */
    sourceType?: string;
    /**
     * The date in the format YYYY-MM-DD. Any data before this date will not be replicated. If this option is not set, the connector will replicate data from up to one year ago by default.
     */
    startDate?: string;
}

export interface SourceMixpanelConfigurationCredentials {
    sourceMixpanelAuthenticationWildcardProjectSecret?: outputs.SourceMixpanelConfigurationCredentialsSourceMixpanelAuthenticationWildcardProjectSecret;
    sourceMixpanelAuthenticationWildcardServiceAccount?: outputs.SourceMixpanelConfigurationCredentialsSourceMixpanelAuthenticationWildcardServiceAccount;
    sourceMixpanelUpdateAuthenticationWildcardProjectSecret?: outputs.SourceMixpanelConfigurationCredentialsSourceMixpanelUpdateAuthenticationWildcardProjectSecret;
    sourceMixpanelUpdateAuthenticationWildcardServiceAccount?: outputs.SourceMixpanelConfigurationCredentialsSourceMixpanelUpdateAuthenticationWildcardServiceAccount;
}

export interface SourceMixpanelConfigurationCredentialsSourceMixpanelAuthenticationWildcardProjectSecret {
    apiSecret: string;
    optionTitle?: string;
}

export interface SourceMixpanelConfigurationCredentialsSourceMixpanelAuthenticationWildcardServiceAccount {
    optionTitle?: string;
    secret: string;
    username: string;
}

export interface SourceMixpanelConfigurationCredentialsSourceMixpanelUpdateAuthenticationWildcardProjectSecret {
    apiSecret: string;
    optionTitle?: string;
}

export interface SourceMixpanelConfigurationCredentialsSourceMixpanelUpdateAuthenticationWildcardServiceAccount {
    optionTitle?: string;
    secret: string;
    username: string;
}

export interface SourceMondayConfiguration {
    credentials?: outputs.SourceMondayConfigurationCredentials;
    /**
     * must be one of ["monday"]
     */
    sourceType: string;
}

export interface SourceMondayConfigurationCredentials {
    sourceMondayAuthorizationMethodApiToken?: outputs.SourceMondayConfigurationCredentialsSourceMondayAuthorizationMethodApiToken;
    sourceMondayAuthorizationMethodOAuth20?: outputs.SourceMondayConfigurationCredentialsSourceMondayAuthorizationMethodOAuth20;
    sourceMondayUpdateAuthorizationMethodApiToken?: outputs.SourceMondayConfigurationCredentialsSourceMondayUpdateAuthorizationMethodApiToken;
    sourceMondayUpdateAuthorizationMethodOAuth20?: outputs.SourceMondayConfigurationCredentialsSourceMondayUpdateAuthorizationMethodOAuth20;
}

export interface SourceMondayConfigurationCredentialsSourceMondayAuthorizationMethodApiToken {
    apiToken: string;
    authType: string;
}

export interface SourceMondayConfigurationCredentialsSourceMondayAuthorizationMethodOAuth20 {
    accessToken: string;
    authType: string;
    clientId: string;
    clientSecret: string;
    subdomain?: string;
}

export interface SourceMondayConfigurationCredentialsSourceMondayUpdateAuthorizationMethodApiToken {
    apiToken: string;
    authType: string;
}

export interface SourceMondayConfigurationCredentialsSourceMondayUpdateAuthorizationMethodOAuth20 {
    accessToken: string;
    authType: string;
    clientId: string;
    clientSecret: string;
    subdomain?: string;
}

export interface SourceMongodbConfiguration {
    /**
     * The authentication source where the user information is stored.
     */
    authSource?: string;
    /**
     * The database you want to replicate.
     */
    database: string;
    /**
     * The MongoDb instance to connect to. For MongoDB Atlas and Replica Set TLS connection is used by default.
     */
    instanceType?: outputs.SourceMongodbConfigurationInstanceType;
    /**
     * The password associated with this username.
     */
    password?: string;
    /**
     * must be one of ["mongodb"]
     */
    sourceType: string;
    /**
     * The username which is used to access the database.
     */
    user?: string;
}

export interface SourceMongodbConfigurationInstanceType {
    sourceMongodbMongoDbInstanceTypeMongoDbAtlas?: outputs.SourceMongodbConfigurationInstanceTypeSourceMongodbMongoDbInstanceTypeMongoDbAtlas;
    sourceMongodbMongoDbInstanceTypeReplicaSet?: outputs.SourceMongodbConfigurationInstanceTypeSourceMongodbMongoDbInstanceTypeReplicaSet;
    sourceMongodbMongoDbInstanceTypeStandaloneMongoDbInstance?: outputs.SourceMongodbConfigurationInstanceTypeSourceMongodbMongoDbInstanceTypeStandaloneMongoDbInstance;
    sourceMongodbUpdateMongoDbInstanceTypeMongoDbAtlas?: outputs.SourceMongodbConfigurationInstanceTypeSourceMongodbUpdateMongoDbInstanceTypeMongoDbAtlas;
    sourceMongodbUpdateMongoDbInstanceTypeReplicaSet?: outputs.SourceMongodbConfigurationInstanceTypeSourceMongodbUpdateMongoDbInstanceTypeReplicaSet;
    sourceMongodbUpdateMongoDbInstanceTypeStandaloneMongoDbInstance?: outputs.SourceMongodbConfigurationInstanceTypeSourceMongodbUpdateMongoDbInstanceTypeStandaloneMongoDbInstance;
}

export interface SourceMongodbConfigurationInstanceTypeSourceMongodbMongoDbInstanceTypeMongoDbAtlas {
    additionalProperties?: string;
    clusterUrl: string;
    instance: string;
}

export interface SourceMongodbConfigurationInstanceTypeSourceMongodbMongoDbInstanceTypeReplicaSet {
    instance: string;
    replicaSet?: string;
    serverAddresses: string;
}

export interface SourceMongodbConfigurationInstanceTypeSourceMongodbMongoDbInstanceTypeStandaloneMongoDbInstance {
    host: string;
    instance: string;
    port: number;
}

export interface SourceMongodbConfigurationInstanceTypeSourceMongodbUpdateMongoDbInstanceTypeMongoDbAtlas {
    additionalProperties?: string;
    clusterUrl: string;
    instance: string;
}

export interface SourceMongodbConfigurationInstanceTypeSourceMongodbUpdateMongoDbInstanceTypeReplicaSet {
    instance: string;
    replicaSet?: string;
    serverAddresses: string;
}

export interface SourceMongodbConfigurationInstanceTypeSourceMongodbUpdateMongoDbInstanceTypeStandaloneMongoDbInstance {
    host: string;
    instance: string;
    port: number;
}

export interface SourceMongodbInternalPocConfiguration {
    /**
     * The authentication source where the user information is stored.
     */
    authSource?: string;
    /**
     * The connection string of the database that you want to replicate..
     */
    connectionString?: string;
    /**
     * The password associated with this username.
     */
    password?: string;
    /**
     * The name of the replica set to be replicated.
     */
    replicaSet?: string;
    /**
     * must be one of ["mongodb-internal-poc"]
     */
    sourceType: string;
    /**
     * The username which is used to access the database.
     */
    user?: string;
}

export interface SourceMssqlConfiguration {
    /**
     * The name of the database.
     */
    database: string;
    /**
     * The hostname of the database.
     */
    host: string;
    /**
     * Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
     */
    jdbcUrlParams?: string;
    /**
     * The password associated with the username.
     */
    password?: string;
    /**
     * The port of the database.
     */
    port: number;
    /**
     * The replication method used for extracting data from the database. STANDARD replication requires no setup on the DB side but will not be able to represent deletions incrementally. CDC uses {TBC} to detect inserts, updates, and deletes. This needs to be configured on the source database itself.
     */
    replicationMethod?: outputs.SourceMssqlConfigurationReplicationMethod;
    /**
     * The list of schemas to sync from. Defaults to user. Case sensitive.
     */
    schemas?: string[];
    /**
     * must be one of ["mssql"]
     */
    sourceType: string;
    /**
     * The encryption method which is used when communicating with the database.
     */
    sslMethod?: outputs.SourceMssqlConfigurationSslMethod;
    /**
     * Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
     */
    tunnelMethod?: outputs.SourceMssqlConfigurationTunnelMethod;
    /**
     * The username which is used to access the database.
     */
    username: string;
}

export interface SourceMssqlConfigurationReplicationMethod {
    sourceMssqlReplicationMethodLogicalReplicationCdc?: outputs.SourceMssqlConfigurationReplicationMethodSourceMssqlReplicationMethodLogicalReplicationCdc;
    sourceMssqlReplicationMethodStandard?: outputs.SourceMssqlConfigurationReplicationMethodSourceMssqlReplicationMethodStandard;
    sourceMssqlUpdateReplicationMethodLogicalReplicationCdc?: outputs.SourceMssqlConfigurationReplicationMethodSourceMssqlUpdateReplicationMethodLogicalReplicationCdc;
    sourceMssqlUpdateReplicationMethodStandard?: outputs.SourceMssqlConfigurationReplicationMethodSourceMssqlUpdateReplicationMethodStandard;
}

export interface SourceMssqlConfigurationReplicationMethodSourceMssqlReplicationMethodLogicalReplicationCdc {
    dataToSync?: string;
    initialWaitingSeconds?: number;
    method: string;
    snapshotIsolation?: string;
}

export interface SourceMssqlConfigurationReplicationMethodSourceMssqlReplicationMethodStandard {
    method: string;
}

export interface SourceMssqlConfigurationReplicationMethodSourceMssqlUpdateReplicationMethodLogicalReplicationCdc {
    dataToSync?: string;
    initialWaitingSeconds?: number;
    method: string;
    snapshotIsolation?: string;
}

export interface SourceMssqlConfigurationReplicationMethodSourceMssqlUpdateReplicationMethodStandard {
    method: string;
}

export interface SourceMssqlConfigurationSslMethod {
    sourceMssqlSslMethodEncryptedTrustServerCertificate?: outputs.SourceMssqlConfigurationSslMethodSourceMssqlSslMethodEncryptedTrustServerCertificate;
    sourceMssqlSslMethodEncryptedVerifyCertificate?: outputs.SourceMssqlConfigurationSslMethodSourceMssqlSslMethodEncryptedVerifyCertificate;
    sourceMssqlUpdateSslMethodEncryptedTrustServerCertificate?: outputs.SourceMssqlConfigurationSslMethodSourceMssqlUpdateSslMethodEncryptedTrustServerCertificate;
    sourceMssqlUpdateSslMethodEncryptedVerifyCertificate?: outputs.SourceMssqlConfigurationSslMethodSourceMssqlUpdateSslMethodEncryptedVerifyCertificate;
}

export interface SourceMssqlConfigurationSslMethodSourceMssqlSslMethodEncryptedTrustServerCertificate {
    sslMethod: string;
}

export interface SourceMssqlConfigurationSslMethodSourceMssqlSslMethodEncryptedVerifyCertificate {
    hostNameInCertificate?: string;
    sslMethod: string;
}

export interface SourceMssqlConfigurationSslMethodSourceMssqlUpdateSslMethodEncryptedTrustServerCertificate {
    sslMethod: string;
}

export interface SourceMssqlConfigurationSslMethodSourceMssqlUpdateSslMethodEncryptedVerifyCertificate {
    hostNameInCertificate?: string;
    sslMethod: string;
}

export interface SourceMssqlConfigurationTunnelMethod {
    sourceMssqlSshTunnelMethodNoTunnel?: outputs.SourceMssqlConfigurationTunnelMethodSourceMssqlSshTunnelMethodNoTunnel;
    sourceMssqlSshTunnelMethodPasswordAuthentication?: outputs.SourceMssqlConfigurationTunnelMethodSourceMssqlSshTunnelMethodPasswordAuthentication;
    sourceMssqlSshTunnelMethodSshKeyAuthentication?: outputs.SourceMssqlConfigurationTunnelMethodSourceMssqlSshTunnelMethodSshKeyAuthentication;
    sourceMssqlUpdateSshTunnelMethodNoTunnel?: outputs.SourceMssqlConfigurationTunnelMethodSourceMssqlUpdateSshTunnelMethodNoTunnel;
    sourceMssqlUpdateSshTunnelMethodPasswordAuthentication?: outputs.SourceMssqlConfigurationTunnelMethodSourceMssqlUpdateSshTunnelMethodPasswordAuthentication;
    sourceMssqlUpdateSshTunnelMethodSshKeyAuthentication?: outputs.SourceMssqlConfigurationTunnelMethodSourceMssqlUpdateSshTunnelMethodSshKeyAuthentication;
}

export interface SourceMssqlConfigurationTunnelMethodSourceMssqlSshTunnelMethodNoTunnel {
    tunnelMethod: string;
}

export interface SourceMssqlConfigurationTunnelMethodSourceMssqlSshTunnelMethodPasswordAuthentication {
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
    tunnelUserPassword: string;
}

export interface SourceMssqlConfigurationTunnelMethodSourceMssqlSshTunnelMethodSshKeyAuthentication {
    sshKey: string;
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
}

export interface SourceMssqlConfigurationTunnelMethodSourceMssqlUpdateSshTunnelMethodNoTunnel {
    tunnelMethod: string;
}

export interface SourceMssqlConfigurationTunnelMethodSourceMssqlUpdateSshTunnelMethodPasswordAuthentication {
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
    tunnelUserPassword: string;
}

export interface SourceMssqlConfigurationTunnelMethodSourceMssqlUpdateSshTunnelMethodSshKeyAuthentication {
    sshKey: string;
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
}

export interface SourceMyHoursConfiguration {
    /**
     * Your My Hours username
     */
    email: string;
    /**
     * Pagination size used for retrieving logs in days
     */
    logsBatchSize?: number;
    /**
     * The password associated to the username
     */
    password: string;
    /**
     * must be one of ["my-hours"]
     */
    sourceType: string;
    /**
     * Start date for collecting time logs
     */
    startDate: string;
}

export interface SourceMysqlConfiguration {
    /**
     * The database name.
     */
    database: string;
    /**
     * The host name of the database.
     */
    host: string;
    /**
     * Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3). For more information read about \n\nJDBC URL parameters\n\n.
     */
    jdbcUrlParams?: string;
    /**
     * The password associated with the username.
     */
    password?: string;
    /**
     * The port to connect to.
     */
    port: number;
    /**
     * Configures how data is extracted from the database.
     */
    replicationMethod: outputs.SourceMysqlConfigurationReplicationMethod;
    /**
     * must be one of ["mysql"]
     */
    sourceType: string;
    /**
     * SSL connection modes. Read more \n\n in the docs\n\n.
     */
    sslMode?: outputs.SourceMysqlConfigurationSslMode;
    /**
     * Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
     */
    tunnelMethod?: outputs.SourceMysqlConfigurationTunnelMethod;
    /**
     * The username which is used to access the database.
     */
    username: string;
}

export interface SourceMysqlConfigurationReplicationMethod {
    sourceMysqlUpdateMethodReadChangesUsingBinaryLogCdc?: outputs.SourceMysqlConfigurationReplicationMethodSourceMysqlUpdateMethodReadChangesUsingBinaryLogCdc;
    sourceMysqlUpdateMethodScanChangesWithUserDefinedCursor?: outputs.SourceMysqlConfigurationReplicationMethodSourceMysqlUpdateMethodScanChangesWithUserDefinedCursor;
    sourceMysqlUpdateUpdateMethodReadChangesUsingBinaryLogCdc?: outputs.SourceMysqlConfigurationReplicationMethodSourceMysqlUpdateUpdateMethodReadChangesUsingBinaryLogCdc;
    sourceMysqlUpdateUpdateMethodScanChangesWithUserDefinedCursor?: outputs.SourceMysqlConfigurationReplicationMethodSourceMysqlUpdateUpdateMethodScanChangesWithUserDefinedCursor;
}

export interface SourceMysqlConfigurationReplicationMethodSourceMysqlUpdateMethodReadChangesUsingBinaryLogCdc {
    initialWaitingSeconds?: number;
    method: string;
    serverTimeZone?: string;
}

export interface SourceMysqlConfigurationReplicationMethodSourceMysqlUpdateMethodScanChangesWithUserDefinedCursor {
    method: string;
}

export interface SourceMysqlConfigurationReplicationMethodSourceMysqlUpdateUpdateMethodReadChangesUsingBinaryLogCdc {
    initialWaitingSeconds?: number;
    method: string;
    serverTimeZone?: string;
}

export interface SourceMysqlConfigurationReplicationMethodSourceMysqlUpdateUpdateMethodScanChangesWithUserDefinedCursor {
    method: string;
}

export interface SourceMysqlConfigurationSslMode {
    sourceMysqlSslModesPreferred?: outputs.SourceMysqlConfigurationSslModeSourceMysqlSslModesPreferred;
    sourceMysqlSslModesRequired?: outputs.SourceMysqlConfigurationSslModeSourceMysqlSslModesRequired;
    sourceMysqlSslModesVerifyCa?: outputs.SourceMysqlConfigurationSslModeSourceMysqlSslModesVerifyCa;
    sourceMysqlSslModesVerifyIdentity?: outputs.SourceMysqlConfigurationSslModeSourceMysqlSslModesVerifyIdentity;
    sourceMysqlUpdateSslModesPreferred?: outputs.SourceMysqlConfigurationSslModeSourceMysqlUpdateSslModesPreferred;
    sourceMysqlUpdateSslModesRequired?: outputs.SourceMysqlConfigurationSslModeSourceMysqlUpdateSslModesRequired;
    sourceMysqlUpdateSslModesVerifyCa?: outputs.SourceMysqlConfigurationSslModeSourceMysqlUpdateSslModesVerifyCa;
    sourceMysqlUpdateSslModesVerifyIdentity?: outputs.SourceMysqlConfigurationSslModeSourceMysqlUpdateSslModesVerifyIdentity;
}

export interface SourceMysqlConfigurationSslModeSourceMysqlSslModesPreferred {
    mode: string;
}

export interface SourceMysqlConfigurationSslModeSourceMysqlSslModesRequired {
    mode: string;
}

export interface SourceMysqlConfigurationSslModeSourceMysqlSslModesVerifyCa {
    caCertificate: string;
    clientCertificate?: string;
    clientKey?: string;
    clientKeyPassword?: string;
    mode: string;
}

export interface SourceMysqlConfigurationSslModeSourceMysqlSslModesVerifyIdentity {
    caCertificate: string;
    clientCertificate?: string;
    clientKey?: string;
    clientKeyPassword?: string;
    mode: string;
}

export interface SourceMysqlConfigurationSslModeSourceMysqlUpdateSslModesPreferred {
    mode: string;
}

export interface SourceMysqlConfigurationSslModeSourceMysqlUpdateSslModesRequired {
    mode: string;
}

export interface SourceMysqlConfigurationSslModeSourceMysqlUpdateSslModesVerifyCa {
    caCertificate: string;
    clientCertificate?: string;
    clientKey?: string;
    clientKeyPassword?: string;
    mode: string;
}

export interface SourceMysqlConfigurationSslModeSourceMysqlUpdateSslModesVerifyIdentity {
    caCertificate: string;
    clientCertificate?: string;
    clientKey?: string;
    clientKeyPassword?: string;
    mode: string;
}

export interface SourceMysqlConfigurationTunnelMethod {
    sourceMysqlSshTunnelMethodNoTunnel?: outputs.SourceMysqlConfigurationTunnelMethodSourceMysqlSshTunnelMethodNoTunnel;
    sourceMysqlSshTunnelMethodPasswordAuthentication?: outputs.SourceMysqlConfigurationTunnelMethodSourceMysqlSshTunnelMethodPasswordAuthentication;
    sourceMysqlSshTunnelMethodSshKeyAuthentication?: outputs.SourceMysqlConfigurationTunnelMethodSourceMysqlSshTunnelMethodSshKeyAuthentication;
    sourceMysqlUpdateSshTunnelMethodNoTunnel?: outputs.SourceMysqlConfigurationTunnelMethodSourceMysqlUpdateSshTunnelMethodNoTunnel;
    sourceMysqlUpdateSshTunnelMethodPasswordAuthentication?: outputs.SourceMysqlConfigurationTunnelMethodSourceMysqlUpdateSshTunnelMethodPasswordAuthentication;
    sourceMysqlUpdateSshTunnelMethodSshKeyAuthentication?: outputs.SourceMysqlConfigurationTunnelMethodSourceMysqlUpdateSshTunnelMethodSshKeyAuthentication;
}

export interface SourceMysqlConfigurationTunnelMethodSourceMysqlSshTunnelMethodNoTunnel {
    tunnelMethod: string;
}

export interface SourceMysqlConfigurationTunnelMethodSourceMysqlSshTunnelMethodPasswordAuthentication {
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
    tunnelUserPassword: string;
}

export interface SourceMysqlConfigurationTunnelMethodSourceMysqlSshTunnelMethodSshKeyAuthentication {
    sshKey: string;
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
}

export interface SourceMysqlConfigurationTunnelMethodSourceMysqlUpdateSshTunnelMethodNoTunnel {
    tunnelMethod: string;
}

export interface SourceMysqlConfigurationTunnelMethodSourceMysqlUpdateSshTunnelMethodPasswordAuthentication {
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
    tunnelUserPassword: string;
}

export interface SourceMysqlConfigurationTunnelMethodSourceMysqlUpdateSshTunnelMethodSshKeyAuthentication {
    sshKey: string;
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
}

export interface SourceNetsuiteConfiguration {
    /**
     * Consumer key associated with your integration
     */
    consumerKey: string;
    /**
     * Consumer secret associated with your integration
     */
    consumerSecret: string;
    /**
     * The API names of the Netsuite objects you want to sync. Setting this speeds up the connection setup process by limiting the number of schemas that need to be retrieved from Netsuite.
     */
    objectTypes?: string[];
    /**
     * Netsuite realm e.g. 2344535, as for `production` or 2344535_SB1, as for the `sandbox`
     */
    realm: string;
    /**
     * must be one of ["netsuite"]
     */
    sourceType: string;
    /**
     * Starting point for your data replication, in format of "YYYY-MM-DDTHH:mm:ssZ"
     */
    startDatetime: string;
    /**
     * Access token key
     */
    tokenKey: string;
    /**
     * Access token secret
     */
    tokenSecret: string;
    /**
     * The amount of days used to query the data with date chunks. Set smaller value, if you have lots of data.
     */
    windowInDays?: number;
}

export interface SourceNotionConfiguration {
    /**
     * Pick an authentication method.
     */
    credentials?: outputs.SourceNotionConfigurationCredentials;
    /**
     * must be one of ["notion"]
     */
    sourceType: string;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00.000Z. Any data before this date will not be replicated.
     */
    startDate: string;
}

export interface SourceNotionConfigurationCredentials {
    sourceNotionAuthenticateUsingAccessToken?: outputs.SourceNotionConfigurationCredentialsSourceNotionAuthenticateUsingAccessToken;
    sourceNotionAuthenticateUsingOAuth20?: outputs.SourceNotionConfigurationCredentialsSourceNotionAuthenticateUsingOAuth20;
    sourceNotionUpdateAuthenticateUsingAccessToken?: outputs.SourceNotionConfigurationCredentialsSourceNotionUpdateAuthenticateUsingAccessToken;
    sourceNotionUpdateAuthenticateUsingOAuth20?: outputs.SourceNotionConfigurationCredentialsSourceNotionUpdateAuthenticateUsingOAuth20;
}

export interface SourceNotionConfigurationCredentialsSourceNotionAuthenticateUsingAccessToken {
    authType: string;
    token: string;
}

export interface SourceNotionConfigurationCredentialsSourceNotionAuthenticateUsingOAuth20 {
    accessToken: string;
    authType: string;
    clientId: string;
    clientSecret: string;
}

export interface SourceNotionConfigurationCredentialsSourceNotionUpdateAuthenticateUsingAccessToken {
    authType: string;
    token: string;
}

export interface SourceNotionConfigurationCredentialsSourceNotionUpdateAuthenticateUsingOAuth20 {
    accessToken: string;
    authType: string;
    clientId: string;
    clientSecret: string;
}

export interface SourceNytimesConfiguration {
    /**
     * API Key
     */
    apiKey: string;
    /**
     * End date to stop the article retrieval (format YYYY-MM)
     */
    endDate?: string;
    /**
     * must be one of ["1", "7", "30"]
     * Period of time (in days)
     */
    period: number;
    /**
     * must be one of ["facebook"]
     * Share Type
     */
    shareType?: string;
    /**
     * must be one of ["nytimes"]
     */
    sourceType: string;
    /**
     * Start date to begin the article retrieval (format YYYY-MM)
     */
    startDate: string;
}

export interface SourceOktaConfiguration {
    credentials?: outputs.SourceOktaConfigurationCredentials;
    /**
     * The Okta domain. See the \n\ndocs\n\n for instructions on how to find it.
     */
    domain?: string;
    /**
     * must be one of ["okta"]
     */
    sourceType: string;
    /**
     * UTC date and time in the format YYYY-MM-DDTHH:MM:SSZ. Any data before this date will not be replicated.
     */
    startDate?: string;
}

export interface SourceOktaConfigurationCredentials {
    sourceOktaAuthorizationMethodApiToken?: outputs.SourceOktaConfigurationCredentialsSourceOktaAuthorizationMethodApiToken;
    sourceOktaAuthorizationMethodOAuth20?: outputs.SourceOktaConfigurationCredentialsSourceOktaAuthorizationMethodOAuth20;
    sourceOktaUpdateAuthorizationMethodApiToken?: outputs.SourceOktaConfigurationCredentialsSourceOktaUpdateAuthorizationMethodApiToken;
    sourceOktaUpdateAuthorizationMethodOAuth20?: outputs.SourceOktaConfigurationCredentialsSourceOktaUpdateAuthorizationMethodOAuth20;
}

export interface SourceOktaConfigurationCredentialsSourceOktaAuthorizationMethodApiToken {
    apiToken: string;
    authType: string;
}

export interface SourceOktaConfigurationCredentialsSourceOktaAuthorizationMethodOAuth20 {
    authType: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
}

export interface SourceOktaConfigurationCredentialsSourceOktaUpdateAuthorizationMethodApiToken {
    apiToken: string;
    authType: string;
}

export interface SourceOktaConfigurationCredentialsSourceOktaUpdateAuthorizationMethodOAuth20 {
    authType: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
}

export interface SourceOmnisendConfiguration {
    /**
     * API Key
     */
    apiKey: string;
    /**
     * must be one of ["omnisend"]
     */
    sourceType: string;
}

export interface SourceOnesignalConfiguration {
    /**
     * Applications keys, see the \n\ndocs\n\n for more information on how to obtain this data
     */
    applications: outputs.SourceOnesignalConfigurationApplication[];
    /**
     * Comma-separated list of names and the value (sum/count) for the returned outcome data. See the \n\ndocs\n\n for more details
     */
    outcomeNames: string;
    /**
     * must be one of ["onesignal"]
     */
    sourceType: string;
    /**
     * The date from which you'd like to replicate data for OneSignal API, in the format YYYY-MM-DDT00:00:00Z. All data generated after this date will be replicated.
     */
    startDate: string;
    /**
     * OneSignal User Auth Key, see the \n\ndocs\n\n for more information on how to obtain this key.
     */
    userAuthKey: string;
}

export interface SourceOnesignalConfigurationApplication {
    appApiKey: string;
    appId: string;
    appName?: string;
}

export interface SourceOpenweatherConfiguration {
    /**
     * Your OpenWeather API Key. See \n\nhere\n\n. The key is case sensitive.
     */
    appid: string;
    /**
     * must be one of ["af", "al", "ar", "az", "bg", "ca", "cz", "da", "de", "el", "en", "eu", "fa", "fi", "fr", "gl", "he", "hi", "hr", "hu", "id", "it", "ja", "kr", "la", "lt", "mk", "no", "nl", "pl", "pt", "pt*br", "ro", "ru", "sv", "se", "sk", "sl", "sp", "es", "sr", "th", "tr", "ua", "uk", "vi", "zh*cn", "zhTw", "zu"]
     * You can use lang parameter to get the output in your language. The contents of the description field will be translated. See \n\nhere\n\n for the list of supported languages.
     */
    lang?: string;
    /**
     * Latitude for which you want to get weather condition from. (min -90, max 90)
     */
    lat: string;
    /**
     * Longitude for which you want to get weather condition from. (min -180, max 180)
     */
    lon: string;
    /**
     * must be one of ["openweather"]
     */
    sourceType: string;
    /**
     * must be one of ["standard", "metric", "imperial"]
     * Units of measurement. standard, metric and imperial units are available. If you do not use the units parameter, standard units will be applied by default.
     */
    units?: string;
}

export interface SourceOracleConfiguration {
    /**
     * Connect data that will be used for DB connection
     */
    connectionData?: outputs.SourceOracleConfigurationConnectionData;
    /**
     * The encryption method with is used when communicating with the database.
     */
    encryption: outputs.SourceOracleConfigurationEncryption;
    /**
     * Hostname of the database.
     */
    host: string;
    /**
     * Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
     */
    jdbcUrlParams?: string;
    /**
     * The password associated with the username.
     */
    password?: string;
    /**
     * Port of the database.
     * Oracle Corporations recommends the following port numbers:
     * 1521 - Default listening port for client connections to the listener.
     * 2484 - Recommended and officially registered listening port for client connections to the listener using TCP/IP with SSL
     */
    port: number;
    /**
     * The list of schemas to sync from. Defaults to user. Case sensitive.
     */
    schemas?: string[];
    /**
     * must be one of ["oracle"]
     */
    sourceType: string;
    /**
     * Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
     */
    tunnelMethod?: outputs.SourceOracleConfigurationTunnelMethod;
    /**
     * The username which is used to access the database.
     */
    username: string;
}

export interface SourceOracleConfigurationConnectionData {
    sourceOracleConnectByServiceName?: outputs.SourceOracleConfigurationConnectionDataSourceOracleConnectByServiceName;
    sourceOracleConnectBySystemIdSid?: outputs.SourceOracleConfigurationConnectionDataSourceOracleConnectBySystemIdSid;
    sourceOracleUpdateConnectByServiceName?: outputs.SourceOracleConfigurationConnectionDataSourceOracleUpdateConnectByServiceName;
    sourceOracleUpdateConnectBySystemIdSid?: outputs.SourceOracleConfigurationConnectionDataSourceOracleUpdateConnectBySystemIdSid;
}

export interface SourceOracleConfigurationConnectionDataSourceOracleConnectByServiceName {
    connectionType?: string;
    serviceName: string;
}

export interface SourceOracleConfigurationConnectionDataSourceOracleConnectBySystemIdSid {
    connectionType?: string;
    sid: string;
}

export interface SourceOracleConfigurationConnectionDataSourceOracleUpdateConnectByServiceName {
    connectionType?: string;
    serviceName: string;
}

export interface SourceOracleConfigurationConnectionDataSourceOracleUpdateConnectBySystemIdSid {
    connectionType?: string;
    sid: string;
}

export interface SourceOracleConfigurationEncryption {
    sourceOracleEncryptionNativeNetworkEncryptionNne?: outputs.SourceOracleConfigurationEncryptionSourceOracleEncryptionNativeNetworkEncryptionNne;
    sourceOracleEncryptionTlsEncryptedVerifyCertificate?: outputs.SourceOracleConfigurationEncryptionSourceOracleEncryptionTlsEncryptedVerifyCertificate;
    sourceOracleUpdateEncryptionNativeNetworkEncryptionNne?: outputs.SourceOracleConfigurationEncryptionSourceOracleUpdateEncryptionNativeNetworkEncryptionNne;
    sourceOracleUpdateEncryptionTlsEncryptedVerifyCertificate?: outputs.SourceOracleConfigurationEncryptionSourceOracleUpdateEncryptionTlsEncryptedVerifyCertificate;
}

export interface SourceOracleConfigurationEncryptionSourceOracleEncryptionNativeNetworkEncryptionNne {
    encryptionAlgorithm?: string;
    encryptionMethod: string;
}

export interface SourceOracleConfigurationEncryptionSourceOracleEncryptionTlsEncryptedVerifyCertificate {
    encryptionMethod: string;
    sslCertificate: string;
}

export interface SourceOracleConfigurationEncryptionSourceOracleUpdateEncryptionNativeNetworkEncryptionNne {
    encryptionAlgorithm?: string;
    encryptionMethod: string;
}

export interface SourceOracleConfigurationEncryptionSourceOracleUpdateEncryptionTlsEncryptedVerifyCertificate {
    encryptionMethod: string;
    sslCertificate: string;
}

export interface SourceOracleConfigurationTunnelMethod {
    sourceOracleSshTunnelMethodNoTunnel?: outputs.SourceOracleConfigurationTunnelMethodSourceOracleSshTunnelMethodNoTunnel;
    sourceOracleSshTunnelMethodPasswordAuthentication?: outputs.SourceOracleConfigurationTunnelMethodSourceOracleSshTunnelMethodPasswordAuthentication;
    sourceOracleSshTunnelMethodSshKeyAuthentication?: outputs.SourceOracleConfigurationTunnelMethodSourceOracleSshTunnelMethodSshKeyAuthentication;
    sourceOracleUpdateSshTunnelMethodNoTunnel?: outputs.SourceOracleConfigurationTunnelMethodSourceOracleUpdateSshTunnelMethodNoTunnel;
    sourceOracleUpdateSshTunnelMethodPasswordAuthentication?: outputs.SourceOracleConfigurationTunnelMethodSourceOracleUpdateSshTunnelMethodPasswordAuthentication;
    sourceOracleUpdateSshTunnelMethodSshKeyAuthentication?: outputs.SourceOracleConfigurationTunnelMethodSourceOracleUpdateSshTunnelMethodSshKeyAuthentication;
}

export interface SourceOracleConfigurationTunnelMethodSourceOracleSshTunnelMethodNoTunnel {
    tunnelMethod: string;
}

export interface SourceOracleConfigurationTunnelMethodSourceOracleSshTunnelMethodPasswordAuthentication {
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
    tunnelUserPassword: string;
}

export interface SourceOracleConfigurationTunnelMethodSourceOracleSshTunnelMethodSshKeyAuthentication {
    sshKey: string;
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
}

export interface SourceOracleConfigurationTunnelMethodSourceOracleUpdateSshTunnelMethodNoTunnel {
    tunnelMethod: string;
}

export interface SourceOracleConfigurationTunnelMethodSourceOracleUpdateSshTunnelMethodPasswordAuthentication {
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
    tunnelUserPassword: string;
}

export interface SourceOracleConfigurationTunnelMethodSourceOracleUpdateSshTunnelMethodSshKeyAuthentication {
    sshKey: string;
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
}

export interface SourceOrbConfiguration {
    /**
     * Orb API Key, issued from the Orb admin console.
     */
    apiKey: string;
    /**
     * When set to N, the connector will always refresh resources created within the past N days. By default, updated objects that are not newly created are not incrementally synced.
     */
    lookbackWindowDays?: number;
    /**
     * Property key names to extract from all events, in order to enrich ledger entries corresponding to an event deduction.
     */
    numericEventPropertiesKeys?: string[];
    /**
     * Orb Plan ID to filter subscriptions that should have usage fetched.
     */
    planId?: string;
    /**
     * must be one of ["orb"]
     */
    sourceType: string;
    /**
     * UTC date and time in the format 2022-03-01T00:00:00Z. Any data with createdAt before this data will not be synced. For Subscription Usage, this becomes the `timeframeStart` API parameter.
     */
    startDate: string;
    /**
     * Property key names to extract from all events, in order to enrich ledger entries corresponding to an event deduction.
     */
    stringEventPropertiesKeys?: string[];
    /**
     * Property key name to group subscription usage by.
     */
    subscriptionUsageGroupingKey?: string;
}

export interface SourceOrbitConfiguration {
    /**
     * Authorizes you to work with Orbit workspaces associated with the token.
     */
    apiToken: string;
    /**
     * must be one of ["orbit"]
     */
    sourceType: string;
    /**
     * Date in the format 2022-06-26. Only load members whose last activities are after this date.
     */
    startDate?: string;
    /**
     * The unique name of the workspace that your API token is associated with.
     */
    workspace: string;
}

export interface SourceOutbrainAmplifyConfiguration {
    /**
     * Credentials for making authenticated requests requires either username/password or access_token.
     */
    credentials: outputs.SourceOutbrainAmplifyConfigurationCredentials;
    /**
     * Date in the format YYYY-MM-DD.
     */
    endDate?: string;
    /**
     * must be one of ["country", "region", "subregion"]
     * The granularity used for geo location data in reports.
     */
    geoLocationBreakdown?: string;
    /**
     * must be one of ["daily", "weekly", "monthly"]
     * The granularity used for periodic data in reports. See \n\nthe docs\n\n.
     */
    reportGranularity?: string;
    /**
     * must be one of ["outbrain-amplify"]
     */
    sourceType: string;
    /**
     * Date in the format YYYY-MM-DD eg. 2017-01-25. Any data before this date will not be replicated.
     */
    startDate: string;
}

export interface SourceOutbrainAmplifyConfigurationCredentials {
    sourceOutbrainAmplifyAuthenticationMethodAccessToken?: outputs.SourceOutbrainAmplifyConfigurationCredentialsSourceOutbrainAmplifyAuthenticationMethodAccessToken;
    sourceOutbrainAmplifyAuthenticationMethodUsernamePassword?: outputs.SourceOutbrainAmplifyConfigurationCredentialsSourceOutbrainAmplifyAuthenticationMethodUsernamePassword;
    sourceOutbrainAmplifyUpdateAuthenticationMethodAccessToken?: outputs.SourceOutbrainAmplifyConfigurationCredentialsSourceOutbrainAmplifyUpdateAuthenticationMethodAccessToken;
    sourceOutbrainAmplifyUpdateAuthenticationMethodUsernamePassword?: outputs.SourceOutbrainAmplifyConfigurationCredentialsSourceOutbrainAmplifyUpdateAuthenticationMethodUsernamePassword;
}

export interface SourceOutbrainAmplifyConfigurationCredentialsSourceOutbrainAmplifyAuthenticationMethodAccessToken {
    accessToken: string;
    type: string;
}

export interface SourceOutbrainAmplifyConfigurationCredentialsSourceOutbrainAmplifyAuthenticationMethodUsernamePassword {
    password: string;
    type: string;
    username: string;
}

export interface SourceOutbrainAmplifyConfigurationCredentialsSourceOutbrainAmplifyUpdateAuthenticationMethodAccessToken {
    accessToken: string;
    type: string;
}

export interface SourceOutbrainAmplifyConfigurationCredentialsSourceOutbrainAmplifyUpdateAuthenticationMethodUsernamePassword {
    password: string;
    type: string;
    username: string;
}

export interface SourceOutreachConfiguration {
    /**
     * The Client ID of your Outreach developer application.
     */
    clientId: string;
    /**
     * The Client Secret of your Outreach developer application.
     */
    clientSecret: string;
    /**
     * A Redirect URI is the location where the authorization server sends the user once the app has been successfully authorized and granted an authorization code or access token.
     */
    redirectUri: string;
    /**
     * The token for obtaining the new access token.
     */
    refreshToken: string;
    /**
     * must be one of ["outreach"]
     */
    sourceType: string;
    /**
     * The date from which you'd like to replicate data for Outreach API, in the format YYYY-MM-DDT00:00:00Z. All data generated after this date will be replicated.
     */
    startDate: string;
}

export interface SourcePaypalTransactionConfiguration {
    /**
     * The Client ID of your Paypal developer application.
     */
    clientId: string;
    /**
     * The Client Secret of your Paypal developer application.
     */
    clientSecret: string;
    /**
     * Determines whether to use the sandbox or production environment.
     */
    isSandbox: boolean;
    /**
     * The key to refresh the expired access token.
     */
    refreshToken?: string;
    /**
     * must be one of ["paypal-transaction"]
     */
    sourceType: string;
    /**
     * Start Date for data extraction in \n\nISO format\n\n. Date must be in range from 3 years till 12 hrs before present time.
     */
    startDate: string;
}

export interface SourcePaystackConfiguration {
    /**
     * When set, the connector will always reload data from the past N days, where N is the value set here. This is useful if your data is updated after creation.
     */
    lookbackWindowDays?: number;
    /**
     * The Paystack API key (usually starts with 'sk*live*'; find yours \n\nhere\n\n).
     */
    secretKey: string;
    /**
     * must be one of ["paystack"]
     */
    sourceType: string;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
     */
    startDate: string;
}

export interface SourcePendoConfiguration {
    apiKey: string;
    /**
     * must be one of ["pendo"]
     */
    sourceType: string;
}

export interface SourcePersistiqConfiguration {
    /**
     * PersistIq API Key. See the \n\ndocs\n\n for more information on where to find that key.
     */
    apiKey: string;
    /**
     * must be one of ["persistiq"]
     */
    sourceType: string;
}

export interface SourcePexelsApiConfiguration {
    /**
     * API key is required to access pexels api, For getting your's goto https://www.pexels.com/api/documentation and create account for free.
     */
    apiKey: string;
    /**
     * Optional, Desired photo color. Supported colors red, orange, yellow, green, turquoise, blue, violet, pink, brown, black, gray, white or any hexidecimal color code.
     */
    color?: string;
    /**
     * Optional, The locale of the search you are performing. The current supported locales are 'en-US' 'pt-BR' 'es-ES' 'ca-ES' 'de-DE' 'it-IT' 'fr-FR' 'sv-SE' 'id-ID' 'pl-PL' 'ja-JP' 'zh-TW' 'zh-CN' 'ko-KR' 'th-TH' 'nl-NL' 'hu-HU' 'vi-VN' 'cs-CZ' 'da-DK' 'fi-FI' 'uk-UA' 'el-GR' 'ro-RO' 'nb-NO' 'sk-SK' 'tr-TR' 'ru-RU'.
     */
    locale?: string;
    /**
     * Optional, Desired photo orientation. The current supported orientations are landscape, portrait or square
     */
    orientation?: string;
    /**
     * Optional, the search query, Example Ocean, Tigers, Pears, etc.
     */
    query: string;
    /**
     * Optional, Minimum photo size. The current supported sizes are large(24MP), medium(12MP) or small(4MP).
     */
    size?: string;
    /**
     * must be one of ["pexels-api"]
     */
    sourceType: string;
}

export interface SourcePinterestConfiguration {
    credentials?: outputs.SourcePinterestConfigurationCredentials;
    /**
     * must be one of ["pinterest"]
     */
    sourceType: string;
    /**
     * A date in the format YYYY-MM-DD. If you have not set a date, it would be defaulted to latest allowed date by api (89 days from today).
     */
    startDate: string;
    /**
     * Entity statuses based off of campaigns, ad_groups, and ads. If you do not have a status set, it will be ignored completely.
     */
    statuses?: string[];
}

export interface SourcePinterestConfigurationCredentials {
    sourcePinterestAuthorizationMethodAccessToken?: outputs.SourcePinterestConfigurationCredentialsSourcePinterestAuthorizationMethodAccessToken;
    sourcePinterestAuthorizationMethodOAuth20?: outputs.SourcePinterestConfigurationCredentialsSourcePinterestAuthorizationMethodOAuth20;
    sourcePinterestUpdateAuthorizationMethodAccessToken?: outputs.SourcePinterestConfigurationCredentialsSourcePinterestUpdateAuthorizationMethodAccessToken;
    sourcePinterestUpdateAuthorizationMethodOAuth20?: outputs.SourcePinterestConfigurationCredentialsSourcePinterestUpdateAuthorizationMethodOAuth20;
}

export interface SourcePinterestConfigurationCredentialsSourcePinterestAuthorizationMethodAccessToken {
    accessToken: string;
    authMethod: string;
}

export interface SourcePinterestConfigurationCredentialsSourcePinterestAuthorizationMethodOAuth20 {
    authMethod: string;
    clientId?: string;
    clientSecret?: string;
    refreshToken: string;
}

export interface SourcePinterestConfigurationCredentialsSourcePinterestUpdateAuthorizationMethodAccessToken {
    accessToken: string;
    authMethod: string;
}

export interface SourcePinterestConfigurationCredentialsSourcePinterestUpdateAuthorizationMethodOAuth20 {
    authMethod: string;
    clientId?: string;
    clientSecret?: string;
    refreshToken: string;
}

export interface SourcePipedriveConfiguration {
    authorization?: outputs.SourcePipedriveConfigurationAuthorization;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated. When specified and not None, then stream will behave as incremental
     */
    replicationStartDate: string;
    /**
     * must be one of ["pipedrive"]
     */
    sourceType: string;
}

export interface SourcePipedriveConfigurationAuthorization {
    apiToken: string;
    authType: string;
}

export interface SourcePocketConfiguration {
    /**
     * The user's Pocket access token.
     */
    accessToken: string;
    /**
     * Your application's Consumer Key.
     */
    consumerKey: string;
    /**
     * must be one of ["article", "video", "image"]
     * Select the content type of the items to retrieve.
     */
    contentType?: string;
    /**
     * must be one of ["simple", "complete"]
     * Select the granularity of the information about each item.
     */
    detailType?: string;
    /**
     * Only return items from a particular `domain`.
     */
    domain?: string;
    /**
     * Retrieve only favorited items.
     */
    favorite?: boolean;
    /**
     * Only return items whose title or url contain the `search` string.
     */
    search?: string;
    /**
     * Only return items modified since the given timestamp.
     */
    since?: string;
    /**
     * must be one of ["newest", "oldest", "title", "site"]
     * Sort retrieved items by the given criteria.
     */
    sort?: string;
    /**
     * must be one of ["pocket"]
     */
    sourceType: string;
    /**
     * must be one of ["unread", "archive", "all"]
     * Select the state of the items to retrieve.
     */
    state?: string;
    /**
     * Return only items tagged with this tag name. Use *untagged* for retrieving only untagged items.
     */
    tag?: string;
}

export interface SourcePokeapiConfiguration {
    /**
     * Pokemon requested from the API.
     */
    pokemonName: string;
    /**
     * must be one of ["pokeapi"]
     */
    sourceType: string;
}

export interface SourcePolygonStockApiConfiguration {
    /**
     * Determines whether or not the results are adjusted for splits. By default, results are adjusted and set to true. Set this to false to get results that are NOT adjusted for splits.
     */
    adjusted?: string;
    /**
     * Your API ACCESS Key
     */
    apiKey: string;
    /**
     * The target date for the aggregate window.
     */
    endDate: string;
    /**
     * The target date for the aggregate window.
     */
    limit?: number;
    /**
     * The size of the timespan multiplier.
     */
    multiplier: number;
    /**
     * Sort the results by timestamp. asc will return results in ascending order (oldest at the top), desc will return results in descending order (newest at the top).
     */
    sort?: string;
    /**
     * must be one of ["polygon-stock-api"]
     */
    sourceType: string;
    /**
     * The beginning date for the aggregate window.
     */
    startDate: string;
    /**
     * The exchange symbol that this item is traded under.
     */
    stocksTicker: string;
    /**
     * The size of the time window.
     */
    timespan: string;
}

export interface SourcePostgresConfiguration {
    /**
     * Name of the database.
     */
    database: string;
    /**
     * Hostname of the database.
     */
    host: string;
    /**
     * Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (Eg. key1=value1&key2=value2&key3=value3). For more information read about \n\nJDBC URL parameters\n\n.
     */
    jdbcUrlParams?: string;
    /**
     * Password associated with the username.
     */
    password?: string;
    /**
     * Port of the database.
     */
    port: number;
    /**
     * Replication method for extracting data from the database.
     */
    replicationMethod?: outputs.SourcePostgresConfigurationReplicationMethod;
    /**
     * The list of schemas (case sensitive) to sync from. Defaults to public.
     */
    schemas?: string[];
    /**
     * must be one of ["postgres"]
     */
    sourceType: string;
    /**
     * SSL connection modes.
     * Read more \n\n in the docs\n\n.
     */
    sslMode?: outputs.SourcePostgresConfigurationSslMode;
    /**
     * Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
     */
    tunnelMethod?: outputs.SourcePostgresConfigurationTunnelMethod;
    /**
     * Username to access the database.
     */
    username: string;
}

export interface SourcePostgresConfigurationReplicationMethod {
    sourcePostgresReplicationMethodLogicalReplicationCdc?: outputs.SourcePostgresConfigurationReplicationMethodSourcePostgresReplicationMethodLogicalReplicationCdc;
    sourcePostgresReplicationMethodStandard?: outputs.SourcePostgresConfigurationReplicationMethodSourcePostgresReplicationMethodStandard;
    sourcePostgresReplicationMethodStandardXmin?: outputs.SourcePostgresConfigurationReplicationMethodSourcePostgresReplicationMethodStandardXmin;
    sourcePostgresUpdateReplicationMethodLogicalReplicationCdc?: outputs.SourcePostgresConfigurationReplicationMethodSourcePostgresUpdateReplicationMethodLogicalReplicationCdc;
    sourcePostgresUpdateReplicationMethodStandard?: outputs.SourcePostgresConfigurationReplicationMethodSourcePostgresUpdateReplicationMethodStandard;
    sourcePostgresUpdateReplicationMethodStandardXmin?: outputs.SourcePostgresConfigurationReplicationMethodSourcePostgresUpdateReplicationMethodStandardXmin;
}

export interface SourcePostgresConfigurationReplicationMethodSourcePostgresReplicationMethodLogicalReplicationCdc {
    additionalProperties?: string;
    initialWaitingSeconds?: number;
    lsnCommitBehaviour?: string;
    method: string;
    plugin?: string;
    publication: string;
    queueSize?: number;
    replicationSlot: string;
}

export interface SourcePostgresConfigurationReplicationMethodSourcePostgresReplicationMethodStandard {
    method: string;
}

export interface SourcePostgresConfigurationReplicationMethodSourcePostgresReplicationMethodStandardXmin {
    method: string;
}

export interface SourcePostgresConfigurationReplicationMethodSourcePostgresUpdateReplicationMethodLogicalReplicationCdc {
    additionalProperties?: string;
    initialWaitingSeconds?: number;
    lsnCommitBehaviour?: string;
    method: string;
    plugin?: string;
    publication: string;
    queueSize?: number;
    replicationSlot: string;
}

export interface SourcePostgresConfigurationReplicationMethodSourcePostgresUpdateReplicationMethodStandard {
    method: string;
}

export interface SourcePostgresConfigurationReplicationMethodSourcePostgresUpdateReplicationMethodStandardXmin {
    method: string;
}

export interface SourcePostgresConfigurationSslMode {
    sourcePostgresSslModesAllow?: outputs.SourcePostgresConfigurationSslModeSourcePostgresSslModesAllow;
    sourcePostgresSslModesDisable?: outputs.SourcePostgresConfigurationSslModeSourcePostgresSslModesDisable;
    sourcePostgresSslModesPrefer?: outputs.SourcePostgresConfigurationSslModeSourcePostgresSslModesPrefer;
    sourcePostgresSslModesRequire?: outputs.SourcePostgresConfigurationSslModeSourcePostgresSslModesRequire;
    sourcePostgresSslModesVerifyCa?: outputs.SourcePostgresConfigurationSslModeSourcePostgresSslModesVerifyCa;
    sourcePostgresSslModesVerifyFull?: outputs.SourcePostgresConfigurationSslModeSourcePostgresSslModesVerifyFull;
    sourcePostgresUpdateSslModesAllow?: outputs.SourcePostgresConfigurationSslModeSourcePostgresUpdateSslModesAllow;
    sourcePostgresUpdateSslModesDisable?: outputs.SourcePostgresConfigurationSslModeSourcePostgresUpdateSslModesDisable;
    sourcePostgresUpdateSslModesPrefer?: outputs.SourcePostgresConfigurationSslModeSourcePostgresUpdateSslModesPrefer;
    sourcePostgresUpdateSslModesRequire?: outputs.SourcePostgresConfigurationSslModeSourcePostgresUpdateSslModesRequire;
    sourcePostgresUpdateSslModesVerifyCa?: outputs.SourcePostgresConfigurationSslModeSourcePostgresUpdateSslModesVerifyCa;
    sourcePostgresUpdateSslModesVerifyFull?: outputs.SourcePostgresConfigurationSslModeSourcePostgresUpdateSslModesVerifyFull;
}

export interface SourcePostgresConfigurationSslModeSourcePostgresSslModesAllow {
    additionalProperties?: string;
    mode: string;
}

export interface SourcePostgresConfigurationSslModeSourcePostgresSslModesDisable {
    additionalProperties?: string;
    mode: string;
}

export interface SourcePostgresConfigurationSslModeSourcePostgresSslModesPrefer {
    additionalProperties?: string;
    mode: string;
}

export interface SourcePostgresConfigurationSslModeSourcePostgresSslModesRequire {
    additionalProperties?: string;
    mode: string;
}

export interface SourcePostgresConfigurationSslModeSourcePostgresSslModesVerifyCa {
    additionalProperties?: string;
    caCertificate: string;
    clientCertificate?: string;
    clientKey?: string;
    clientKeyPassword?: string;
    mode: string;
}

export interface SourcePostgresConfigurationSslModeSourcePostgresSslModesVerifyFull {
    additionalProperties?: string;
    caCertificate: string;
    clientCertificate?: string;
    clientKey?: string;
    clientKeyPassword?: string;
    mode: string;
}

export interface SourcePostgresConfigurationSslModeSourcePostgresUpdateSslModesAllow {
    additionalProperties?: string;
    mode: string;
}

export interface SourcePostgresConfigurationSslModeSourcePostgresUpdateSslModesDisable {
    additionalProperties?: string;
    mode: string;
}

export interface SourcePostgresConfigurationSslModeSourcePostgresUpdateSslModesPrefer {
    additionalProperties?: string;
    mode: string;
}

export interface SourcePostgresConfigurationSslModeSourcePostgresUpdateSslModesRequire {
    additionalProperties?: string;
    mode: string;
}

export interface SourcePostgresConfigurationSslModeSourcePostgresUpdateSslModesVerifyCa {
    additionalProperties?: string;
    caCertificate: string;
    clientCertificate?: string;
    clientKey?: string;
    clientKeyPassword?: string;
    mode: string;
}

export interface SourcePostgresConfigurationSslModeSourcePostgresUpdateSslModesVerifyFull {
    additionalProperties?: string;
    caCertificate: string;
    clientCertificate?: string;
    clientKey?: string;
    clientKeyPassword?: string;
    mode: string;
}

export interface SourcePostgresConfigurationTunnelMethod {
    sourcePostgresSshTunnelMethodNoTunnel?: outputs.SourcePostgresConfigurationTunnelMethodSourcePostgresSshTunnelMethodNoTunnel;
    sourcePostgresSshTunnelMethodPasswordAuthentication?: outputs.SourcePostgresConfigurationTunnelMethodSourcePostgresSshTunnelMethodPasswordAuthentication;
    sourcePostgresSshTunnelMethodSshKeyAuthentication?: outputs.SourcePostgresConfigurationTunnelMethodSourcePostgresSshTunnelMethodSshKeyAuthentication;
    sourcePostgresUpdateSshTunnelMethodNoTunnel?: outputs.SourcePostgresConfigurationTunnelMethodSourcePostgresUpdateSshTunnelMethodNoTunnel;
    sourcePostgresUpdateSshTunnelMethodPasswordAuthentication?: outputs.SourcePostgresConfigurationTunnelMethodSourcePostgresUpdateSshTunnelMethodPasswordAuthentication;
    sourcePostgresUpdateSshTunnelMethodSshKeyAuthentication?: outputs.SourcePostgresConfigurationTunnelMethodSourcePostgresUpdateSshTunnelMethodSshKeyAuthentication;
}

export interface SourcePostgresConfigurationTunnelMethodSourcePostgresSshTunnelMethodNoTunnel {
    tunnelMethod: string;
}

export interface SourcePostgresConfigurationTunnelMethodSourcePostgresSshTunnelMethodPasswordAuthentication {
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
    tunnelUserPassword: string;
}

export interface SourcePostgresConfigurationTunnelMethodSourcePostgresSshTunnelMethodSshKeyAuthentication {
    sshKey: string;
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
}

export interface SourcePostgresConfigurationTunnelMethodSourcePostgresUpdateSshTunnelMethodNoTunnel {
    tunnelMethod: string;
}

export interface SourcePostgresConfigurationTunnelMethodSourcePostgresUpdateSshTunnelMethodPasswordAuthentication {
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
    tunnelUserPassword: string;
}

export interface SourcePostgresConfigurationTunnelMethodSourcePostgresUpdateSshTunnelMethodSshKeyAuthentication {
    sshKey: string;
    tunnelHost: string;
    tunnelMethod: string;
    tunnelPort: number;
    tunnelUser: string;
}

export interface SourcePosthogConfiguration {
    /**
     * API Key. See the \n\ndocs\n\n for information on how to generate this key.
     */
    apiKey: string;
    /**
     * Base PostHog url. Defaults to PostHog Cloud (https://app.posthog.com).
     */
    baseUrl?: string;
    /**
     * must be one of ["posthog"]
     */
    sourceType: string;
    /**
     * The date from which you'd like to replicate the data. Any data before this date will not be replicated.
     */
    startDate: string;
}

export interface SourcePostmarkappConfiguration {
    /**
     * must be one of ["postmarkapp"]
     */
    sourceType: string;
    /**
     * API Key for account
     */
    xPostmarkAccountToken: string;
    /**
     * API Key for server
     */
    xPostmarkServerToken: string;
}

export interface SourcePrestashopConfiguration {
    /**
     * Your PrestaShop access key. See \n\n the docs \n\n for info on how to obtain this.
     */
    accessKey: string;
    /**
     * must be one of ["prestashop"]
     */
    sourceType: string;
    /**
     * The Start date in the format YYYY-MM-DD.
     */
    startDate: string;
    /**
     * Shop URL without trailing slash.
     */
    url: string;
}

export interface SourcePublicApisConfiguration {
    /**
     * must be one of ["public-apis"]
     */
    sourceType: string;
}

export interface SourcePunkApiConfiguration {
    /**
     * To extract specific data with Unique ID
     */
    brewedAfter: string;
    /**
     * To extract specific data with Unique ID
     */
    brewedBefore: string;
    /**
     * To extract specific data with Unique ID
     */
    id?: string;
    /**
     * must be one of ["punk-api"]
     */
    sourceType: string;
}

export interface SourcePypiConfiguration {
    /**
     * Name of the project/package. Can only be in lowercase with hyphen. This is the name used using pip command for installing the package.
     */
    projectName: string;
    /**
     * must be one of ["pypi"]
     */
    sourceType: string;
    /**
     * Version of the project/package.  Use it to find a particular release instead of all releases.
     */
    version?: string;
}

export interface SourceQualarooConfiguration {
    /**
     * A Qualaroo token. See the \n\ndocs\n\n for instructions on how to generate it.
     */
    key: string;
    /**
     * must be one of ["qualaroo"]
     */
    sourceType: string;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
     */
    startDate: string;
    /**
     * IDs of the surveys from which you'd like to replicate data. If left empty, data from all surveys to which you have access will be replicated.
     */
    surveyIds?: string[];
    /**
     * A Qualaroo token. See the \n\ndocs\n\n for instructions on how to generate it.
     */
    token: string;
}

export interface SourceQuickbooksConfiguration {
    credentials: outputs.SourceQuickbooksConfigurationCredentials;
    /**
     * Determines whether to use the sandbox or production environment.
     */
    sandbox: boolean;
    /**
     * must be one of ["quickbooks"]
     */
    sourceType: string;
    /**
     * The default value to use if no bookmark exists for an endpoint (rfc3339 date string). E.g, 2021-03-20T00:00:00Z. Any data before this date will not be replicated.
     */
    startDate: string;
}

export interface SourceQuickbooksConfigurationCredentials {
    sourceQuickbooksAuthorizationMethodOAuth20?: outputs.SourceQuickbooksConfigurationCredentialsSourceQuickbooksAuthorizationMethodOAuth20;
    sourceQuickbooksUpdateAuthorizationMethodOAuth20?: outputs.SourceQuickbooksConfigurationCredentialsSourceQuickbooksUpdateAuthorizationMethodOAuth20;
}

export interface SourceQuickbooksConfigurationCredentialsSourceQuickbooksAuthorizationMethodOAuth20 {
    accessToken: string;
    authType?: string;
    clientId: string;
    clientSecret: string;
    realmId: string;
    refreshToken: string;
    tokenExpiryDate: string;
}

export interface SourceQuickbooksConfigurationCredentialsSourceQuickbooksUpdateAuthorizationMethodOAuth20 {
    accessToken: string;
    authType?: string;
    clientId: string;
    clientSecret: string;
    realmId: string;
    refreshToken: string;
    tokenExpiryDate: string;
}

export interface SourceRailzConfiguration {
    /**
     * Client ID (client_id)
     */
    clientId: string;
    /**
     * Secret key (secret_key)
     */
    secretKey: string;
    /**
     * must be one of ["railz"]
     */
    sourceType: string;
    /**
     * Start date
     */
    startDate: string;
}

export interface SourceRechargeConfiguration {
    /**
     * The value of the Access Token generated. See the \n\ndocs\n\n for more information.
     */
    accessToken: string;
    /**
     * must be one of ["recharge"]
     */
    sourceType: string;
    /**
     * The date from which you'd like to replicate data for Recharge API, in the format YYYY-MM-DDT00:00:00Z. Any data before this date will not be replicated.
     */
    startDate: string;
}

export interface SourceRecreationConfiguration {
    /**
     * API Key
     */
    apikey: string;
    queryCampsites?: string;
    /**
     * must be one of ["recreation"]
     */
    sourceType: string;
}

export interface SourceRecruiteeConfiguration {
    /**
     * Recruitee API Key. See \n\nhere\n\n.
     */
    apiKey: string;
    /**
     * Recruitee Company ID. You can also find this ID on the \n\nRecruitee API tokens page\n\n.
     */
    companyId: number;
    /**
     * must be one of ["recruitee"]
     */
    sourceType: string;
}

export interface SourceRecurlyConfiguration {
    /**
     * Recurly API Key. See the  \n\ndocs\n\n for more information on how to generate this key.
     */
    apiKey: string;
    /**
     * ISO8601 timestamp from which the replication from Recurly API will start from.
     */
    beginTime?: string;
    /**
     * ISO8601 timestamp to which the replication from Recurly API will stop. Records after that date won't be imported.
     */
    endTime?: string;
    /**
     * must be one of ["recurly"]
     */
    sourceType: string;
}

export interface SourceRedshiftConfiguration {
    /**
     * Name of the database.
     */
    database: string;
    /**
     * Host Endpoint of the Redshift Cluster (must include the cluster-id, region and end with .redshift.amazonaws.com).
     */
    host: string;
    /**
     * Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
     */
    jdbcUrlParams?: string;
    /**
     * Password associated with the username.
     */
    password: string;
    /**
     * Port of the database.
     */
    port: number;
    /**
     * The list of schemas to sync from. Specify one or more explicitly or keep empty to process all schemas. Schema names are case sensitive.
     */
    schemas?: string[];
    /**
     * must be one of ["redshift"]
     */
    sourceType: string;
    /**
     * Username to use to access the database.
     */
    username: string;
}

export interface SourceRetentlyConfiguration {
    /**
     * Choose how to authenticate to Retently
     */
    credentials?: outputs.SourceRetentlyConfigurationCredentials;
    /**
     * must be one of ["retently"]
     */
    sourceType?: string;
}

export interface SourceRetentlyConfigurationCredentials {
    sourceRetentlyAuthenticationMechanismAuthenticateViaRetentlyOAuth?: outputs.SourceRetentlyConfigurationCredentialsSourceRetentlyAuthenticationMechanismAuthenticateViaRetentlyOAuth;
    sourceRetentlyAuthenticationMechanismAuthenticateWithApiToken?: outputs.SourceRetentlyConfigurationCredentialsSourceRetentlyAuthenticationMechanismAuthenticateWithApiToken;
    sourceRetentlyUpdateAuthenticationMechanismAuthenticateViaRetentlyOAuth?: outputs.SourceRetentlyConfigurationCredentialsSourceRetentlyUpdateAuthenticationMechanismAuthenticateViaRetentlyOAuth;
    sourceRetentlyUpdateAuthenticationMechanismAuthenticateWithApiToken?: outputs.SourceRetentlyConfigurationCredentialsSourceRetentlyUpdateAuthenticationMechanismAuthenticateWithApiToken;
}

export interface SourceRetentlyConfigurationCredentialsSourceRetentlyAuthenticationMechanismAuthenticateViaRetentlyOAuth {
    additionalProperties?: string;
    authType?: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
}

export interface SourceRetentlyConfigurationCredentialsSourceRetentlyAuthenticationMechanismAuthenticateWithApiToken {
    additionalProperties?: string;
    apiKey: string;
    authType?: string;
}

export interface SourceRetentlyConfigurationCredentialsSourceRetentlyUpdateAuthenticationMechanismAuthenticateViaRetentlyOAuth {
    additionalProperties?: string;
    authType?: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
}

export interface SourceRetentlyConfigurationCredentialsSourceRetentlyUpdateAuthenticationMechanismAuthenticateWithApiToken {
    additionalProperties?: string;
    apiKey: string;
    authType?: string;
}

export interface SourceRkiCovidConfiguration {
    /**
     * must be one of ["rki-covid"]
     */
    sourceType: string;
    /**
     * UTC date in the format 2017-01-25. Any data before this date will not be replicated.
     */
    startDate: string;
}

export interface SourceRssConfiguration {
    /**
     * must be one of ["rss"]
     */
    sourceType: string;
    /**
     * RSS Feed URL
     */
    url: string;
}

export interface SourceS3Configuration {
    /**
     * The name of the stream you would like this source to output. Can contain letters, numbers, or underscores.
     */
    dataset: string;
    /**
     * The format of the files you'd like to replicate
     */
    format?: outputs.SourceS3ConfigurationFormat;
    /**
     * A regular expression which tells the connector which files to replicate. All files which match this pattern will be replicated. Use | to separate multiple patterns. See \n\nthis page\n\n to understand pattern syntax (GLOBSTAR and SPLIT flags are enabled). Use pattern \n\n**\n\n to pick up all files.
     */
    pathPattern: string;
    /**
     * Use this to load files from S3 or S3-compatible services
     */
    provider: outputs.SourceS3ConfigurationProvider;
    /**
     * Optionally provide a schema to enforce, as a valid JSON string. Ensure this is a mapping of \n\n{ "column" : "type" }\n\n, where types are valid \n\nJSON Schema datatypes\n\n. Leave as {} to auto-infer the schema.
     */
    schema?: string;
    /**
     * must be one of ["s3"]
     */
    sourceType: string;
}

export interface SourceS3ConfigurationFormat {
    sourceS3FileFormatAvro?: outputs.SourceS3ConfigurationFormatSourceS3FileFormatAvro;
    sourceS3FileFormatCsv?: outputs.SourceS3ConfigurationFormatSourceS3FileFormatCsv;
    sourceS3FileFormatJsonl?: outputs.SourceS3ConfigurationFormatSourceS3FileFormatJsonl;
    sourceS3FileFormatParquet?: outputs.SourceS3ConfigurationFormatSourceS3FileFormatParquet;
    sourceS3UpdateFileFormatAvro?: outputs.SourceS3ConfigurationFormatSourceS3UpdateFileFormatAvro;
    sourceS3UpdateFileFormatCsv?: outputs.SourceS3ConfigurationFormatSourceS3UpdateFileFormatCsv;
    sourceS3UpdateFileFormatJsonl?: outputs.SourceS3ConfigurationFormatSourceS3UpdateFileFormatJsonl;
    sourceS3UpdateFileFormatParquet?: outputs.SourceS3ConfigurationFormatSourceS3UpdateFileFormatParquet;
}

export interface SourceS3ConfigurationFormatSourceS3FileFormatAvro {
    filetype?: string;
}

export interface SourceS3ConfigurationFormatSourceS3FileFormatCsv {
    additionalReaderOptions?: string;
    advancedOptions?: string;
    blockSize?: number;
    delimiter?: string;
    doubleQuote?: boolean;
    encoding?: string;
    escapeChar?: string;
    filetype?: string;
    inferDatatypes?: boolean;
    newlinesInValues?: boolean;
    quoteChar?: string;
}

export interface SourceS3ConfigurationFormatSourceS3FileFormatJsonl {
    blockSize?: number;
    filetype?: string;
    newlinesInValues?: boolean;
    unexpectedFieldBehavior?: string;
}

export interface SourceS3ConfigurationFormatSourceS3FileFormatParquet {
    batchSize?: number;
    bufferSize?: number;
    columns?: string[];
    filetype?: string;
}

export interface SourceS3ConfigurationFormatSourceS3UpdateFileFormatAvro {
    filetype?: string;
}

export interface SourceS3ConfigurationFormatSourceS3UpdateFileFormatCsv {
    additionalReaderOptions?: string;
    advancedOptions?: string;
    blockSize?: number;
    delimiter?: string;
    doubleQuote?: boolean;
    encoding?: string;
    escapeChar?: string;
    filetype?: string;
    inferDatatypes?: boolean;
    newlinesInValues?: boolean;
    quoteChar?: string;
}

export interface SourceS3ConfigurationFormatSourceS3UpdateFileFormatJsonl {
    blockSize?: number;
    filetype?: string;
    newlinesInValues?: boolean;
    unexpectedFieldBehavior?: string;
}

export interface SourceS3ConfigurationFormatSourceS3UpdateFileFormatParquet {
    batchSize?: number;
    bufferSize?: number;
    columns?: string[];
    filetype?: string;
}

export interface SourceS3ConfigurationProvider {
    awsAccessKeyId?: string;
    awsSecretAccessKey?: string;
    bucket: string;
    endpoint?: string;
    pathPrefix?: string;
    startDate?: string;
}

export interface SourceSalesforceConfiguration {
    /**
     * must be one of ["Client"]
     */
    authType?: string;
    /**
     * Enter your Salesforce developer application's \n\nClient ID\n\n
     */
    clientId: string;
    /**
     * Enter your Salesforce developer application's \n\nClient secret\n\n
     */
    clientSecret: string;
    /**
     * Toggle to use Bulk API (this might cause empty fields for some streams)
     */
    forceUseBulkApi?: boolean;
    /**
     * Toggle if you're using a \n\nSalesforce Sandbox\n\n
     */
    isSandbox?: boolean;
    /**
     * Enter your application's \n\nSalesforce Refresh Token\n\n used for Airbyte to access your Salesforce account.
     */
    refreshToken: string;
    /**
     * must be one of ["salesforce"]
     */
    sourceType: string;
    /**
     * Enter the date (or date-time) in the YYYY-MM-DD or YYYY-MM-DDTHH:mm:ssZ format. Airbyte will replicate the data updated on and after this date. If this field is blank, Airbyte will replicate the data for last two years.
     */
    startDate?: string;
    /**
     * Add filters to select only required stream based on `SObject` name. Use this field to filter which tables are displayed by this connector. This is useful if your Salesforce account has a large number of tables (>1000), in which case you may find it easier to navigate the UI and speed up the connector's performance if you restrict the tables displayed by this connector.
     */
    streamsCriterias?: outputs.SourceSalesforceConfigurationStreamsCriteria[];
}

export interface SourceSalesforceConfigurationStreamsCriteria {
    criteria: string;
    value: string;
}

export interface SourceSalesloftConfiguration {
    credentials: outputs.SourceSalesloftConfigurationCredentials;
    /**
     * must be one of ["salesloft"]
     */
    sourceType: string;
    /**
     * The date from which you'd like to replicate data for Salesloft API, in the format YYYY-MM-DDT00:00:00Z. All data generated after this date will be replicated.
     */
    startDate: string;
}

export interface SourceSalesloftConfigurationCredentials {
    sourceSalesloftCredentialsAuthenticateViaApiKey?: outputs.SourceSalesloftConfigurationCredentialsSourceSalesloftCredentialsAuthenticateViaApiKey;
    sourceSalesloftCredentialsAuthenticateViaOAuth?: outputs.SourceSalesloftConfigurationCredentialsSourceSalesloftCredentialsAuthenticateViaOAuth;
    sourceSalesloftUpdateCredentialsAuthenticateViaApiKey?: outputs.SourceSalesloftConfigurationCredentialsSourceSalesloftUpdateCredentialsAuthenticateViaApiKey;
    sourceSalesloftUpdateCredentialsAuthenticateViaOAuth?: outputs.SourceSalesloftConfigurationCredentialsSourceSalesloftUpdateCredentialsAuthenticateViaOAuth;
}

export interface SourceSalesloftConfigurationCredentialsSourceSalesloftCredentialsAuthenticateViaApiKey {
    apiKey: string;
    authType: string;
}

export interface SourceSalesloftConfigurationCredentialsSourceSalesloftCredentialsAuthenticateViaOAuth {
    accessToken: string;
    authType: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
    tokenExpiryDate: string;
}

export interface SourceSalesloftConfigurationCredentialsSourceSalesloftUpdateCredentialsAuthenticateViaApiKey {
    apiKey: string;
    authType: string;
}

export interface SourceSalesloftConfigurationCredentialsSourceSalesloftUpdateCredentialsAuthenticateViaOAuth {
    accessToken: string;
    authType: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
    tokenExpiryDate: string;
}

export interface SourceSapFieldglassConfiguration {
    /**
     * API Key
     */
    apiKey: string;
    /**
     * must be one of ["sap-fieldglass"]
     */
    sourceType: string;
}

export interface SourceSecodaConfiguration {
    /**
     * Your API Access Key. See \n\nhere\n\n. The key is case sensitive.
     */
    apiKey: string;
    /**
     * must be one of ["secoda"]
     */
    sourceType: string;
}

export interface SourceSendgridConfiguration {
    /**
     * API Key, use \n\nadmin\n\n to generate this key.
     */
    apikey: string;
    /**
     * must be one of ["sendgrid"]
     */
    sourceType: string;
    /**
     * Start time in ISO8601 format. Any data before this time point will not be replicated.
     */
    startTime?: string;
}

export interface SourceSendinblueConfiguration {
    /**
     * Your API Key. See \n\nhere\n\n.
     */
    apiKey: string;
    /**
     * must be one of ["sendinblue"]
     */
    sourceType: string;
}

export interface SourceSenseforceConfiguration {
    /**
     * Your API access token. See \n\nhere\n\n. The toke is case sensitive.
     */
    accessToken: string;
    /**
     * Your Senseforce API backend URL. This is the URL shown during the Login screen. See \n\nhere\n\n for more details. (Note: Most Senseforce backend APIs have the term 'galaxy' in their ULR)
     */
    backendUrl: string;
    /**
     * The ID of the dataset you want to synchronize. The ID can be found in the URL when opening the dataset. See \n\nhere\n\n for more details. (Note: As the Senseforce API only allows to synchronize a specific dataset, each dataset you  want to synchronize needs to be implemented as a separate airbyte source).
     */
    datasetId: string;
    /**
     * The time increment used by the connector when requesting data from the Senseforce API. The bigger the value is, the less requests will be made and faster the sync will be. On the other hand, the more seldom the state is persisted and the more likely one could run into rate limites.  Furthermore, consider that large chunks of time might take a long time for the Senseforce query to return data - meaning it could take in effect longer than with more smaller time slices. If there are a lot of data per day, set this setting to 1. If there is only very little data per day, you might change the setting to 10 or more.
     */
    sliceRange?: number;
    /**
     * must be one of ["senseforce"]
     */
    sourceType: string;
    /**
     * UTC date and time in the format 2017-01-25. Only data with "Timestamp" after this date will be replicated. Important note: This start date must be set to the first day of where your dataset provides data.  If your dataset has data from 2020-10-10 10:21:10, set the startDate to 2020-10-10 or later
     */
    startDate: string;
}

export interface SourceSentryConfiguration {
    /**
     * Log into Sentry and then \n\ncreate authentication tokens\n\n.For self-hosted, you can find or create authentication tokens by visiting "{instance*url*prefix}/settings/account/api/auth-tokens/"
     */
    authToken: string;
    /**
     * Fields to retrieve when fetching discover events
     */
    discoverFields?: string[];
    /**
     * Host name of Sentry API server.For self-hosted, specify your host name here. Otherwise, leave it empty.
     */
    hostname?: string;
    /**
     * The slug of the organization the groups belong to.
     */
    organization: string;
    /**
     * The name (slug) of the Project you want to sync.
     */
    project: string;
    /**
     * must be one of ["sentry"]
     */
    sourceType: string;
}

export interface SourceSftpBulkConfiguration {
    /**
     * Sync only the most recent file for the configured folder path and file pattern
     */
    fileMostRecent?: boolean;
    /**
     * The regular expression to specify files for sync in a chosen Folder Path
     */
    filePattern?: string;
    /**
     * must be one of ["csv", "json"]
     * The file type you want to sync. Currently only 'csv' and 'json' files are supported.
     */
    fileType?: string;
    /**
     * The directory to search files for sync
     */
    folderPath: string;
    /**
     * The server host address
     */
    host: string;
    /**
     * OS-level password for logging into the jump server host
     */
    password?: string;
    /**
     * The server port
     */
    port: number;
    /**
     * The private key
     */
    privateKey?: string;
    /**
     * The separator used in the CSV files. Define None if you want to use the Sniffer functionality
     */
    separator?: string;
    /**
     * must be one of ["sftp-bulk"]
     */
    sourceType: string;
    /**
     * The date from which you'd like to replicate data for all incremental streams, in the format YYYY-MM-DDT00:00:00Z. All data generated after this date will be replicated.
     */
    startDate: string;
    /**
     * The name of the stream or table you want to create
     */
    streamName: string;
    /**
     * The server user
     */
    username: string;
}

export interface SourceSftpConfiguration {
    /**
     * The server authentication method
     */
    credentials?: outputs.SourceSftpConfigurationCredentials;
    /**
     * The regular expression to specify files for sync in a chosen Folder Path
     */
    filePattern?: string;
    /**
     * Coma separated file types. Currently only 'csv' and 'json' types are supported.
     */
    fileTypes?: string;
    /**
     * The directory to search files for sync
     */
    folderPath?: string;
    /**
     * The server host address
     */
    host: string;
    /**
     * The server port
     */
    port: number;
    /**
     * must be one of ["sftp"]
     */
    sourceType: string;
    /**
     * The server user
     */
    user: string;
}

export interface SourceSftpConfigurationCredentials {
    sourceSftpAuthenticationWildcardPasswordAuthentication?: outputs.SourceSftpConfigurationCredentialsSourceSftpAuthenticationWildcardPasswordAuthentication;
    sourceSftpAuthenticationWildcardSshKeyAuthentication?: outputs.SourceSftpConfigurationCredentialsSourceSftpAuthenticationWildcardSshKeyAuthentication;
    sourceSftpUpdateAuthenticationWildcardPasswordAuthentication?: outputs.SourceSftpConfigurationCredentialsSourceSftpUpdateAuthenticationWildcardPasswordAuthentication;
    sourceSftpUpdateAuthenticationWildcardSshKeyAuthentication?: outputs.SourceSftpConfigurationCredentialsSourceSftpUpdateAuthenticationWildcardSshKeyAuthentication;
}

export interface SourceSftpConfigurationCredentialsSourceSftpAuthenticationWildcardPasswordAuthentication {
    authMethod: string;
    authUserPassword: string;
}

export interface SourceSftpConfigurationCredentialsSourceSftpAuthenticationWildcardSshKeyAuthentication {
    authMethod: string;
    authSshKey: string;
}

export interface SourceSftpConfigurationCredentialsSourceSftpUpdateAuthenticationWildcardPasswordAuthentication {
    authMethod: string;
    authUserPassword: string;
}

export interface SourceSftpConfigurationCredentialsSourceSftpUpdateAuthenticationWildcardSshKeyAuthentication {
    authMethod: string;
    authSshKey: string;
}

export interface SourceShopifyConfiguration {
    /**
     * The authorization method to use to retrieve data from Shopify
     */
    credentials?: outputs.SourceShopifyConfigurationCredentials;
    /**
     * The name of your Shopify store found in the URL. For example, if your URL was https://NAME.myshopify.com, then the name would be 'NAME' or 'NAME.myshopify.com'.
     */
    shop: string;
    /**
     * must be one of ["shopify"]
     */
    sourceType: string;
    /**
     * The date you would like to replicate data from. Format: YYYY-MM-DD. Any data before this date will not be replicated.
     */
    startDate: string;
}

export interface SourceShopifyConfigurationCredentials {
    sourceShopifyShopifyAuthorizationMethodApiPassword?: outputs.SourceShopifyConfigurationCredentialsSourceShopifyShopifyAuthorizationMethodApiPassword;
    sourceShopifyShopifyAuthorizationMethodOAuth20?: outputs.SourceShopifyConfigurationCredentialsSourceShopifyShopifyAuthorizationMethodOAuth20;
    sourceShopifyUpdateShopifyAuthorizationMethodApiPassword?: outputs.SourceShopifyConfigurationCredentialsSourceShopifyUpdateShopifyAuthorizationMethodApiPassword;
    sourceShopifyUpdateShopifyAuthorizationMethodOAuth20?: outputs.SourceShopifyConfigurationCredentialsSourceShopifyUpdateShopifyAuthorizationMethodOAuth20;
}

export interface SourceShopifyConfigurationCredentialsSourceShopifyShopifyAuthorizationMethodApiPassword {
    apiPassword: string;
    authMethod: string;
}

export interface SourceShopifyConfigurationCredentialsSourceShopifyShopifyAuthorizationMethodOAuth20 {
    accessToken?: string;
    authMethod: string;
    clientId?: string;
    clientSecret?: string;
}

export interface SourceShopifyConfigurationCredentialsSourceShopifyUpdateShopifyAuthorizationMethodApiPassword {
    apiPassword: string;
    authMethod: string;
}

export interface SourceShopifyConfigurationCredentialsSourceShopifyUpdateShopifyAuthorizationMethodOAuth20 {
    accessToken?: string;
    authMethod: string;
    clientId?: string;
    clientSecret?: string;
}

export interface SourceShortioConfiguration {
    domainId: string;
    /**
     * Short.io Secret Key
     */
    secretKey: string;
    /**
     * must be one of ["shortio"]
     */
    sourceType: string;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
     */
    startDate: string;
}

export interface SourceSlackConfiguration {
    /**
     * A channel name list (without leading '#' char) which limit the channels from which you'd like to sync. Empty list means no filter.
     */
    channelFilters?: string[];
    /**
     * Choose how to authenticate into Slack
     */
    credentials?: outputs.SourceSlackConfigurationCredentials;
    /**
     * Whether to join all channels or to sync data only from channels the bot is already in.  If false, you'll need to manually add the bot to all the channels from which you'd like to sync messages.
     */
    joinChannels: boolean;
    /**
     * How far into the past to look for messages in threads, default is 0 days
     */
    lookbackWindow: number;
    /**
     * must be one of ["slack"]
     */
    sourceType: string;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
     */
    startDate: string;
}

export interface SourceSlackConfigurationCredentials {
    sourceSlackAuthenticationMechanismApiToken?: outputs.SourceSlackConfigurationCredentialsSourceSlackAuthenticationMechanismApiToken;
    sourceSlackAuthenticationMechanismSignInViaSlackOAuth?: outputs.SourceSlackConfigurationCredentialsSourceSlackAuthenticationMechanismSignInViaSlackOAuth;
    sourceSlackUpdateAuthenticationMechanismApiToken?: outputs.SourceSlackConfigurationCredentialsSourceSlackUpdateAuthenticationMechanismApiToken;
    sourceSlackUpdateAuthenticationMechanismSignInViaSlackOAuth?: outputs.SourceSlackConfigurationCredentialsSourceSlackUpdateAuthenticationMechanismSignInViaSlackOAuth;
}

export interface SourceSlackConfigurationCredentialsSourceSlackAuthenticationMechanismApiToken {
    apiToken: string;
    optionTitle: string;
}

export interface SourceSlackConfigurationCredentialsSourceSlackAuthenticationMechanismSignInViaSlackOAuth {
    accessToken: string;
    clientId: string;
    clientSecret: string;
    optionTitle: string;
}

export interface SourceSlackConfigurationCredentialsSourceSlackUpdateAuthenticationMechanismApiToken {
    apiToken: string;
    optionTitle: string;
}

export interface SourceSlackConfigurationCredentialsSourceSlackUpdateAuthenticationMechanismSignInViaSlackOAuth {
    accessToken: string;
    clientId: string;
    clientSecret: string;
    optionTitle: string;
}

export interface SourceSmailyConfiguration {
    /**
     * API user password. See https://smaily.com/help/api/general/create-api-user/
     */
    apiPassword: string;
    /**
     * API Subdomain. See https://smaily.com/help/api/general/create-api-user/
     */
    apiSubdomain: string;
    /**
     * API user username. See https://smaily.com/help/api/general/create-api-user/
     */
    apiUsername: string;
    /**
     * must be one of ["smaily"]
     */
    sourceType: string;
}

export interface SourceSmartengageConfiguration {
    /**
     * API Key
     */
    apiKey: string;
    /**
     * must be one of ["smartengage"]
     */
    sourceType: string;
}

export interface SourceSmartsheetsConfiguration {
    credentials: outputs.SourceSmartsheetsConfigurationCredentials;
    /**
     * A List of available columns which metadata can be pulled from.
     */
    metadataFields?: string[];
    /**
     * must be one of ["smartsheets"]
     */
    sourceType: string;
    /**
     * The spreadsheet ID. Find it by opening the spreadsheet then navigating to File > Properties
     */
    spreadsheetId: string;
    /**
     * Only rows modified after this date/time will be replicated. This should be an ISO 8601 string, for instance: `2000-01-01T13:00:00`
     */
    startDatetime?: string;
}

export interface SourceSmartsheetsConfigurationCredentials {
    sourceSmartsheetsAuthorizationMethodApiAccessToken?: outputs.SourceSmartsheetsConfigurationCredentialsSourceSmartsheetsAuthorizationMethodApiAccessToken;
    sourceSmartsheetsAuthorizationMethodOAuth20?: outputs.SourceSmartsheetsConfigurationCredentialsSourceSmartsheetsAuthorizationMethodOAuth20;
    sourceSmartsheetsUpdateAuthorizationMethodApiAccessToken?: outputs.SourceSmartsheetsConfigurationCredentialsSourceSmartsheetsUpdateAuthorizationMethodApiAccessToken;
    sourceSmartsheetsUpdateAuthorizationMethodOAuth20?: outputs.SourceSmartsheetsConfigurationCredentialsSourceSmartsheetsUpdateAuthorizationMethodOAuth20;
}

export interface SourceSmartsheetsConfigurationCredentialsSourceSmartsheetsAuthorizationMethodApiAccessToken {
    accessToken: string;
    authType?: string;
}

export interface SourceSmartsheetsConfigurationCredentialsSourceSmartsheetsAuthorizationMethodOAuth20 {
    accessToken: string;
    authType?: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
    tokenExpiryDate: string;
}

export interface SourceSmartsheetsConfigurationCredentialsSourceSmartsheetsUpdateAuthorizationMethodApiAccessToken {
    accessToken: string;
    authType?: string;
}

export interface SourceSmartsheetsConfigurationCredentialsSourceSmartsheetsUpdateAuthorizationMethodOAuth20 {
    accessToken: string;
    authType?: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
    tokenExpiryDate: string;
}

export interface SourceSnapchatMarketingConfiguration {
    /**
     * The Client ID of your Snapchat developer application.
     */
    clientId: string;
    /**
     * The Client Secret of your Snapchat developer application.
     */
    clientSecret: string;
    /**
     * Date in the format 2017-01-25. Any data after this date will not be replicated.
     */
    endDate?: string;
    /**
     * Refresh Token to renew the expired Access Token.
     */
    refreshToken: string;
    /**
     * must be one of ["snapchat-marketing"]
     */
    sourceType: string;
    /**
     * Date in the format 2022-01-01. Any data before this date will not be replicated.
     */
    startDate?: string;
}

export interface SourceSnowflakeConfiguration {
    credentials?: outputs.SourceSnowflakeConfigurationCredentials;
    /**
     * The database you created for Airbyte to access data.
     */
    database: string;
    /**
     * The host domain of the snowflake instance (must include the account, region, cloud environment, and end with snowflakecomputing.com).
     */
    host: string;
    /**
     * Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
     */
    jdbcUrlParams?: string;
    /**
     * The role you created for Airbyte to access Snowflake.
     */
    role: string;
    /**
     * The source Snowflake schema tables. Leave empty to access tables from multiple schemas.
     */
    schema?: string;
    /**
     * must be one of ["snowflake"]
     */
    sourceType: string;
    /**
     * The warehouse you created for Airbyte to access data.
     */
    warehouse: string;
}

export interface SourceSnowflakeConfigurationCredentials {
    sourceSnowflakeAuthorizationMethodOAuth20?: outputs.SourceSnowflakeConfigurationCredentialsSourceSnowflakeAuthorizationMethodOAuth20;
    sourceSnowflakeAuthorizationMethodUsernameAndPassword?: outputs.SourceSnowflakeConfigurationCredentialsSourceSnowflakeAuthorizationMethodUsernameAndPassword;
    sourceSnowflakeUpdateAuthorizationMethodOAuth20?: outputs.SourceSnowflakeConfigurationCredentialsSourceSnowflakeUpdateAuthorizationMethodOAuth20;
    sourceSnowflakeUpdateAuthorizationMethodUsernameAndPassword?: outputs.SourceSnowflakeConfigurationCredentialsSourceSnowflakeUpdateAuthorizationMethodUsernameAndPassword;
}

export interface SourceSnowflakeConfigurationCredentialsSourceSnowflakeAuthorizationMethodOAuth20 {
    accessToken?: string;
    authType: string;
    clientId: string;
    clientSecret: string;
    refreshToken?: string;
}

export interface SourceSnowflakeConfigurationCredentialsSourceSnowflakeAuthorizationMethodUsernameAndPassword {
    authType: string;
    password: string;
    username: string;
}

export interface SourceSnowflakeConfigurationCredentialsSourceSnowflakeUpdateAuthorizationMethodOAuth20 {
    accessToken?: string;
    authType: string;
    clientId: string;
    clientSecret: string;
    refreshToken?: string;
}

export interface SourceSnowflakeConfigurationCredentialsSourceSnowflakeUpdateAuthorizationMethodUsernameAndPassword {
    authType: string;
    password: string;
    username: string;
}

export interface SourceSonarCloudConfiguration {
    /**
     * Comma-separated list of component keys.
     */
    componentKeys: string[];
    /**
     * To retrieve issues created before the given date (inclusive).
     */
    endDate?: string;
    /**
     * Organization key. See \n\nhere\n\n.
     */
    organization: string;
    /**
     * must be one of ["sonar-cloud"]
     */
    sourceType: string;
    /**
     * To retrieve issues created after the given date (inclusive).
     */
    startDate?: string;
    /**
     * Your User Token. See \n\nhere\n\n. The token is case sensitive.
     */
    userToken: string;
}

export interface SourceSpaceXApiConfiguration {
    id?: string;
    options?: string;
    /**
     * must be one of ["spacex-api"]
     */
    sourceType?: string;
}

export interface SourceSquareConfiguration {
    /**
     * Choose how to authenticate to Square.
     */
    credentials?: outputs.SourceSquareConfigurationCredentials;
    /**
     * In some streams there is an option to include deleted objects (Items, Categories, Discounts, Taxes)
     */
    includeDeletedObjects?: boolean;
    /**
     * Determines whether to use the sandbox or production environment.
     */
    isSandbox: boolean;
    /**
     * must be one of ["square"]
     */
    sourceType: string;
    /**
     * UTC date in the format YYYY-MM-DD. Any data before this date will not be replicated. If not set, all data will be replicated.
     */
    startDate?: string;
}

export interface SourceSquareConfigurationCredentials {
    sourceSquareAuthenticationApiKey?: outputs.SourceSquareConfigurationCredentialsSourceSquareAuthenticationApiKey;
    sourceSquareAuthenticationOauthAuthentication?: outputs.SourceSquareConfigurationCredentialsSourceSquareAuthenticationOauthAuthentication;
    sourceSquareUpdateAuthenticationApiKey?: outputs.SourceSquareConfigurationCredentialsSourceSquareUpdateAuthenticationApiKey;
    sourceSquareUpdateAuthenticationOauthAuthentication?: outputs.SourceSquareConfigurationCredentialsSourceSquareUpdateAuthenticationOauthAuthentication;
}

export interface SourceSquareConfigurationCredentialsSourceSquareAuthenticationApiKey {
    apiKey: string;
    authType: string;
}

export interface SourceSquareConfigurationCredentialsSourceSquareAuthenticationOauthAuthentication {
    authType: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
}

export interface SourceSquareConfigurationCredentialsSourceSquareUpdateAuthenticationApiKey {
    apiKey: string;
    authType: string;
}

export interface SourceSquareConfigurationCredentialsSourceSquareUpdateAuthenticationOauthAuthentication {
    authType: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
}

export interface SourceStravaConfiguration {
    /**
     * The Athlete ID of your Strava developer application.
     */
    athleteId: number;
    /**
     * must be one of ["Client"]
     */
    authType?: string;
    /**
     * The Client ID of your Strava developer application.
     */
    clientId: string;
    /**
     * The Client Secret of your Strava developer application.
     */
    clientSecret: string;
    /**
     * The Refresh Token with the activity: readAll permissions.
     */
    refreshToken: string;
    /**
     * must be one of ["strava"]
     */
    sourceType: string;
    /**
     * UTC date and time. Any data before this date will not be replicated.
     */
    startDate: string;
}

export interface SourceStripeConfiguration {
    /**
     * Your Stripe account ID (starts with 'acct_', find yours \n\nhere\n\n).
     */
    accountId: string;
    /**
     * Stripe API key (usually starts with 'sk*live*'; find yours \n\nhere\n\n).
     */
    clientSecret: string;
    /**
     * When set, the connector will always re-export data from the past N days, where N is the value set here. This is useful if your data is frequently updated after creation. More info \n\nhere\n\n
     */
    lookbackWindowDays?: number;
    /**
     * The time increment used by the connector when requesting data from the Stripe API. The bigger the value is, the less requests will be made and faster the sync will be. On the other hand, the more seldom the state is persisted.
     */
    sliceRange?: number;
    /**
     * must be one of ["stripe"]
     */
    sourceType: string;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Only data generated after this date will be replicated.
     */
    startDate: string;
}

export interface SourceSurveySparrowConfiguration {
    /**
     * Your access token. See \n\nhere\n\n. The key is case sensitive.
     */
    accessToken: string;
    /**
     * Is your account location is EU based? If yes, the base url to retrieve data will be different.
     */
    region?: outputs.SourceSurveySparrowConfigurationRegion;
    /**
     * must be one of ["survey-sparrow"]
     */
    sourceType: string;
    /**
     * A List of your survey ids for survey-specific stream
     */
    surveyIds?: string[];
}

export interface SourceSurveySparrowConfigurationRegion {
    sourceSurveySparrowBaseUrlEuBasedAccount?: outputs.SourceSurveySparrowConfigurationRegionSourceSurveySparrowBaseUrlEuBasedAccount;
    sourceSurveySparrowBaseUrlGlobalAccount?: outputs.SourceSurveySparrowConfigurationRegionSourceSurveySparrowBaseUrlGlobalAccount;
    sourceSurveySparrowUpdateBaseUrlEuBasedAccount?: outputs.SourceSurveySparrowConfigurationRegionSourceSurveySparrowUpdateBaseUrlEuBasedAccount;
    sourceSurveySparrowUpdateBaseUrlGlobalAccount?: outputs.SourceSurveySparrowConfigurationRegionSourceSurveySparrowUpdateBaseUrlGlobalAccount;
}

export interface SourceSurveySparrowConfigurationRegionSourceSurveySparrowBaseUrlEuBasedAccount {
    urlBase?: string;
}

export interface SourceSurveySparrowConfigurationRegionSourceSurveySparrowBaseUrlGlobalAccount {
    urlBase?: string;
}

export interface SourceSurveySparrowConfigurationRegionSourceSurveySparrowUpdateBaseUrlEuBasedAccount {
    urlBase?: string;
}

export interface SourceSurveySparrowConfigurationRegionSourceSurveySparrowUpdateBaseUrlGlobalAccount {
    urlBase?: string;
}

export interface SourceSurveymonkeyConfiguration {
    /**
     * The authorization method to use to retrieve data from SurveyMonkey
     */
    credentials?: outputs.SourceSurveymonkeyConfigurationCredentials;
    /**
     * must be one of ["USA", "Europe", "Canada"]
     * Depending on the originating datacenter of the SurveyMonkey account, the API access URL may be different.
     */
    origin?: string;
    /**
     * must be one of ["surveymonkey"]
     */
    sourceType: string;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
     */
    startDate: string;
    /**
     * IDs of the surveys from which you'd like to replicate data. If left empty, data from all boards to which you have access will be replicated.
     */
    surveyIds?: string[];
}

export interface SourceSurveymonkeyConfigurationCredentials {
    accessToken: string;
    authMethod: string;
    clientId?: string;
    clientSecret?: string;
}

export interface SourceTempoConfiguration {
    /**
     * Tempo API Token. Go to Tempo>Settings, scroll down to Data Access and select API integration.
     */
    apiToken: string;
    /**
     * must be one of ["tempo"]
     */
    sourceType: string;
}

export interface SourceTheGuardianApiConfiguration {
    /**
     * Your API Key. See \n\nhere\n\n. The key is case sensitive.
     */
    apiKey: string;
    /**
     * (Optional) Use this to set the maximum date (YYYY-MM-DD) of the results. Results newer than the endDate will not be shown. Default is set to the current date (today) for incremental syncs.
     */
    endDate?: string;
    /**
     * (Optional) The query (q) parameter filters the results to only those that include that search term. The q parameter supports AND, OR and NOT operators.
     */
    query?: string;
    /**
     * (Optional) Use this to filter the results by a particular section. See \n\nhere\n\n for a list of all sections, and \n\nhere\n\n for the sections endpoint documentation.
     */
    section?: string;
    /**
     * must be one of ["the-guardian-api"]
     */
    sourceType: string;
    /**
     * Use this to set the minimum date (YYYY-MM-DD) of the results. Results older than the startDate will not be shown.
     */
    startDate: string;
    /**
     * (Optional) A tag is a piece of data that is used by The Guardian to categorise content. Use this parameter to filter results by showing only the ones matching the entered tag. See \n\nhere\n\n for a list of all tags, and \n\nhere\n\n for the tags endpoint documentation.
     */
    tag?: string;
}

export interface SourceTiktokMarketingConfiguration {
    /**
     * The attribution window in days.
     */
    attributionWindow?: number;
    /**
     * Authentication method
     */
    credentials?: outputs.SourceTiktokMarketingConfigurationCredentials;
    /**
     * The date until which you'd like to replicate data for all incremental streams, in the format YYYY-MM-DD. All data generated between startDate and this date will be replicated. Not setting this option will result in always syncing the data till the current date.
     */
    endDate?: string;
    /**
     * Set to active if you want to include deleted data in reports.
     */
    includeDeleted?: boolean;
    /**
     * must be one of ["tiktok-marketing"]
     */
    sourceType?: string;
    /**
     * The Start Date in format: YYYY-MM-DD. Any data before this date will not be replicated. If this parameter is not set, all data will be replicated.
     */
    startDate?: string;
}

export interface SourceTiktokMarketingConfigurationCredentials {
    sourceTiktokMarketingAuthenticationMethodOAuth20?: outputs.SourceTiktokMarketingConfigurationCredentialsSourceTiktokMarketingAuthenticationMethodOAuth20;
    sourceTiktokMarketingAuthenticationMethodSandboxAccessToken?: outputs.SourceTiktokMarketingConfigurationCredentialsSourceTiktokMarketingAuthenticationMethodSandboxAccessToken;
    sourceTiktokMarketingUpdateAuthenticationMethodOAuth20?: outputs.SourceTiktokMarketingConfigurationCredentialsSourceTiktokMarketingUpdateAuthenticationMethodOAuth20;
    sourceTiktokMarketingUpdateAuthenticationMethodSandboxAccessToken?: outputs.SourceTiktokMarketingConfigurationCredentialsSourceTiktokMarketingUpdateAuthenticationMethodSandboxAccessToken;
}

export interface SourceTiktokMarketingConfigurationCredentialsSourceTiktokMarketingAuthenticationMethodOAuth20 {
    accessToken: string;
    advertiserId?: string;
    appId: string;
    authType?: string;
    secret: string;
}

export interface SourceTiktokMarketingConfigurationCredentialsSourceTiktokMarketingAuthenticationMethodSandboxAccessToken {
    accessToken: string;
    advertiserId: string;
    authType?: string;
}

export interface SourceTiktokMarketingConfigurationCredentialsSourceTiktokMarketingUpdateAuthenticationMethodOAuth20 {
    accessToken: string;
    advertiserId?: string;
    appId: string;
    authType?: string;
    secret: string;
}

export interface SourceTiktokMarketingConfigurationCredentialsSourceTiktokMarketingUpdateAuthenticationMethodSandboxAccessToken {
    accessToken: string;
    advertiserId: string;
    authType?: string;
}

export interface SourceTodoistConfiguration {
    /**
     * must be one of ["todoist"]
     */
    sourceType: string;
    /**
     * Your API Token. See \n\nhere\n\n. The token is case sensitive.
     */
    token: string;
}

export interface SourceTrelloConfiguration {
    /**
     * IDs of the boards to replicate data from. If left empty, data from all boards to which you have access will be replicated.
     */
    boardIds?: string[];
    /**
     * Trello API key. See the \n\ndocs\n\n for instructions on how to generate it.
     */
    key: string;
    /**
     * must be one of ["trello"]
     */
    sourceType: string;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
     */
    startDate: string;
    /**
     * Trello API token. See the \n\ndocs\n\n for instructions on how to generate it.
     */
    token: string;
}

export interface SourceTrustpilotConfiguration {
    /**
     * The names of business units which shall be synchronized. Some streams e.g. configured*business*units or privateReviews use this configuration.
     */
    businessUnits: string[];
    credentials: outputs.SourceTrustpilotConfigurationCredentials;
    /**
     * must be one of ["trustpilot"]
     */
    sourceType: string;
    /**
     * For streams with sync. method incremental the start date time to be used
     */
    startDate: string;
}

export interface SourceTrustpilotConfigurationCredentials {
    sourceTrustpilotAuthorizationMethodApiKey?: outputs.SourceTrustpilotConfigurationCredentialsSourceTrustpilotAuthorizationMethodApiKey;
    sourceTrustpilotAuthorizationMethodOAuth20?: outputs.SourceTrustpilotConfigurationCredentialsSourceTrustpilotAuthorizationMethodOAuth20;
    sourceTrustpilotUpdateAuthorizationMethodApiKey?: outputs.SourceTrustpilotConfigurationCredentialsSourceTrustpilotUpdateAuthorizationMethodApiKey;
    sourceTrustpilotUpdateAuthorizationMethodOAuth20?: outputs.SourceTrustpilotConfigurationCredentialsSourceTrustpilotUpdateAuthorizationMethodOAuth20;
}

export interface SourceTrustpilotConfigurationCredentialsSourceTrustpilotAuthorizationMethodApiKey {
    authType?: string;
    clientId: string;
}

export interface SourceTrustpilotConfigurationCredentialsSourceTrustpilotAuthorizationMethodOAuth20 {
    accessToken: string;
    authType?: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
    tokenExpiryDate: string;
}

export interface SourceTrustpilotConfigurationCredentialsSourceTrustpilotUpdateAuthorizationMethodApiKey {
    authType?: string;
    clientId: string;
}

export interface SourceTrustpilotConfigurationCredentialsSourceTrustpilotUpdateAuthorizationMethodOAuth20 {
    accessToken: string;
    authType?: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
    tokenExpiryDate: string;
}

export interface SourceTvmazeScheduleConfiguration {
    /**
     * Country code for domestic TV schedule retrieval.
     */
    domesticScheduleCountryCode: string;
    /**
     * End date for TV schedule retrieval. May be in the future. Optional.
     */
    endDate?: string;
    /**
     * must be one of ["tvmaze-schedule"]
     */
    sourceType: string;
    /**
     * Start date for TV schedule retrieval. May be in the future.
     */
    startDate: string;
    /**
     * ISO 3166-1 country code for web TV schedule retrieval. Leave blank for
     * all countries plus global web channels (e.g. Netflix). Alternatively,
     * set to 'global' for just global web channels.
     */
    webScheduleCountryCode?: string;
}

export interface SourceTwilioConfiguration {
    /**
     * Twilio account SID
     */
    accountSid: string;
    /**
     * Twilio Auth Token.
     */
    authToken: string;
    /**
     * How far into the past to look for records. (in minutes)
     */
    lookbackWindow?: number;
    /**
     * must be one of ["twilio"]
     */
    sourceType: string;
    /**
     * UTC date and time in the format 2020-10-01T00:00:00Z. Any data before this date will not be replicated.
     */
    startDate: string;
}

export interface SourceTwilioTaskrouterConfiguration {
    /**
     * Twilio Account ID
     */
    accountSid: string;
    /**
     * Twilio Auth Token
     */
    authToken: string;
    /**
     * must be one of ["twilio-taskrouter"]
     */
    sourceType: string;
}

export interface SourceTwitterConfiguration {
    /**
     * App only Bearer Token. See the \n\ndocs\n\n for more information on how to obtain this token.
     */
    apiKey: string;
    /**
     * The end date for retrieving tweets must be a minimum of 10 seconds prior to the request time.
     */
    endDate?: string;
    /**
     * Query for matching Tweets. You can learn how to build this query by reading \n\n build a query guide \n\n.
     */
    query: string;
    /**
     * must be one of ["twitter"]
     */
    sourceType: string;
    /**
     * The start date for retrieving tweets cannot be more than 7 days in the past.
     */
    startDate?: string;
}

export interface SourceTypeformConfiguration {
    credentials: outputs.SourceTypeformConfigurationCredentials;
    /**
     * When this parameter is set, the connector will replicate data only from the input forms. Otherwise, all forms in your Typeform account will be replicated. You can find form IDs in your form URLs. For example, in the URL "https://mysite.typeform.com/to/u6nXL7" the formId is u6nXL7. You can find form URLs on Share panel
     */
    formIds?: string[];
    /**
     * must be one of ["typeform"]
     */
    sourceType: string;
    /**
     * The date from which you'd like to replicate data for Typeform API, in the format YYYY-MM-DDT00:00:00Z. All data generated after this date will be replicated.
     */
    startDate?: string;
}

export interface SourceTypeformConfigurationCredentials {
    sourceTypeformAuthorizationMethodOAuth20?: outputs.SourceTypeformConfigurationCredentialsSourceTypeformAuthorizationMethodOAuth20;
    sourceTypeformAuthorizationMethodPrivateToken?: outputs.SourceTypeformConfigurationCredentialsSourceTypeformAuthorizationMethodPrivateToken;
    sourceTypeformUpdateAuthorizationMethodOAuth20?: outputs.SourceTypeformConfigurationCredentialsSourceTypeformUpdateAuthorizationMethodOAuth20;
    sourceTypeformUpdateAuthorizationMethodPrivateToken?: outputs.SourceTypeformConfigurationCredentialsSourceTypeformUpdateAuthorizationMethodPrivateToken;
}

export interface SourceTypeformConfigurationCredentialsSourceTypeformAuthorizationMethodOAuth20 {
    accessToken: string;
    authType?: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
    tokenExpiryDate: string;
}

export interface SourceTypeformConfigurationCredentialsSourceTypeformAuthorizationMethodPrivateToken {
    accessToken: string;
    authType?: string;
}

export interface SourceTypeformConfigurationCredentialsSourceTypeformUpdateAuthorizationMethodOAuth20 {
    accessToken: string;
    authType?: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
    tokenExpiryDate: string;
}

export interface SourceTypeformConfigurationCredentialsSourceTypeformUpdateAuthorizationMethodPrivateToken {
    accessToken: string;
    authType?: string;
}

export interface SourceUsCensusConfiguration {
    /**
     * Your API Key. Get your key \n\nhere\n\n.
     */
    apiKey: string;
    /**
     * The query parameters portion of the GET request, without the api key
     */
    queryParams?: string;
    /**
     * The path portion of the GET request
     */
    queryPath: string;
    /**
     * must be one of ["us-census"]
     */
    sourceType: string;
}

export interface SourceVantageConfiguration {
    /**
     * Your API Access token. See \n\nhere\n\n.
     */
    accessToken: string;
    /**
     * must be one of ["vantage"]
     */
    sourceType: string;
}

export interface SourceWebflowConfiguration {
    /**
     * The API token for authenticating to Webflow. See https://university.webflow.com/lesson/intro-to-the-webflow-api
     */
    apiKey: string;
    /**
     * The id of the Webflow site you are requesting data from. See https://developers.webflow.com/#sites
     */
    siteId: string;
    /**
     * must be one of ["webflow"]
     */
    sourceType: string;
}

export interface SourceWhiskyHunterConfiguration {
    /**
     * must be one of ["whisky-hunter"]
     */
    sourceType?: string;
}

export interface SourceWikipediaPageviewsConfiguration {
    /**
     * If you want to filter by access method, use one of desktop, mobile-app or mobile-web. If you are interested in pageviews regardless of access method, use all-access.
     */
    access: string;
    /**
     * If you want to filter by agent type, use one of user, automated or spider. If you are interested in pageviews regardless of agent type, use all-agents.
     */
    agent: string;
    /**
     * The title of any article in the specified project. Any spaces should be replaced with underscores. It also should be URI-encoded, so that non-URI-safe characters like %, / or ? are accepted.
     */
    article: string;
    /**
     * The ISO 3166-1 alpha-2 code of a country for which to retrieve top articles.
     */
    country: string;
    /**
     * The date of the last day to include, in YYYYMMDD or YYYYMMDDHH format.
     */
    end: string;
    /**
     * If you want to filter by project, use the domain of any Wikimedia project.
     */
    project: string;
    /**
     * must be one of ["wikipedia-pageviews"]
     */
    sourceType: string;
    /**
     * The date of the first day to include, in YYYYMMDD or YYYYMMDDHH format.
     */
    start: string;
}

export interface SourceWoocommerceConfiguration {
    /**
     * Customer Key for API in WooCommerce shop
     */
    apiKey: string;
    /**
     * Customer Secret for API in WooCommerce shop
     */
    apiSecret: string;
    /**
     * The name of the store. For https://EXAMPLE.com, the shop name is 'EXAMPLE.com'.
     */
    shop: string;
    /**
     * must be one of ["woocommerce"]
     */
    sourceType: string;
    /**
     * The date you would like to replicate data from. Format: YYYY-MM-DD
     */
    startDate: string;
}

export interface SourceXeroConfiguration {
    authentication: outputs.SourceXeroConfigurationAuthentication;
    /**
     * must be one of ["xero"]
     */
    sourceType: string;
    /**
     * UTC date and time in the format YYYY-MM-DDTHH:mm:ssZ. Any data with createdAt before this data will not be synced.
     */
    startDate: string;
    /**
     * Enter your Xero organization's Tenant ID
     */
    tenantId: string;
}

export interface SourceXeroConfigurationAuthentication {
    accessToken: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
    tokenExpiryDate: string;
}

export interface SourceXkcdConfiguration {
    /**
     * must be one of ["xkcd"]
     */
    sourceType?: string;
}

export interface SourceYandexMetricaConfiguration {
    /**
     * Your Yandex Metrica API access token
     */
    authToken: string;
    /**
     * Counter ID
     */
    counterId: string;
    /**
     * Starting point for your data replication, in format of "YYYY-MM-DD". If not provided will sync till most recent date.
     */
    endDate?: string;
    /**
     * must be one of ["yandex-metrica"]
     */
    sourceType: string;
    /**
     * Starting point for your data replication, in format of "YYYY-MM-DD".
     */
    startDate: string;
}

export interface SourceYotpoConfiguration {
    /**
     * Access token recieved as a result of API call to https://api.yotpo.com/oauth/token (Ref- https://apidocs.yotpo.com/reference/yotpo-authentication)
     */
    accessToken: string;
    /**
     * App key found at settings (Ref- https://settings.yotpo.com/#/general_settings)
     */
    appKey: string;
    /**
     * Email address registered with yotpo.
     */
    email: string;
    /**
     * must be one of ["yotpo"]
     */
    sourceType: string;
    /**
     * Date time filter for incremental filter, Specify which date to extract from.
     */
    startDate: string;
}

export interface SourceYouniumConfiguration {
    /**
     * Legal Entity that data should be pulled from
     */
    legalEntity: string;
    /**
     * Account password for younium account API key
     */
    password: string;
    /**
     * Property defining if connector is used against playground or production environment
     */
    playground?: boolean;
    /**
     * must be one of ["younium"]
     */
    sourceType: string;
    /**
     * Username for Younium account
     */
    username: string;
}

export interface SourceYoutubeAnalyticsConfiguration {
    credentials: outputs.SourceYoutubeAnalyticsConfigurationCredentials;
    /**
     * must be one of ["youtube-analytics"]
     */
    sourceType: string;
}

export interface SourceYoutubeAnalyticsConfigurationCredentials {
    additionalProperties?: string;
    clientId: string;
    clientSecret: string;
    refreshToken: string;
}

export interface SourceZendeskChatConfiguration {
    credentials?: outputs.SourceZendeskChatConfigurationCredentials;
    /**
     * must be one of ["zendesk-chat"]
     */
    sourceType: string;
    /**
     * The date from which you'd like to replicate data for Zendesk Chat API, in the format YYYY-MM-DDT00:00:00Z.
     */
    startDate: string;
    /**
     * Required if you access Zendesk Chat from a Zendesk Support subdomain.
     */
    subdomain?: string;
}

export interface SourceZendeskChatConfigurationCredentials {
    sourceZendeskChatAuthorizationMethodAccessToken?: outputs.SourceZendeskChatConfigurationCredentialsSourceZendeskChatAuthorizationMethodAccessToken;
    sourceZendeskChatAuthorizationMethodOAuth20?: outputs.SourceZendeskChatConfigurationCredentialsSourceZendeskChatAuthorizationMethodOAuth20;
    sourceZendeskChatUpdateAuthorizationMethodAccessToken?: outputs.SourceZendeskChatConfigurationCredentialsSourceZendeskChatUpdateAuthorizationMethodAccessToken;
    sourceZendeskChatUpdateAuthorizationMethodOAuth20?: outputs.SourceZendeskChatConfigurationCredentialsSourceZendeskChatUpdateAuthorizationMethodOAuth20;
}

export interface SourceZendeskChatConfigurationCredentialsSourceZendeskChatAuthorizationMethodAccessToken {
    accessToken: string;
    credentials: string;
}

export interface SourceZendeskChatConfigurationCredentialsSourceZendeskChatAuthorizationMethodOAuth20 {
    accessToken?: string;
    clientId?: string;
    clientSecret?: string;
    credentials: string;
    refreshToken?: string;
}

export interface SourceZendeskChatConfigurationCredentialsSourceZendeskChatUpdateAuthorizationMethodAccessToken {
    accessToken: string;
    credentials: string;
}

export interface SourceZendeskChatConfigurationCredentialsSourceZendeskChatUpdateAuthorizationMethodOAuth20 {
    accessToken?: string;
    clientId?: string;
    clientSecret?: string;
    credentials: string;
    refreshToken?: string;
}

export interface SourceZendeskSunshineConfiguration {
    credentials?: outputs.SourceZendeskSunshineConfigurationCredentials;
    /**
     * must be one of ["zendesk-sunshine"]
     */
    sourceType: string;
    /**
     * The date from which you'd like to replicate data for Zendesk Sunshine API, in the format YYYY-MM-DDT00:00:00Z.
     */
    startDate: string;
    /**
     * The subdomain for your Zendesk Account.
     */
    subdomain: string;
}

export interface SourceZendeskSunshineConfigurationCredentials {
    sourceZendeskSunshineAuthorizationMethodApiToken?: outputs.SourceZendeskSunshineConfigurationCredentialsSourceZendeskSunshineAuthorizationMethodApiToken;
    sourceZendeskSunshineAuthorizationMethodOAuth20?: outputs.SourceZendeskSunshineConfigurationCredentialsSourceZendeskSunshineAuthorizationMethodOAuth20;
    sourceZendeskSunshineUpdateAuthorizationMethodApiToken?: outputs.SourceZendeskSunshineConfigurationCredentialsSourceZendeskSunshineUpdateAuthorizationMethodApiToken;
    sourceZendeskSunshineUpdateAuthorizationMethodOAuth20?: outputs.SourceZendeskSunshineConfigurationCredentialsSourceZendeskSunshineUpdateAuthorizationMethodOAuth20;
}

export interface SourceZendeskSunshineConfigurationCredentialsSourceZendeskSunshineAuthorizationMethodApiToken {
    additionalProperties?: string;
    apiToken: string;
    authMethod: string;
    email: string;
}

export interface SourceZendeskSunshineConfigurationCredentialsSourceZendeskSunshineAuthorizationMethodOAuth20 {
    accessToken: string;
    additionalProperties?: string;
    authMethod: string;
    clientId: string;
    clientSecret: string;
}

export interface SourceZendeskSunshineConfigurationCredentialsSourceZendeskSunshineUpdateAuthorizationMethodApiToken {
    additionalProperties?: string;
    apiToken: string;
    authMethod: string;
    email: string;
}

export interface SourceZendeskSunshineConfigurationCredentialsSourceZendeskSunshineUpdateAuthorizationMethodOAuth20 {
    accessToken: string;
    additionalProperties?: string;
    authMethod: string;
    clientId: string;
    clientSecret: string;
}

export interface SourceZendeskSupportConfiguration {
    /**
     * Zendesk allows two authentication methods. We recommend using `OAuth2.0` for Airbyte Cloud users and `API token` for Airbyte Open Source users.
     */
    credentials?: outputs.SourceZendeskSupportConfigurationCredentials;
    /**
     * Makes each stream read a single page of data.
     */
    ignorePagination?: boolean;
    /**
     * must be one of ["zendesk-support"]
     */
    sourceType: string;
    /**
     * The UTC date and time from which you'd like to replicate data, in the format YYYY-MM-DDT00:00:00Z. All data generated after this date will be replicated.
     */
    startDate: string;
    /**
     * This is your unique Zendesk subdomain that can be found in your account URL. For example, in https://MY*SUBDOMAIN.zendesk.com/, MY*SUBDOMAIN is the value of your subdomain.
     */
    subdomain: string;
}

export interface SourceZendeskSupportConfigurationCredentials {
    sourceZendeskSupportAuthenticationApiToken?: outputs.SourceZendeskSupportConfigurationCredentialsSourceZendeskSupportAuthenticationApiToken;
    sourceZendeskSupportAuthenticationOAuth20?: outputs.SourceZendeskSupportConfigurationCredentialsSourceZendeskSupportAuthenticationOAuth20;
    sourceZendeskSupportUpdateAuthenticationApiToken?: outputs.SourceZendeskSupportConfigurationCredentialsSourceZendeskSupportUpdateAuthenticationApiToken;
    sourceZendeskSupportUpdateAuthenticationOAuth20?: outputs.SourceZendeskSupportConfigurationCredentialsSourceZendeskSupportUpdateAuthenticationOAuth20;
}

export interface SourceZendeskSupportConfigurationCredentialsSourceZendeskSupportAuthenticationApiToken {
    additionalProperties?: string;
    apiToken: string;
    credentials?: string;
    email: string;
}

export interface SourceZendeskSupportConfigurationCredentialsSourceZendeskSupportAuthenticationOAuth20 {
    accessToken: string;
    additionalProperties?: string;
    clientId?: string;
    clientSecret?: string;
    credentials?: string;
}

export interface SourceZendeskSupportConfigurationCredentialsSourceZendeskSupportUpdateAuthenticationApiToken {
    additionalProperties?: string;
    apiToken: string;
    credentials?: string;
    email: string;
}

export interface SourceZendeskSupportConfigurationCredentialsSourceZendeskSupportUpdateAuthenticationOAuth20 {
    accessToken: string;
    additionalProperties?: string;
    clientId?: string;
    clientSecret?: string;
    credentials?: string;
}

export interface SourceZendeskTalkConfiguration {
    /**
     * Zendesk service provides two authentication methods. Choose between: `OAuth2.0` or `API token`.
     */
    credentials?: outputs.SourceZendeskTalkConfigurationCredentials;
    /**
     * must be one of ["zendesk-talk"]
     */
    sourceType: string;
    /**
     * The date from which you'd like to replicate data for Zendesk Talk API, in the format YYYY-MM-DDT00:00:00Z. All data generated after this date will be replicated.
     */
    startDate: string;
    /**
     * This is your Zendesk subdomain that can be found in your account URL. For example, in https://{MY*SUBDOMAIN}.zendesk.com/, where MY*SUBDOMAIN is the value of your subdomain.
     */
    subdomain: string;
}

export interface SourceZendeskTalkConfigurationCredentials {
    sourceZendeskTalkAuthenticationApiToken?: outputs.SourceZendeskTalkConfigurationCredentialsSourceZendeskTalkAuthenticationApiToken;
    sourceZendeskTalkAuthenticationOAuth20?: outputs.SourceZendeskTalkConfigurationCredentialsSourceZendeskTalkAuthenticationOAuth20;
    sourceZendeskTalkUpdateAuthenticationApiToken?: outputs.SourceZendeskTalkConfigurationCredentialsSourceZendeskTalkUpdateAuthenticationApiToken;
    sourceZendeskTalkUpdateAuthenticationOAuth20?: outputs.SourceZendeskTalkConfigurationCredentialsSourceZendeskTalkUpdateAuthenticationOAuth20;
}

export interface SourceZendeskTalkConfigurationCredentialsSourceZendeskTalkAuthenticationApiToken {
    additionalProperties?: string;
    apiToken: string;
    authType?: string;
    email: string;
}

export interface SourceZendeskTalkConfigurationCredentialsSourceZendeskTalkAuthenticationOAuth20 {
    accessToken: string;
    additionalProperties?: string;
    authType?: string;
    clientId?: string;
    clientSecret?: string;
}

export interface SourceZendeskTalkConfigurationCredentialsSourceZendeskTalkUpdateAuthenticationApiToken {
    additionalProperties?: string;
    apiToken: string;
    authType?: string;
    email: string;
}

export interface SourceZendeskTalkConfigurationCredentialsSourceZendeskTalkUpdateAuthenticationOAuth20 {
    accessToken: string;
    additionalProperties?: string;
    authType?: string;
    clientId?: string;
    clientSecret?: string;
}

export interface SourceZenloopConfiguration {
    /**
     * Zenloop API Token. You can get the API token in settings page \n\nhere\n\n
     */
    apiToken: string;
    /**
     * Zenloop date_from. Format: 2021-10-24T03:30:30Z or 2021-10-24. Leave empty if only data from current data should be synced
     */
    dateFrom?: string;
    /**
     * must be one of ["zenloop"]
     */
    sourceType: string;
    /**
     * Zenloop Survey Group ID. Can be found by pulling All Survey Groups via SurveyGroups stream. Leave empty to pull answers from all survey groups
     */
    surveyGroupId?: string;
    /**
     * Zenloop Survey ID. Can be found \n\nhere\n\n. Leave empty to pull answers from all surveys
     */
    surveyId?: string;
}

export interface SourceZohoCrmConfiguration {
    /**
     * OAuth2.0 Client ID
     */
    clientId: string;
    /**
     * OAuth2.0 Client Secret
     */
    clientSecret: string;
    /**
     * must be one of ["US", "AU", "EU", "IN", "CN", "JP"]
     * Please choose the region of your Data Center location. More info by this \n\nLink\n\n
     */
    dcRegion: string;
    /**
     * must be one of ["Free", "Standard", "Professional", "Enterprise", "Ultimate"]
     * Choose your Edition of Zoho CRM to determine API Concurrency Limits
     */
    edition: string;
    /**
     * must be one of ["Production", "Developer", "Sandbox"]
     * Please choose the environment
     */
    environment: string;
    /**
     * OAuth2.0 Refresh Token
     */
    refreshToken: string;
    /**
     * must be one of ["zoho-crm"]
     */
    sourceType: string;
    /**
     * ISO 8601, for instance: `YYYY-MM-DD`, `YYYY-MM-DD HH:MM:SS+HH:MM`
     */
    startDatetime?: string;
}

export interface SourceZoomConfiguration {
    /**
     * JWT Token
     */
    jwtToken: string;
    /**
     * must be one of ["zoom"]
     */
    sourceType: string;
}

export interface SourceZuoraConfiguration {
    /**
     * Your OAuth user Client ID
     */
    clientId: string;
    /**
     * Your OAuth user Client Secret
     */
    clientSecret: string;
    /**
     * must be one of ["Live", "Unlimited"]
     * Choose between `Live`, or `Unlimited` - the optimized, replicated database at 12 hours freshness for high volume extraction \n\nLink\n\n
     */
    dataQuery: string;
    /**
     * must be one of ["zuora"]
     */
    sourceType: string;
    /**
     * Start Date in format: YYYY-MM-DD
     */
    startDate: string;
    /**
     * must be one of ["US Production", "US Cloud Production", "US API Sandbox", "US Cloud API Sandbox", "US Central Sandbox", "US Performance Test", "EU Production", "EU API Sandbox", "EU Central Sandbox"]
     * Please choose the right endpoint where your Tenant is located. More info by this \n\nLink\n\n
     */
    tenantEndpoint: string;
    /**
     * The amount of days for each data-chunk begining from start_date. Bigger the value - faster the fetch. (0.1 - as for couple of hours, 1 - as for a Day; 364 - as for a Year).
     */
    windowInDays?: string;
}

